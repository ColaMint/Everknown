/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "NoteStore_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace evernote { namespace edam {

int _kShareRelationshipPrivilegeLevelValues[] = {
  ShareRelationshipPrivilegeLevel::READ_NOTEBOOK,
  ShareRelationshipPrivilegeLevel::READ_NOTEBOOK_PLUS_ACTIVITY,
  ShareRelationshipPrivilegeLevel::MODIFY_NOTEBOOK_PLUS_ACTIVITY,
  ShareRelationshipPrivilegeLevel::FULL_ACCESS
};
const char* _kShareRelationshipPrivilegeLevelNames[] = {
  "READ_NOTEBOOK",
  "READ_NOTEBOOK_PLUS_ACTIVITY",
  "MODIFY_NOTEBOOK_PLUS_ACTIVITY",
  "FULL_ACCESS"
};
const std::map<int, const char*> _ShareRelationshipPrivilegeLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kShareRelationshipPrivilegeLevelValues, _kShareRelationshipPrivilegeLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


SyncState::~SyncState() throw() {
}


void SyncState::__set_currentTime(const  ::evernote::edam::Timestamp val) {
  this->currentTime = val;
}

void SyncState::__set_fullSyncBefore(const  ::evernote::edam::Timestamp val) {
  this->fullSyncBefore = val;
}

void SyncState::__set_updateCount(const int32_t val) {
  this->updateCount = val;
}

void SyncState::__set_uploaded(const int64_t val) {
  this->uploaded = val;
__isset.uploaded = true;
}

void SyncState::__set_userLastUpdated(const  ::evernote::edam::Timestamp val) {
  this->userLastUpdated = val;
__isset.userLastUpdated = true;
}

void SyncState::__set_userMaxMessageEventId(const  ::evernote::edam::MessageEventID val) {
  this->userMaxMessageEventId = val;
__isset.userMaxMessageEventId = true;
}

uint32_t SyncState::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_currentTime = false;
  bool isset_fullSyncBefore = false;
  bool isset_updateCount = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->currentTime);
          isset_currentTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fullSyncBefore);
          isset_fullSyncBefore = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->updateCount);
          isset_updateCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uploaded);
          this->__isset.uploaded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->userLastUpdated);
          this->__isset.userLastUpdated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->userMaxMessageEventId);
          this->__isset.userMaxMessageEventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_currentTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fullSyncBefore)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_updateCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SyncState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SyncState");

  xfer += oprot->writeFieldBegin("currentTime", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->currentTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fullSyncBefore", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->fullSyncBefore);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updateCount", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->updateCount);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.uploaded) {
    xfer += oprot->writeFieldBegin("uploaded", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->uploaded);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userLastUpdated) {
    xfer += oprot->writeFieldBegin("userLastUpdated", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->userLastUpdated);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userMaxMessageEventId) {
    xfer += oprot->writeFieldBegin("userMaxMessageEventId", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->userMaxMessageEventId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SyncState &a, SyncState &b) {
  using ::std::swap;
  swap(a.currentTime, b.currentTime);
  swap(a.fullSyncBefore, b.fullSyncBefore);
  swap(a.updateCount, b.updateCount);
  swap(a.uploaded, b.uploaded);
  swap(a.userLastUpdated, b.userLastUpdated);
  swap(a.userMaxMessageEventId, b.userMaxMessageEventId);
  swap(a.__isset, b.__isset);
}

SyncState::SyncState(const SyncState& other0) {
  currentTime = other0.currentTime;
  fullSyncBefore = other0.fullSyncBefore;
  updateCount = other0.updateCount;
  uploaded = other0.uploaded;
  userLastUpdated = other0.userLastUpdated;
  userMaxMessageEventId = other0.userMaxMessageEventId;
  __isset = other0.__isset;
}
SyncState& SyncState::operator=(const SyncState& other1) {
  currentTime = other1.currentTime;
  fullSyncBefore = other1.fullSyncBefore;
  updateCount = other1.updateCount;
  uploaded = other1.uploaded;
  userLastUpdated = other1.userLastUpdated;
  userMaxMessageEventId = other1.userMaxMessageEventId;
  __isset = other1.__isset;
  return *this;
}
void SyncState::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SyncState(";
  out << "currentTime=" << to_string(currentTime);
  out << ", " << "fullSyncBefore=" << to_string(fullSyncBefore);
  out << ", " << "updateCount=" << to_string(updateCount);
  out << ", " << "uploaded="; (__isset.uploaded ? (out << to_string(uploaded)) : (out << "<null>"));
  out << ", " << "userLastUpdated="; (__isset.userLastUpdated ? (out << to_string(userLastUpdated)) : (out << "<null>"));
  out << ", " << "userMaxMessageEventId="; (__isset.userMaxMessageEventId ? (out << to_string(userMaxMessageEventId)) : (out << "<null>"));
  out << ")";
}


SyncChunk::~SyncChunk() throw() {
}


void SyncChunk::__set_currentTime(const  ::evernote::edam::Timestamp val) {
  this->currentTime = val;
}

void SyncChunk::__set_chunkHighUSN(const int32_t val) {
  this->chunkHighUSN = val;
__isset.chunkHighUSN = true;
}

void SyncChunk::__set_updateCount(const int32_t val) {
  this->updateCount = val;
}

void SyncChunk::__set_notes(const std::vector< ::evernote::edam::Note> & val) {
  this->notes = val;
__isset.notes = true;
}

void SyncChunk::__set_notebooks(const std::vector< ::evernote::edam::Notebook> & val) {
  this->notebooks = val;
__isset.notebooks = true;
}

void SyncChunk::__set_tags(const std::vector< ::evernote::edam::Tag> & val) {
  this->tags = val;
__isset.tags = true;
}

void SyncChunk::__set_searches(const std::vector< ::evernote::edam::SavedSearch> & val) {
  this->searches = val;
__isset.searches = true;
}

void SyncChunk::__set_resources(const std::vector< ::evernote::edam::Resource> & val) {
  this->resources = val;
__isset.resources = true;
}

void SyncChunk::__set_expungedNotes(const std::vector< ::evernote::edam::Guid> & val) {
  this->expungedNotes = val;
__isset.expungedNotes = true;
}

void SyncChunk::__set_expungedNotebooks(const std::vector< ::evernote::edam::Guid> & val) {
  this->expungedNotebooks = val;
__isset.expungedNotebooks = true;
}

void SyncChunk::__set_expungedTags(const std::vector< ::evernote::edam::Guid> & val) {
  this->expungedTags = val;
__isset.expungedTags = true;
}

void SyncChunk::__set_expungedSearches(const std::vector< ::evernote::edam::Guid> & val) {
  this->expungedSearches = val;
__isset.expungedSearches = true;
}

void SyncChunk::__set_linkedNotebooks(const std::vector< ::evernote::edam::LinkedNotebook> & val) {
  this->linkedNotebooks = val;
__isset.linkedNotebooks = true;
}

void SyncChunk::__set_expungedLinkedNotebooks(const std::vector< ::evernote::edam::Guid> & val) {
  this->expungedLinkedNotebooks = val;
__isset.expungedLinkedNotebooks = true;
}

uint32_t SyncChunk::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_currentTime = false;
  bool isset_updateCount = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->currentTime);
          isset_currentTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->chunkHighUSN);
          this->__isset.chunkHighUSN = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->updateCount);
          isset_updateCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notes.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->notes.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->notes[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.notes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notebooks.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _etype10;
            xfer += iprot->readListBegin(_etype10, _size7);
            this->notebooks.resize(_size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              xfer += this->notebooks[_i11].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.notebooks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tags.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->tags.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->tags[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->searches.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _etype20;
            xfer += iprot->readListBegin(_etype20, _size17);
            this->searches.resize(_size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              xfer += this->searches[_i21].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.searches = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->resources.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->resources.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->resources[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.resources = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->expungedNotes.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->expungedNotes.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += iprot->readString(this->expungedNotes[_i31]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.expungedNotes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->expungedNotebooks.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->expungedNotebooks.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += iprot->readString(this->expungedNotebooks[_i36]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.expungedNotebooks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->expungedTags.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->expungedTags.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += iprot->readString(this->expungedTags[_i41]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.expungedTags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->expungedSearches.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->expungedSearches.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += iprot->readString(this->expungedSearches[_i46]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.expungedSearches = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->linkedNotebooks.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->linkedNotebooks.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += this->linkedNotebooks[_i51].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.linkedNotebooks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->expungedLinkedNotebooks.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->expungedLinkedNotebooks.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += iprot->readString(this->expungedLinkedNotebooks[_i56]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.expungedLinkedNotebooks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_currentTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_updateCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SyncChunk::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SyncChunk");

  xfer += oprot->writeFieldBegin("currentTime", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->currentTime);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.chunkHighUSN) {
    xfer += oprot->writeFieldBegin("chunkHighUSN", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->chunkHighUSN);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("updateCount", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->updateCount);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.notes) {
    xfer += oprot->writeFieldBegin("notes", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notes.size()));
      std::vector< ::evernote::edam::Note> ::const_iterator _iter57;
      for (_iter57 = this->notes.begin(); _iter57 != this->notes.end(); ++_iter57)
      {
        xfer += (*_iter57).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.notebooks) {
    xfer += oprot->writeFieldBegin("notebooks", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notebooks.size()));
      std::vector< ::evernote::edam::Notebook> ::const_iterator _iter58;
      for (_iter58 = this->notebooks.begin(); _iter58 != this->notebooks.end(); ++_iter58)
      {
        xfer += (*_iter58).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tags) {
    xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tags.size()));
      std::vector< ::evernote::edam::Tag> ::const_iterator _iter59;
      for (_iter59 = this->tags.begin(); _iter59 != this->tags.end(); ++_iter59)
      {
        xfer += (*_iter59).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.searches) {
    xfer += oprot->writeFieldBegin("searches", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->searches.size()));
      std::vector< ::evernote::edam::SavedSearch> ::const_iterator _iter60;
      for (_iter60 = this->searches.begin(); _iter60 != this->searches.end(); ++_iter60)
      {
        xfer += (*_iter60).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resources) {
    xfer += oprot->writeFieldBegin("resources", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->resources.size()));
      std::vector< ::evernote::edam::Resource> ::const_iterator _iter61;
      for (_iter61 = this->resources.begin(); _iter61 != this->resources.end(); ++_iter61)
      {
        xfer += (*_iter61).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expungedNotes) {
    xfer += oprot->writeFieldBegin("expungedNotes", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->expungedNotes.size()));
      std::vector< ::evernote::edam::Guid> ::const_iterator _iter62;
      for (_iter62 = this->expungedNotes.begin(); _iter62 != this->expungedNotes.end(); ++_iter62)
      {
        xfer += oprot->writeString((*_iter62));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expungedNotebooks) {
    xfer += oprot->writeFieldBegin("expungedNotebooks", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->expungedNotebooks.size()));
      std::vector< ::evernote::edam::Guid> ::const_iterator _iter63;
      for (_iter63 = this->expungedNotebooks.begin(); _iter63 != this->expungedNotebooks.end(); ++_iter63)
      {
        xfer += oprot->writeString((*_iter63));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expungedTags) {
    xfer += oprot->writeFieldBegin("expungedTags", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->expungedTags.size()));
      std::vector< ::evernote::edam::Guid> ::const_iterator _iter64;
      for (_iter64 = this->expungedTags.begin(); _iter64 != this->expungedTags.end(); ++_iter64)
      {
        xfer += oprot->writeString((*_iter64));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expungedSearches) {
    xfer += oprot->writeFieldBegin("expungedSearches", ::apache::thrift::protocol::T_LIST, 12);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->expungedSearches.size()));
      std::vector< ::evernote::edam::Guid> ::const_iterator _iter65;
      for (_iter65 = this->expungedSearches.begin(); _iter65 != this->expungedSearches.end(); ++_iter65)
      {
        xfer += oprot->writeString((*_iter65));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.linkedNotebooks) {
    xfer += oprot->writeFieldBegin("linkedNotebooks", ::apache::thrift::protocol::T_LIST, 13);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->linkedNotebooks.size()));
      std::vector< ::evernote::edam::LinkedNotebook> ::const_iterator _iter66;
      for (_iter66 = this->linkedNotebooks.begin(); _iter66 != this->linkedNotebooks.end(); ++_iter66)
      {
        xfer += (*_iter66).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expungedLinkedNotebooks) {
    xfer += oprot->writeFieldBegin("expungedLinkedNotebooks", ::apache::thrift::protocol::T_LIST, 14);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->expungedLinkedNotebooks.size()));
      std::vector< ::evernote::edam::Guid> ::const_iterator _iter67;
      for (_iter67 = this->expungedLinkedNotebooks.begin(); _iter67 != this->expungedLinkedNotebooks.end(); ++_iter67)
      {
        xfer += oprot->writeString((*_iter67));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SyncChunk &a, SyncChunk &b) {
  using ::std::swap;
  swap(a.currentTime, b.currentTime);
  swap(a.chunkHighUSN, b.chunkHighUSN);
  swap(a.updateCount, b.updateCount);
  swap(a.notes, b.notes);
  swap(a.notebooks, b.notebooks);
  swap(a.tags, b.tags);
  swap(a.searches, b.searches);
  swap(a.resources, b.resources);
  swap(a.expungedNotes, b.expungedNotes);
  swap(a.expungedNotebooks, b.expungedNotebooks);
  swap(a.expungedTags, b.expungedTags);
  swap(a.expungedSearches, b.expungedSearches);
  swap(a.linkedNotebooks, b.linkedNotebooks);
  swap(a.expungedLinkedNotebooks, b.expungedLinkedNotebooks);
  swap(a.__isset, b.__isset);
}

SyncChunk::SyncChunk(const SyncChunk& other68) {
  currentTime = other68.currentTime;
  chunkHighUSN = other68.chunkHighUSN;
  updateCount = other68.updateCount;
  notes = other68.notes;
  notebooks = other68.notebooks;
  tags = other68.tags;
  searches = other68.searches;
  resources = other68.resources;
  expungedNotes = other68.expungedNotes;
  expungedNotebooks = other68.expungedNotebooks;
  expungedTags = other68.expungedTags;
  expungedSearches = other68.expungedSearches;
  linkedNotebooks = other68.linkedNotebooks;
  expungedLinkedNotebooks = other68.expungedLinkedNotebooks;
  __isset = other68.__isset;
}
SyncChunk& SyncChunk::operator=(const SyncChunk& other69) {
  currentTime = other69.currentTime;
  chunkHighUSN = other69.chunkHighUSN;
  updateCount = other69.updateCount;
  notes = other69.notes;
  notebooks = other69.notebooks;
  tags = other69.tags;
  searches = other69.searches;
  resources = other69.resources;
  expungedNotes = other69.expungedNotes;
  expungedNotebooks = other69.expungedNotebooks;
  expungedTags = other69.expungedTags;
  expungedSearches = other69.expungedSearches;
  linkedNotebooks = other69.linkedNotebooks;
  expungedLinkedNotebooks = other69.expungedLinkedNotebooks;
  __isset = other69.__isset;
  return *this;
}
void SyncChunk::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SyncChunk(";
  out << "currentTime=" << to_string(currentTime);
  out << ", " << "chunkHighUSN="; (__isset.chunkHighUSN ? (out << to_string(chunkHighUSN)) : (out << "<null>"));
  out << ", " << "updateCount=" << to_string(updateCount);
  out << ", " << "notes="; (__isset.notes ? (out << to_string(notes)) : (out << "<null>"));
  out << ", " << "notebooks="; (__isset.notebooks ? (out << to_string(notebooks)) : (out << "<null>"));
  out << ", " << "tags="; (__isset.tags ? (out << to_string(tags)) : (out << "<null>"));
  out << ", " << "searches="; (__isset.searches ? (out << to_string(searches)) : (out << "<null>"));
  out << ", " << "resources="; (__isset.resources ? (out << to_string(resources)) : (out << "<null>"));
  out << ", " << "expungedNotes="; (__isset.expungedNotes ? (out << to_string(expungedNotes)) : (out << "<null>"));
  out << ", " << "expungedNotebooks="; (__isset.expungedNotebooks ? (out << to_string(expungedNotebooks)) : (out << "<null>"));
  out << ", " << "expungedTags="; (__isset.expungedTags ? (out << to_string(expungedTags)) : (out << "<null>"));
  out << ", " << "expungedSearches="; (__isset.expungedSearches ? (out << to_string(expungedSearches)) : (out << "<null>"));
  out << ", " << "linkedNotebooks="; (__isset.linkedNotebooks ? (out << to_string(linkedNotebooks)) : (out << "<null>"));
  out << ", " << "expungedLinkedNotebooks="; (__isset.expungedLinkedNotebooks ? (out << to_string(expungedLinkedNotebooks)) : (out << "<null>"));
  out << ")";
}


SyncChunkFilter::~SyncChunkFilter() throw() {
}


void SyncChunkFilter::__set_includeNotes(const bool val) {
  this->includeNotes = val;
__isset.includeNotes = true;
}

void SyncChunkFilter::__set_includeNoteResources(const bool val) {
  this->includeNoteResources = val;
__isset.includeNoteResources = true;
}

void SyncChunkFilter::__set_includeNoteAttributes(const bool val) {
  this->includeNoteAttributes = val;
__isset.includeNoteAttributes = true;
}

void SyncChunkFilter::__set_includeNotebooks(const bool val) {
  this->includeNotebooks = val;
__isset.includeNotebooks = true;
}

void SyncChunkFilter::__set_includeTags(const bool val) {
  this->includeTags = val;
__isset.includeTags = true;
}

void SyncChunkFilter::__set_includeSearches(const bool val) {
  this->includeSearches = val;
__isset.includeSearches = true;
}

void SyncChunkFilter::__set_includeResources(const bool val) {
  this->includeResources = val;
__isset.includeResources = true;
}

void SyncChunkFilter::__set_includeLinkedNotebooks(const bool val) {
  this->includeLinkedNotebooks = val;
__isset.includeLinkedNotebooks = true;
}

void SyncChunkFilter::__set_includeExpunged(const bool val) {
  this->includeExpunged = val;
__isset.includeExpunged = true;
}

void SyncChunkFilter::__set_includeNoteApplicationDataFullMap(const bool val) {
  this->includeNoteApplicationDataFullMap = val;
__isset.includeNoteApplicationDataFullMap = true;
}

void SyncChunkFilter::__set_includeResourceApplicationDataFullMap(const bool val) {
  this->includeResourceApplicationDataFullMap = val;
__isset.includeResourceApplicationDataFullMap = true;
}

void SyncChunkFilter::__set_includeNoteResourceApplicationDataFullMap(const bool val) {
  this->includeNoteResourceApplicationDataFullMap = val;
__isset.includeNoteResourceApplicationDataFullMap = true;
}

void SyncChunkFilter::__set_includeSharedNotes(const bool val) {
  this->includeSharedNotes = val;
__isset.includeSharedNotes = true;
}

void SyncChunkFilter::__set_omitSharedNotebooks(const bool val) {
  this->omitSharedNotebooks = val;
__isset.omitSharedNotebooks = true;
}

void SyncChunkFilter::__set_requireNoteContentClass(const std::string& val) {
  this->requireNoteContentClass = val;
__isset.requireNoteContentClass = true;
}

void SyncChunkFilter::__set_notebookGuids(const std::set<std::string> & val) {
  this->notebookGuids = val;
__isset.notebookGuids = true;
}

uint32_t SyncChunkFilter::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeNotes);
          this->__isset.includeNotes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeNoteResources);
          this->__isset.includeNoteResources = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeNoteAttributes);
          this->__isset.includeNoteAttributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeNotebooks);
          this->__isset.includeNotebooks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeTags);
          this->__isset.includeTags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeSearches);
          this->__isset.includeSearches = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeResources);
          this->__isset.includeResources = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeLinkedNotebooks);
          this->__isset.includeLinkedNotebooks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeExpunged);
          this->__isset.includeExpunged = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeNoteApplicationDataFullMap);
          this->__isset.includeNoteApplicationDataFullMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeResourceApplicationDataFullMap);
          this->__isset.includeResourceApplicationDataFullMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeNoteResourceApplicationDataFullMap);
          this->__isset.includeNoteResourceApplicationDataFullMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeSharedNotes);
          this->__isset.includeSharedNotes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->omitSharedNotebooks);
          this->__isset.omitSharedNotebooks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->requireNoteContentClass);
          this->__isset.requireNoteContentClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->notebookGuids.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _etype73;
            xfer += iprot->readSetBegin(_etype73, _size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              std::string _elem75;
              xfer += iprot->readString(_elem75);
              this->notebookGuids.insert(_elem75);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.notebookGuids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SyncChunkFilter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SyncChunkFilter");

  if (this->__isset.includeNotes) {
    xfer += oprot->writeFieldBegin("includeNotes", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->includeNotes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeNoteResources) {
    xfer += oprot->writeFieldBegin("includeNoteResources", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->includeNoteResources);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeNoteAttributes) {
    xfer += oprot->writeFieldBegin("includeNoteAttributes", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->includeNoteAttributes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeNotebooks) {
    xfer += oprot->writeFieldBegin("includeNotebooks", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->includeNotebooks);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeTags) {
    xfer += oprot->writeFieldBegin("includeTags", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->includeTags);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeSearches) {
    xfer += oprot->writeFieldBegin("includeSearches", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->includeSearches);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeResources) {
    xfer += oprot->writeFieldBegin("includeResources", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->includeResources);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeLinkedNotebooks) {
    xfer += oprot->writeFieldBegin("includeLinkedNotebooks", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->includeLinkedNotebooks);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeExpunged) {
    xfer += oprot->writeFieldBegin("includeExpunged", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->includeExpunged);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeNoteApplicationDataFullMap) {
    xfer += oprot->writeFieldBegin("includeNoteApplicationDataFullMap", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->includeNoteApplicationDataFullMap);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.requireNoteContentClass) {
    xfer += oprot->writeFieldBegin("requireNoteContentClass", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->requireNoteContentClass);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeResourceApplicationDataFullMap) {
    xfer += oprot->writeFieldBegin("includeResourceApplicationDataFullMap", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->includeResourceApplicationDataFullMap);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeNoteResourceApplicationDataFullMap) {
    xfer += oprot->writeFieldBegin("includeNoteResourceApplicationDataFullMap", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->includeNoteResourceApplicationDataFullMap);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.notebookGuids) {
    xfer += oprot->writeFieldBegin("notebookGuids", ::apache::thrift::protocol::T_SET, 15);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->notebookGuids.size()));
      std::set<std::string> ::const_iterator _iter76;
      for (_iter76 = this->notebookGuids.begin(); _iter76 != this->notebookGuids.end(); ++_iter76)
      {
        xfer += oprot->writeString((*_iter76));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.omitSharedNotebooks) {
    xfer += oprot->writeFieldBegin("omitSharedNotebooks", ::apache::thrift::protocol::T_BOOL, 16);
    xfer += oprot->writeBool(this->omitSharedNotebooks);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeSharedNotes) {
    xfer += oprot->writeFieldBegin("includeSharedNotes", ::apache::thrift::protocol::T_BOOL, 17);
    xfer += oprot->writeBool(this->includeSharedNotes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SyncChunkFilter &a, SyncChunkFilter &b) {
  using ::std::swap;
  swap(a.includeNotes, b.includeNotes);
  swap(a.includeNoteResources, b.includeNoteResources);
  swap(a.includeNoteAttributes, b.includeNoteAttributes);
  swap(a.includeNotebooks, b.includeNotebooks);
  swap(a.includeTags, b.includeTags);
  swap(a.includeSearches, b.includeSearches);
  swap(a.includeResources, b.includeResources);
  swap(a.includeLinkedNotebooks, b.includeLinkedNotebooks);
  swap(a.includeExpunged, b.includeExpunged);
  swap(a.includeNoteApplicationDataFullMap, b.includeNoteApplicationDataFullMap);
  swap(a.includeResourceApplicationDataFullMap, b.includeResourceApplicationDataFullMap);
  swap(a.includeNoteResourceApplicationDataFullMap, b.includeNoteResourceApplicationDataFullMap);
  swap(a.includeSharedNotes, b.includeSharedNotes);
  swap(a.omitSharedNotebooks, b.omitSharedNotebooks);
  swap(a.requireNoteContentClass, b.requireNoteContentClass);
  swap(a.notebookGuids, b.notebookGuids);
  swap(a.__isset, b.__isset);
}

SyncChunkFilter::SyncChunkFilter(const SyncChunkFilter& other77) {
  includeNotes = other77.includeNotes;
  includeNoteResources = other77.includeNoteResources;
  includeNoteAttributes = other77.includeNoteAttributes;
  includeNotebooks = other77.includeNotebooks;
  includeTags = other77.includeTags;
  includeSearches = other77.includeSearches;
  includeResources = other77.includeResources;
  includeLinkedNotebooks = other77.includeLinkedNotebooks;
  includeExpunged = other77.includeExpunged;
  includeNoteApplicationDataFullMap = other77.includeNoteApplicationDataFullMap;
  includeResourceApplicationDataFullMap = other77.includeResourceApplicationDataFullMap;
  includeNoteResourceApplicationDataFullMap = other77.includeNoteResourceApplicationDataFullMap;
  includeSharedNotes = other77.includeSharedNotes;
  omitSharedNotebooks = other77.omitSharedNotebooks;
  requireNoteContentClass = other77.requireNoteContentClass;
  notebookGuids = other77.notebookGuids;
  __isset = other77.__isset;
}
SyncChunkFilter& SyncChunkFilter::operator=(const SyncChunkFilter& other78) {
  includeNotes = other78.includeNotes;
  includeNoteResources = other78.includeNoteResources;
  includeNoteAttributes = other78.includeNoteAttributes;
  includeNotebooks = other78.includeNotebooks;
  includeTags = other78.includeTags;
  includeSearches = other78.includeSearches;
  includeResources = other78.includeResources;
  includeLinkedNotebooks = other78.includeLinkedNotebooks;
  includeExpunged = other78.includeExpunged;
  includeNoteApplicationDataFullMap = other78.includeNoteApplicationDataFullMap;
  includeResourceApplicationDataFullMap = other78.includeResourceApplicationDataFullMap;
  includeNoteResourceApplicationDataFullMap = other78.includeNoteResourceApplicationDataFullMap;
  includeSharedNotes = other78.includeSharedNotes;
  omitSharedNotebooks = other78.omitSharedNotebooks;
  requireNoteContentClass = other78.requireNoteContentClass;
  notebookGuids = other78.notebookGuids;
  __isset = other78.__isset;
  return *this;
}
void SyncChunkFilter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SyncChunkFilter(";
  out << "includeNotes="; (__isset.includeNotes ? (out << to_string(includeNotes)) : (out << "<null>"));
  out << ", " << "includeNoteResources="; (__isset.includeNoteResources ? (out << to_string(includeNoteResources)) : (out << "<null>"));
  out << ", " << "includeNoteAttributes="; (__isset.includeNoteAttributes ? (out << to_string(includeNoteAttributes)) : (out << "<null>"));
  out << ", " << "includeNotebooks="; (__isset.includeNotebooks ? (out << to_string(includeNotebooks)) : (out << "<null>"));
  out << ", " << "includeTags="; (__isset.includeTags ? (out << to_string(includeTags)) : (out << "<null>"));
  out << ", " << "includeSearches="; (__isset.includeSearches ? (out << to_string(includeSearches)) : (out << "<null>"));
  out << ", " << "includeResources="; (__isset.includeResources ? (out << to_string(includeResources)) : (out << "<null>"));
  out << ", " << "includeLinkedNotebooks="; (__isset.includeLinkedNotebooks ? (out << to_string(includeLinkedNotebooks)) : (out << "<null>"));
  out << ", " << "includeExpunged="; (__isset.includeExpunged ? (out << to_string(includeExpunged)) : (out << "<null>"));
  out << ", " << "includeNoteApplicationDataFullMap="; (__isset.includeNoteApplicationDataFullMap ? (out << to_string(includeNoteApplicationDataFullMap)) : (out << "<null>"));
  out << ", " << "includeResourceApplicationDataFullMap="; (__isset.includeResourceApplicationDataFullMap ? (out << to_string(includeResourceApplicationDataFullMap)) : (out << "<null>"));
  out << ", " << "includeNoteResourceApplicationDataFullMap="; (__isset.includeNoteResourceApplicationDataFullMap ? (out << to_string(includeNoteResourceApplicationDataFullMap)) : (out << "<null>"));
  out << ", " << "includeSharedNotes="; (__isset.includeSharedNotes ? (out << to_string(includeSharedNotes)) : (out << "<null>"));
  out << ", " << "omitSharedNotebooks="; (__isset.omitSharedNotebooks ? (out << to_string(omitSharedNotebooks)) : (out << "<null>"));
  out << ", " << "requireNoteContentClass="; (__isset.requireNoteContentClass ? (out << to_string(requireNoteContentClass)) : (out << "<null>"));
  out << ", " << "notebookGuids="; (__isset.notebookGuids ? (out << to_string(notebookGuids)) : (out << "<null>"));
  out << ")";
}


NoteFilter::~NoteFilter() throw() {
}


void NoteFilter::__set_order(const int32_t val) {
  this->order = val;
__isset.order = true;
}

void NoteFilter::__set_ascending(const bool val) {
  this->ascending = val;
__isset.ascending = true;
}

void NoteFilter::__set_words(const std::string& val) {
  this->words = val;
__isset.words = true;
}

void NoteFilter::__set_notebookGuid(const  ::evernote::edam::Guid& val) {
  this->notebookGuid = val;
__isset.notebookGuid = true;
}

void NoteFilter::__set_tagGuids(const std::vector< ::evernote::edam::Guid> & val) {
  this->tagGuids = val;
__isset.tagGuids = true;
}

void NoteFilter::__set_timeZone(const std::string& val) {
  this->timeZone = val;
__isset.timeZone = true;
}

void NoteFilter::__set_inactive(const bool val) {
  this->inactive = val;
__isset.inactive = true;
}

void NoteFilter::__set_emphasized(const std::string& val) {
  this->emphasized = val;
__isset.emphasized = true;
}

void NoteFilter::__set_includeAllReadableNotebooks(const bool val) {
  this->includeAllReadableNotebooks = val;
__isset.includeAllReadableNotebooks = true;
}

void NoteFilter::__set_context(const std::string& val) {
  this->context = val;
__isset.context = true;
}

uint32_t NoteFilter::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->order);
          this->__isset.order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ascending);
          this->__isset.ascending = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->words);
          this->__isset.words = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->notebookGuid);
          this->__isset.notebookGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tagGuids.clear();
            uint32_t _size79;
            ::apache::thrift::protocol::TType _etype82;
            xfer += iprot->readListBegin(_etype82, _size79);
            this->tagGuids.resize(_size79);
            uint32_t _i83;
            for (_i83 = 0; _i83 < _size79; ++_i83)
            {
              xfer += iprot->readString(this->tagGuids[_i83]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tagGuids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timeZone);
          this->__isset.timeZone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->inactive);
          this->__isset.inactive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->emphasized);
          this->__isset.emphasized = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeAllReadableNotebooks);
          this->__isset.includeAllReadableNotebooks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->context);
          this->__isset.context = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteFilter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteFilter");

  if (this->__isset.order) {
    xfer += oprot->writeFieldBegin("order", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->order);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ascending) {
    xfer += oprot->writeFieldBegin("ascending", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->ascending);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.words) {
    xfer += oprot->writeFieldBegin("words", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->words);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.notebookGuid) {
    xfer += oprot->writeFieldBegin("notebookGuid", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->notebookGuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tagGuids) {
    xfer += oprot->writeFieldBegin("tagGuids", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tagGuids.size()));
      std::vector< ::evernote::edam::Guid> ::const_iterator _iter84;
      for (_iter84 = this->tagGuids.begin(); _iter84 != this->tagGuids.end(); ++_iter84)
      {
        xfer += oprot->writeString((*_iter84));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeZone) {
    xfer += oprot->writeFieldBegin("timeZone", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->timeZone);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.inactive) {
    xfer += oprot->writeFieldBegin("inactive", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->inactive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.emphasized) {
    xfer += oprot->writeFieldBegin("emphasized", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->emphasized);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeAllReadableNotebooks) {
    xfer += oprot->writeFieldBegin("includeAllReadableNotebooks", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->includeAllReadableNotebooks);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.context) {
    xfer += oprot->writeFieldBegin("context", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->context);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoteFilter &a, NoteFilter &b) {
  using ::std::swap;
  swap(a.order, b.order);
  swap(a.ascending, b.ascending);
  swap(a.words, b.words);
  swap(a.notebookGuid, b.notebookGuid);
  swap(a.tagGuids, b.tagGuids);
  swap(a.timeZone, b.timeZone);
  swap(a.inactive, b.inactive);
  swap(a.emphasized, b.emphasized);
  swap(a.includeAllReadableNotebooks, b.includeAllReadableNotebooks);
  swap(a.context, b.context);
  swap(a.__isset, b.__isset);
}

NoteFilter::NoteFilter(const NoteFilter& other85) {
  order = other85.order;
  ascending = other85.ascending;
  words = other85.words;
  notebookGuid = other85.notebookGuid;
  tagGuids = other85.tagGuids;
  timeZone = other85.timeZone;
  inactive = other85.inactive;
  emphasized = other85.emphasized;
  includeAllReadableNotebooks = other85.includeAllReadableNotebooks;
  context = other85.context;
  __isset = other85.__isset;
}
NoteFilter& NoteFilter::operator=(const NoteFilter& other86) {
  order = other86.order;
  ascending = other86.ascending;
  words = other86.words;
  notebookGuid = other86.notebookGuid;
  tagGuids = other86.tagGuids;
  timeZone = other86.timeZone;
  inactive = other86.inactive;
  emphasized = other86.emphasized;
  includeAllReadableNotebooks = other86.includeAllReadableNotebooks;
  context = other86.context;
  __isset = other86.__isset;
  return *this;
}
void NoteFilter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoteFilter(";
  out << "order="; (__isset.order ? (out << to_string(order)) : (out << "<null>"));
  out << ", " << "ascending="; (__isset.ascending ? (out << to_string(ascending)) : (out << "<null>"));
  out << ", " << "words="; (__isset.words ? (out << to_string(words)) : (out << "<null>"));
  out << ", " << "notebookGuid="; (__isset.notebookGuid ? (out << to_string(notebookGuid)) : (out << "<null>"));
  out << ", " << "tagGuids="; (__isset.tagGuids ? (out << to_string(tagGuids)) : (out << "<null>"));
  out << ", " << "timeZone="; (__isset.timeZone ? (out << to_string(timeZone)) : (out << "<null>"));
  out << ", " << "inactive="; (__isset.inactive ? (out << to_string(inactive)) : (out << "<null>"));
  out << ", " << "emphasized="; (__isset.emphasized ? (out << to_string(emphasized)) : (out << "<null>"));
  out << ", " << "includeAllReadableNotebooks="; (__isset.includeAllReadableNotebooks ? (out << to_string(includeAllReadableNotebooks)) : (out << "<null>"));
  out << ", " << "context="; (__isset.context ? (out << to_string(context)) : (out << "<null>"));
  out << ")";
}


NoteList::~NoteList() throw() {
}


void NoteList::__set_startIndex(const int32_t val) {
  this->startIndex = val;
}

void NoteList::__set_totalNotes(const int32_t val) {
  this->totalNotes = val;
}

void NoteList::__set_notes(const std::vector< ::evernote::edam::Note> & val) {
  this->notes = val;
}

void NoteList::__set_stoppedWords(const std::vector<std::string> & val) {
  this->stoppedWords = val;
__isset.stoppedWords = true;
}

void NoteList::__set_searchedWords(const std::vector<std::string> & val) {
  this->searchedWords = val;
__isset.searchedWords = true;
}

void NoteList::__set_updateCount(const int32_t val) {
  this->updateCount = val;
__isset.updateCount = true;
}

uint32_t NoteList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_startIndex = false;
  bool isset_totalNotes = false;
  bool isset_notes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->startIndex);
          isset_startIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalNotes);
          isset_totalNotes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notes.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readListBegin(_etype90, _size87);
            this->notes.resize(_size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              xfer += this->notes[_i91].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_notes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stoppedWords.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _etype95;
            xfer += iprot->readListBegin(_etype95, _size92);
            this->stoppedWords.resize(_size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              xfer += iprot->readString(this->stoppedWords[_i96]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stoppedWords = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->searchedWords.clear();
            uint32_t _size97;
            ::apache::thrift::protocol::TType _etype100;
            xfer += iprot->readListBegin(_etype100, _size97);
            this->searchedWords.resize(_size97);
            uint32_t _i101;
            for (_i101 = 0; _i101 < _size97; ++_i101)
            {
              xfer += iprot->readString(this->searchedWords[_i101]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.searchedWords = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->updateCount);
          this->__isset.updateCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_startIndex)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_totalNotes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_notes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NoteList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteList");

  xfer += oprot->writeFieldBegin("startIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->startIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalNotes", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->totalNotes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notes", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notes.size()));
    std::vector< ::evernote::edam::Note> ::const_iterator _iter102;
    for (_iter102 = this->notes.begin(); _iter102 != this->notes.end(); ++_iter102)
    {
      xfer += (*_iter102).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stoppedWords) {
    xfer += oprot->writeFieldBegin("stoppedWords", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->stoppedWords.size()));
      std::vector<std::string> ::const_iterator _iter103;
      for (_iter103 = this->stoppedWords.begin(); _iter103 != this->stoppedWords.end(); ++_iter103)
      {
        xfer += oprot->writeString((*_iter103));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.searchedWords) {
    xfer += oprot->writeFieldBegin("searchedWords", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->searchedWords.size()));
      std::vector<std::string> ::const_iterator _iter104;
      for (_iter104 = this->searchedWords.begin(); _iter104 != this->searchedWords.end(); ++_iter104)
      {
        xfer += oprot->writeString((*_iter104));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updateCount) {
    xfer += oprot->writeFieldBegin("updateCount", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->updateCount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoteList &a, NoteList &b) {
  using ::std::swap;
  swap(a.startIndex, b.startIndex);
  swap(a.totalNotes, b.totalNotes);
  swap(a.notes, b.notes);
  swap(a.stoppedWords, b.stoppedWords);
  swap(a.searchedWords, b.searchedWords);
  swap(a.updateCount, b.updateCount);
  swap(a.__isset, b.__isset);
}

NoteList::NoteList(const NoteList& other105) {
  startIndex = other105.startIndex;
  totalNotes = other105.totalNotes;
  notes = other105.notes;
  stoppedWords = other105.stoppedWords;
  searchedWords = other105.searchedWords;
  updateCount = other105.updateCount;
  __isset = other105.__isset;
}
NoteList& NoteList::operator=(const NoteList& other106) {
  startIndex = other106.startIndex;
  totalNotes = other106.totalNotes;
  notes = other106.notes;
  stoppedWords = other106.stoppedWords;
  searchedWords = other106.searchedWords;
  updateCount = other106.updateCount;
  __isset = other106.__isset;
  return *this;
}
void NoteList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoteList(";
  out << "startIndex=" << to_string(startIndex);
  out << ", " << "totalNotes=" << to_string(totalNotes);
  out << ", " << "notes=" << to_string(notes);
  out << ", " << "stoppedWords="; (__isset.stoppedWords ? (out << to_string(stoppedWords)) : (out << "<null>"));
  out << ", " << "searchedWords="; (__isset.searchedWords ? (out << to_string(searchedWords)) : (out << "<null>"));
  out << ", " << "updateCount="; (__isset.updateCount ? (out << to_string(updateCount)) : (out << "<null>"));
  out << ")";
}


NoteMetadata::~NoteMetadata() throw() {
}


void NoteMetadata::__set_guid(const  ::evernote::edam::Guid& val) {
  this->guid = val;
}

void NoteMetadata::__set_title(const std::string& val) {
  this->title = val;
__isset.title = true;
}

void NoteMetadata::__set_contentLength(const int32_t val) {
  this->contentLength = val;
__isset.contentLength = true;
}

void NoteMetadata::__set_created(const  ::evernote::edam::Timestamp val) {
  this->created = val;
__isset.created = true;
}

void NoteMetadata::__set_updated(const  ::evernote::edam::Timestamp val) {
  this->updated = val;
__isset.updated = true;
}

void NoteMetadata::__set_deleted(const  ::evernote::edam::Timestamp val) {
  this->deleted = val;
__isset.deleted = true;
}

void NoteMetadata::__set_updateSequenceNum(const int32_t val) {
  this->updateSequenceNum = val;
__isset.updateSequenceNum = true;
}

void NoteMetadata::__set_notebookGuid(const std::string& val) {
  this->notebookGuid = val;
__isset.notebookGuid = true;
}

void NoteMetadata::__set_tagGuids(const std::vector< ::evernote::edam::Guid> & val) {
  this->tagGuids = val;
__isset.tagGuids = true;
}

void NoteMetadata::__set_attributes(const  ::evernote::edam::NoteAttributes& val) {
  this->attributes = val;
__isset.attributes = true;
}

void NoteMetadata::__set_largestResourceMime(const std::string& val) {
  this->largestResourceMime = val;
__isset.largestResourceMime = true;
}

void NoteMetadata::__set_largestResourceSize(const int32_t val) {
  this->largestResourceSize = val;
__isset.largestResourceSize = true;
}

uint32_t NoteMetadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_guid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          isset_guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->contentLength);
          this->__isset.contentLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->created);
          this->__isset.created = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updated);
          this->__isset.updated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->deleted);
          this->__isset.deleted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->updateSequenceNum);
          this->__isset.updateSequenceNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->notebookGuid);
          this->__isset.notebookGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tagGuids.clear();
            uint32_t _size107;
            ::apache::thrift::protocol::TType _etype110;
            xfer += iprot->readListBegin(_etype110, _size107);
            this->tagGuids.resize(_size107);
            uint32_t _i111;
            for (_i111 = 0; _i111 < _size107; ++_i111)
            {
              xfer += iprot->readString(this->tagGuids[_i111]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tagGuids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attributes.read(iprot);
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->largestResourceMime);
          this->__isset.largestResourceMime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->largestResourceSize);
          this->__isset.largestResourceSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_guid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NoteMetadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteMetadata");

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.title) {
    xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->title);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.contentLength) {
    xfer += oprot->writeFieldBegin("contentLength", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->contentLength);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created) {
    xfer += oprot->writeFieldBegin("created", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->created);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated) {
    xfer += oprot->writeFieldBegin("updated", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->updated);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleted) {
    xfer += oprot->writeFieldBegin("deleted", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->deleted);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updateSequenceNum) {
    xfer += oprot->writeFieldBegin("updateSequenceNum", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->updateSequenceNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.notebookGuid) {
    xfer += oprot->writeFieldBegin("notebookGuid", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->notebookGuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tagGuids) {
    xfer += oprot->writeFieldBegin("tagGuids", ::apache::thrift::protocol::T_LIST, 12);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tagGuids.size()));
      std::vector< ::evernote::edam::Guid> ::const_iterator _iter112;
      for (_iter112 = this->tagGuids.begin(); _iter112 != this->tagGuids.end(); ++_iter112)
      {
        xfer += oprot->writeString((*_iter112));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->attributes.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.largestResourceMime) {
    xfer += oprot->writeFieldBegin("largestResourceMime", ::apache::thrift::protocol::T_STRING, 20);
    xfer += oprot->writeString(this->largestResourceMime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.largestResourceSize) {
    xfer += oprot->writeFieldBegin("largestResourceSize", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32(this->largestResourceSize);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoteMetadata &a, NoteMetadata &b) {
  using ::std::swap;
  swap(a.guid, b.guid);
  swap(a.title, b.title);
  swap(a.contentLength, b.contentLength);
  swap(a.created, b.created);
  swap(a.updated, b.updated);
  swap(a.deleted, b.deleted);
  swap(a.updateSequenceNum, b.updateSequenceNum);
  swap(a.notebookGuid, b.notebookGuid);
  swap(a.tagGuids, b.tagGuids);
  swap(a.attributes, b.attributes);
  swap(a.largestResourceMime, b.largestResourceMime);
  swap(a.largestResourceSize, b.largestResourceSize);
  swap(a.__isset, b.__isset);
}

NoteMetadata::NoteMetadata(const NoteMetadata& other113) {
  guid = other113.guid;
  title = other113.title;
  contentLength = other113.contentLength;
  created = other113.created;
  updated = other113.updated;
  deleted = other113.deleted;
  updateSequenceNum = other113.updateSequenceNum;
  notebookGuid = other113.notebookGuid;
  tagGuids = other113.tagGuids;
  attributes = other113.attributes;
  largestResourceMime = other113.largestResourceMime;
  largestResourceSize = other113.largestResourceSize;
  __isset = other113.__isset;
}
NoteMetadata& NoteMetadata::operator=(const NoteMetadata& other114) {
  guid = other114.guid;
  title = other114.title;
  contentLength = other114.contentLength;
  created = other114.created;
  updated = other114.updated;
  deleted = other114.deleted;
  updateSequenceNum = other114.updateSequenceNum;
  notebookGuid = other114.notebookGuid;
  tagGuids = other114.tagGuids;
  attributes = other114.attributes;
  largestResourceMime = other114.largestResourceMime;
  largestResourceSize = other114.largestResourceSize;
  __isset = other114.__isset;
  return *this;
}
void NoteMetadata::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoteMetadata(";
  out << "guid=" << to_string(guid);
  out << ", " << "title="; (__isset.title ? (out << to_string(title)) : (out << "<null>"));
  out << ", " << "contentLength="; (__isset.contentLength ? (out << to_string(contentLength)) : (out << "<null>"));
  out << ", " << "created="; (__isset.created ? (out << to_string(created)) : (out << "<null>"));
  out << ", " << "updated="; (__isset.updated ? (out << to_string(updated)) : (out << "<null>"));
  out << ", " << "deleted="; (__isset.deleted ? (out << to_string(deleted)) : (out << "<null>"));
  out << ", " << "updateSequenceNum="; (__isset.updateSequenceNum ? (out << to_string(updateSequenceNum)) : (out << "<null>"));
  out << ", " << "notebookGuid="; (__isset.notebookGuid ? (out << to_string(notebookGuid)) : (out << "<null>"));
  out << ", " << "tagGuids="; (__isset.tagGuids ? (out << to_string(tagGuids)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "largestResourceMime="; (__isset.largestResourceMime ? (out << to_string(largestResourceMime)) : (out << "<null>"));
  out << ", " << "largestResourceSize="; (__isset.largestResourceSize ? (out << to_string(largestResourceSize)) : (out << "<null>"));
  out << ")";
}


NotesMetadataList::~NotesMetadataList() throw() {
}


void NotesMetadataList::__set_startIndex(const int32_t val) {
  this->startIndex = val;
}

void NotesMetadataList::__set_totalNotes(const int32_t val) {
  this->totalNotes = val;
}

void NotesMetadataList::__set_notes(const std::vector<NoteMetadata> & val) {
  this->notes = val;
}

void NotesMetadataList::__set_stoppedWords(const std::vector<std::string> & val) {
  this->stoppedWords = val;
__isset.stoppedWords = true;
}

void NotesMetadataList::__set_searchedWords(const std::vector<std::string> & val) {
  this->searchedWords = val;
__isset.searchedWords = true;
}

void NotesMetadataList::__set_updateCount(const int32_t val) {
  this->updateCount = val;
__isset.updateCount = true;
}

uint32_t NotesMetadataList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_startIndex = false;
  bool isset_totalNotes = false;
  bool isset_notes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->startIndex);
          isset_startIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalNotes);
          isset_totalNotes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notes.clear();
            uint32_t _size115;
            ::apache::thrift::protocol::TType _etype118;
            xfer += iprot->readListBegin(_etype118, _size115);
            this->notes.resize(_size115);
            uint32_t _i119;
            for (_i119 = 0; _i119 < _size115; ++_i119)
            {
              xfer += this->notes[_i119].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_notes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stoppedWords.clear();
            uint32_t _size120;
            ::apache::thrift::protocol::TType _etype123;
            xfer += iprot->readListBegin(_etype123, _size120);
            this->stoppedWords.resize(_size120);
            uint32_t _i124;
            for (_i124 = 0; _i124 < _size120; ++_i124)
            {
              xfer += iprot->readString(this->stoppedWords[_i124]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stoppedWords = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->searchedWords.clear();
            uint32_t _size125;
            ::apache::thrift::protocol::TType _etype128;
            xfer += iprot->readListBegin(_etype128, _size125);
            this->searchedWords.resize(_size125);
            uint32_t _i129;
            for (_i129 = 0; _i129 < _size125; ++_i129)
            {
              xfer += iprot->readString(this->searchedWords[_i129]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.searchedWords = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->updateCount);
          this->__isset.updateCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_startIndex)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_totalNotes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_notes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotesMetadataList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotesMetadataList");

  xfer += oprot->writeFieldBegin("startIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->startIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalNotes", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->totalNotes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notes", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notes.size()));
    std::vector<NoteMetadata> ::const_iterator _iter130;
    for (_iter130 = this->notes.begin(); _iter130 != this->notes.end(); ++_iter130)
    {
      xfer += (*_iter130).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stoppedWords) {
    xfer += oprot->writeFieldBegin("stoppedWords", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->stoppedWords.size()));
      std::vector<std::string> ::const_iterator _iter131;
      for (_iter131 = this->stoppedWords.begin(); _iter131 != this->stoppedWords.end(); ++_iter131)
      {
        xfer += oprot->writeString((*_iter131));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.searchedWords) {
    xfer += oprot->writeFieldBegin("searchedWords", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->searchedWords.size()));
      std::vector<std::string> ::const_iterator _iter132;
      for (_iter132 = this->searchedWords.begin(); _iter132 != this->searchedWords.end(); ++_iter132)
      {
        xfer += oprot->writeString((*_iter132));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updateCount) {
    xfer += oprot->writeFieldBegin("updateCount", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->updateCount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotesMetadataList &a, NotesMetadataList &b) {
  using ::std::swap;
  swap(a.startIndex, b.startIndex);
  swap(a.totalNotes, b.totalNotes);
  swap(a.notes, b.notes);
  swap(a.stoppedWords, b.stoppedWords);
  swap(a.searchedWords, b.searchedWords);
  swap(a.updateCount, b.updateCount);
  swap(a.__isset, b.__isset);
}

NotesMetadataList::NotesMetadataList(const NotesMetadataList& other133) {
  startIndex = other133.startIndex;
  totalNotes = other133.totalNotes;
  notes = other133.notes;
  stoppedWords = other133.stoppedWords;
  searchedWords = other133.searchedWords;
  updateCount = other133.updateCount;
  __isset = other133.__isset;
}
NotesMetadataList& NotesMetadataList::operator=(const NotesMetadataList& other134) {
  startIndex = other134.startIndex;
  totalNotes = other134.totalNotes;
  notes = other134.notes;
  stoppedWords = other134.stoppedWords;
  searchedWords = other134.searchedWords;
  updateCount = other134.updateCount;
  __isset = other134.__isset;
  return *this;
}
void NotesMetadataList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotesMetadataList(";
  out << "startIndex=" << to_string(startIndex);
  out << ", " << "totalNotes=" << to_string(totalNotes);
  out << ", " << "notes=" << to_string(notes);
  out << ", " << "stoppedWords="; (__isset.stoppedWords ? (out << to_string(stoppedWords)) : (out << "<null>"));
  out << ", " << "searchedWords="; (__isset.searchedWords ? (out << to_string(searchedWords)) : (out << "<null>"));
  out << ", " << "updateCount="; (__isset.updateCount ? (out << to_string(updateCount)) : (out << "<null>"));
  out << ")";
}


NotesMetadataResultSpec::~NotesMetadataResultSpec() throw() {
}


void NotesMetadataResultSpec::__set_includeTitle(const bool val) {
  this->includeTitle = val;
__isset.includeTitle = true;
}

void NotesMetadataResultSpec::__set_includeContentLength(const bool val) {
  this->includeContentLength = val;
__isset.includeContentLength = true;
}

void NotesMetadataResultSpec::__set_includeCreated(const bool val) {
  this->includeCreated = val;
__isset.includeCreated = true;
}

void NotesMetadataResultSpec::__set_includeUpdated(const bool val) {
  this->includeUpdated = val;
__isset.includeUpdated = true;
}

void NotesMetadataResultSpec::__set_includeDeleted(const bool val) {
  this->includeDeleted = val;
__isset.includeDeleted = true;
}

void NotesMetadataResultSpec::__set_includeUpdateSequenceNum(const bool val) {
  this->includeUpdateSequenceNum = val;
__isset.includeUpdateSequenceNum = true;
}

void NotesMetadataResultSpec::__set_includeNotebookGuid(const bool val) {
  this->includeNotebookGuid = val;
__isset.includeNotebookGuid = true;
}

void NotesMetadataResultSpec::__set_includeTagGuids(const bool val) {
  this->includeTagGuids = val;
__isset.includeTagGuids = true;
}

void NotesMetadataResultSpec::__set_includeAttributes(const bool val) {
  this->includeAttributes = val;
__isset.includeAttributes = true;
}

void NotesMetadataResultSpec::__set_includeLargestResourceMime(const bool val) {
  this->includeLargestResourceMime = val;
__isset.includeLargestResourceMime = true;
}

void NotesMetadataResultSpec::__set_includeLargestResourceSize(const bool val) {
  this->includeLargestResourceSize = val;
__isset.includeLargestResourceSize = true;
}

uint32_t NotesMetadataResultSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeTitle);
          this->__isset.includeTitle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeContentLength);
          this->__isset.includeContentLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeCreated);
          this->__isset.includeCreated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeUpdated);
          this->__isset.includeUpdated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeDeleted);
          this->__isset.includeDeleted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeUpdateSequenceNum);
          this->__isset.includeUpdateSequenceNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeNotebookGuid);
          this->__isset.includeNotebookGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeTagGuids);
          this->__isset.includeTagGuids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeAttributes);
          this->__isset.includeAttributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeLargestResourceMime);
          this->__isset.includeLargestResourceMime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeLargestResourceSize);
          this->__isset.includeLargestResourceSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotesMetadataResultSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotesMetadataResultSpec");

  if (this->__isset.includeTitle) {
    xfer += oprot->writeFieldBegin("includeTitle", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->includeTitle);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeContentLength) {
    xfer += oprot->writeFieldBegin("includeContentLength", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->includeContentLength);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeCreated) {
    xfer += oprot->writeFieldBegin("includeCreated", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->includeCreated);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeUpdated) {
    xfer += oprot->writeFieldBegin("includeUpdated", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->includeUpdated);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeDeleted) {
    xfer += oprot->writeFieldBegin("includeDeleted", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->includeDeleted);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeUpdateSequenceNum) {
    xfer += oprot->writeFieldBegin("includeUpdateSequenceNum", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->includeUpdateSequenceNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeNotebookGuid) {
    xfer += oprot->writeFieldBegin("includeNotebookGuid", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->includeNotebookGuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeTagGuids) {
    xfer += oprot->writeFieldBegin("includeTagGuids", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->includeTagGuids);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeAttributes) {
    xfer += oprot->writeFieldBegin("includeAttributes", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->includeAttributes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeLargestResourceMime) {
    xfer += oprot->writeFieldBegin("includeLargestResourceMime", ::apache::thrift::protocol::T_BOOL, 20);
    xfer += oprot->writeBool(this->includeLargestResourceMime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeLargestResourceSize) {
    xfer += oprot->writeFieldBegin("includeLargestResourceSize", ::apache::thrift::protocol::T_BOOL, 21);
    xfer += oprot->writeBool(this->includeLargestResourceSize);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotesMetadataResultSpec &a, NotesMetadataResultSpec &b) {
  using ::std::swap;
  swap(a.includeTitle, b.includeTitle);
  swap(a.includeContentLength, b.includeContentLength);
  swap(a.includeCreated, b.includeCreated);
  swap(a.includeUpdated, b.includeUpdated);
  swap(a.includeDeleted, b.includeDeleted);
  swap(a.includeUpdateSequenceNum, b.includeUpdateSequenceNum);
  swap(a.includeNotebookGuid, b.includeNotebookGuid);
  swap(a.includeTagGuids, b.includeTagGuids);
  swap(a.includeAttributes, b.includeAttributes);
  swap(a.includeLargestResourceMime, b.includeLargestResourceMime);
  swap(a.includeLargestResourceSize, b.includeLargestResourceSize);
  swap(a.__isset, b.__isset);
}

NotesMetadataResultSpec::NotesMetadataResultSpec(const NotesMetadataResultSpec& other135) {
  includeTitle = other135.includeTitle;
  includeContentLength = other135.includeContentLength;
  includeCreated = other135.includeCreated;
  includeUpdated = other135.includeUpdated;
  includeDeleted = other135.includeDeleted;
  includeUpdateSequenceNum = other135.includeUpdateSequenceNum;
  includeNotebookGuid = other135.includeNotebookGuid;
  includeTagGuids = other135.includeTagGuids;
  includeAttributes = other135.includeAttributes;
  includeLargestResourceMime = other135.includeLargestResourceMime;
  includeLargestResourceSize = other135.includeLargestResourceSize;
  __isset = other135.__isset;
}
NotesMetadataResultSpec& NotesMetadataResultSpec::operator=(const NotesMetadataResultSpec& other136) {
  includeTitle = other136.includeTitle;
  includeContentLength = other136.includeContentLength;
  includeCreated = other136.includeCreated;
  includeUpdated = other136.includeUpdated;
  includeDeleted = other136.includeDeleted;
  includeUpdateSequenceNum = other136.includeUpdateSequenceNum;
  includeNotebookGuid = other136.includeNotebookGuid;
  includeTagGuids = other136.includeTagGuids;
  includeAttributes = other136.includeAttributes;
  includeLargestResourceMime = other136.includeLargestResourceMime;
  includeLargestResourceSize = other136.includeLargestResourceSize;
  __isset = other136.__isset;
  return *this;
}
void NotesMetadataResultSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotesMetadataResultSpec(";
  out << "includeTitle="; (__isset.includeTitle ? (out << to_string(includeTitle)) : (out << "<null>"));
  out << ", " << "includeContentLength="; (__isset.includeContentLength ? (out << to_string(includeContentLength)) : (out << "<null>"));
  out << ", " << "includeCreated="; (__isset.includeCreated ? (out << to_string(includeCreated)) : (out << "<null>"));
  out << ", " << "includeUpdated="; (__isset.includeUpdated ? (out << to_string(includeUpdated)) : (out << "<null>"));
  out << ", " << "includeDeleted="; (__isset.includeDeleted ? (out << to_string(includeDeleted)) : (out << "<null>"));
  out << ", " << "includeUpdateSequenceNum="; (__isset.includeUpdateSequenceNum ? (out << to_string(includeUpdateSequenceNum)) : (out << "<null>"));
  out << ", " << "includeNotebookGuid="; (__isset.includeNotebookGuid ? (out << to_string(includeNotebookGuid)) : (out << "<null>"));
  out << ", " << "includeTagGuids="; (__isset.includeTagGuids ? (out << to_string(includeTagGuids)) : (out << "<null>"));
  out << ", " << "includeAttributes="; (__isset.includeAttributes ? (out << to_string(includeAttributes)) : (out << "<null>"));
  out << ", " << "includeLargestResourceMime="; (__isset.includeLargestResourceMime ? (out << to_string(includeLargestResourceMime)) : (out << "<null>"));
  out << ", " << "includeLargestResourceSize="; (__isset.includeLargestResourceSize ? (out << to_string(includeLargestResourceSize)) : (out << "<null>"));
  out << ")";
}


NoteCollectionCounts::~NoteCollectionCounts() throw() {
}


void NoteCollectionCounts::__set_notebookCounts(const std::map< ::evernote::edam::Guid, int32_t> & val) {
  this->notebookCounts = val;
__isset.notebookCounts = true;
}

void NoteCollectionCounts::__set_tagCounts(const std::map< ::evernote::edam::Guid, int32_t> & val) {
  this->tagCounts = val;
__isset.tagCounts = true;
}

void NoteCollectionCounts::__set_trashCount(const int32_t val) {
  this->trashCount = val;
__isset.trashCount = true;
}

uint32_t NoteCollectionCounts::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->notebookCounts.clear();
            uint32_t _size137;
            ::apache::thrift::protocol::TType _ktype138;
            ::apache::thrift::protocol::TType _vtype139;
            xfer += iprot->readMapBegin(_ktype138, _vtype139, _size137);
            uint32_t _i141;
            for (_i141 = 0; _i141 < _size137; ++_i141)
            {
               ::evernote::edam::Guid _key142;
              xfer += iprot->readString(_key142);
              int32_t& _val143 = this->notebookCounts[_key142];
              xfer += iprot->readI32(_val143);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.notebookCounts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->tagCounts.clear();
            uint32_t _size144;
            ::apache::thrift::protocol::TType _ktype145;
            ::apache::thrift::protocol::TType _vtype146;
            xfer += iprot->readMapBegin(_ktype145, _vtype146, _size144);
            uint32_t _i148;
            for (_i148 = 0; _i148 < _size144; ++_i148)
            {
               ::evernote::edam::Guid _key149;
              xfer += iprot->readString(_key149);
              int32_t& _val150 = this->tagCounts[_key149];
              xfer += iprot->readI32(_val150);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.tagCounts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->trashCount);
          this->__isset.trashCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteCollectionCounts::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteCollectionCounts");

  if (this->__isset.notebookCounts) {
    xfer += oprot->writeFieldBegin("notebookCounts", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->notebookCounts.size()));
      std::map< ::evernote::edam::Guid, int32_t> ::const_iterator _iter151;
      for (_iter151 = this->notebookCounts.begin(); _iter151 != this->notebookCounts.end(); ++_iter151)
      {
        xfer += oprot->writeString(_iter151->first);
        xfer += oprot->writeI32(_iter151->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tagCounts) {
    xfer += oprot->writeFieldBegin("tagCounts", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->tagCounts.size()));
      std::map< ::evernote::edam::Guid, int32_t> ::const_iterator _iter152;
      for (_iter152 = this->tagCounts.begin(); _iter152 != this->tagCounts.end(); ++_iter152)
      {
        xfer += oprot->writeString(_iter152->first);
        xfer += oprot->writeI32(_iter152->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.trashCount) {
    xfer += oprot->writeFieldBegin("trashCount", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->trashCount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoteCollectionCounts &a, NoteCollectionCounts &b) {
  using ::std::swap;
  swap(a.notebookCounts, b.notebookCounts);
  swap(a.tagCounts, b.tagCounts);
  swap(a.trashCount, b.trashCount);
  swap(a.__isset, b.__isset);
}

NoteCollectionCounts::NoteCollectionCounts(const NoteCollectionCounts& other153) {
  notebookCounts = other153.notebookCounts;
  tagCounts = other153.tagCounts;
  trashCount = other153.trashCount;
  __isset = other153.__isset;
}
NoteCollectionCounts& NoteCollectionCounts::operator=(const NoteCollectionCounts& other154) {
  notebookCounts = other154.notebookCounts;
  tagCounts = other154.tagCounts;
  trashCount = other154.trashCount;
  __isset = other154.__isset;
  return *this;
}
void NoteCollectionCounts::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoteCollectionCounts(";
  out << "notebookCounts="; (__isset.notebookCounts ? (out << to_string(notebookCounts)) : (out << "<null>"));
  out << ", " << "tagCounts="; (__isset.tagCounts ? (out << to_string(tagCounts)) : (out << "<null>"));
  out << ", " << "trashCount="; (__isset.trashCount ? (out << to_string(trashCount)) : (out << "<null>"));
  out << ")";
}


NoteResultSpec::~NoteResultSpec() throw() {
}


void NoteResultSpec::__set_includeContent(const bool val) {
  this->includeContent = val;
__isset.includeContent = true;
}

void NoteResultSpec::__set_includeResourcesData(const bool val) {
  this->includeResourcesData = val;
__isset.includeResourcesData = true;
}

void NoteResultSpec::__set_includeResourcesRecognition(const bool val) {
  this->includeResourcesRecognition = val;
__isset.includeResourcesRecognition = true;
}

void NoteResultSpec::__set_includeResourcesAlternateData(const bool val) {
  this->includeResourcesAlternateData = val;
__isset.includeResourcesAlternateData = true;
}

void NoteResultSpec::__set_includeSharedNotes(const bool val) {
  this->includeSharedNotes = val;
__isset.includeSharedNotes = true;
}

void NoteResultSpec::__set_includeNoteAppDataValues(const bool val) {
  this->includeNoteAppDataValues = val;
__isset.includeNoteAppDataValues = true;
}

void NoteResultSpec::__set_includeResourceAppDataValues(const bool val) {
  this->includeResourceAppDataValues = val;
__isset.includeResourceAppDataValues = true;
}

void NoteResultSpec::__set_includeAccountLimits(const bool val) {
  this->includeAccountLimits = val;
__isset.includeAccountLimits = true;
}

uint32_t NoteResultSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeContent);
          this->__isset.includeContent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeResourcesData);
          this->__isset.includeResourcesData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeResourcesRecognition);
          this->__isset.includeResourcesRecognition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeResourcesAlternateData);
          this->__isset.includeResourcesAlternateData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeSharedNotes);
          this->__isset.includeSharedNotes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeNoteAppDataValues);
          this->__isset.includeNoteAppDataValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeResourceAppDataValues);
          this->__isset.includeResourceAppDataValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeAccountLimits);
          this->__isset.includeAccountLimits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteResultSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteResultSpec");

  if (this->__isset.includeContent) {
    xfer += oprot->writeFieldBegin("includeContent", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->includeContent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeResourcesData) {
    xfer += oprot->writeFieldBegin("includeResourcesData", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->includeResourcesData);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeResourcesRecognition) {
    xfer += oprot->writeFieldBegin("includeResourcesRecognition", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->includeResourcesRecognition);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeResourcesAlternateData) {
    xfer += oprot->writeFieldBegin("includeResourcesAlternateData", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->includeResourcesAlternateData);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeSharedNotes) {
    xfer += oprot->writeFieldBegin("includeSharedNotes", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->includeSharedNotes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeNoteAppDataValues) {
    xfer += oprot->writeFieldBegin("includeNoteAppDataValues", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->includeNoteAppDataValues);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeResourceAppDataValues) {
    xfer += oprot->writeFieldBegin("includeResourceAppDataValues", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->includeResourceAppDataValues);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeAccountLimits) {
    xfer += oprot->writeFieldBegin("includeAccountLimits", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->includeAccountLimits);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoteResultSpec &a, NoteResultSpec &b) {
  using ::std::swap;
  swap(a.includeContent, b.includeContent);
  swap(a.includeResourcesData, b.includeResourcesData);
  swap(a.includeResourcesRecognition, b.includeResourcesRecognition);
  swap(a.includeResourcesAlternateData, b.includeResourcesAlternateData);
  swap(a.includeSharedNotes, b.includeSharedNotes);
  swap(a.includeNoteAppDataValues, b.includeNoteAppDataValues);
  swap(a.includeResourceAppDataValues, b.includeResourceAppDataValues);
  swap(a.includeAccountLimits, b.includeAccountLimits);
  swap(a.__isset, b.__isset);
}

NoteResultSpec::NoteResultSpec(const NoteResultSpec& other155) {
  includeContent = other155.includeContent;
  includeResourcesData = other155.includeResourcesData;
  includeResourcesRecognition = other155.includeResourcesRecognition;
  includeResourcesAlternateData = other155.includeResourcesAlternateData;
  includeSharedNotes = other155.includeSharedNotes;
  includeNoteAppDataValues = other155.includeNoteAppDataValues;
  includeResourceAppDataValues = other155.includeResourceAppDataValues;
  includeAccountLimits = other155.includeAccountLimits;
  __isset = other155.__isset;
}
NoteResultSpec& NoteResultSpec::operator=(const NoteResultSpec& other156) {
  includeContent = other156.includeContent;
  includeResourcesData = other156.includeResourcesData;
  includeResourcesRecognition = other156.includeResourcesRecognition;
  includeResourcesAlternateData = other156.includeResourcesAlternateData;
  includeSharedNotes = other156.includeSharedNotes;
  includeNoteAppDataValues = other156.includeNoteAppDataValues;
  includeResourceAppDataValues = other156.includeResourceAppDataValues;
  includeAccountLimits = other156.includeAccountLimits;
  __isset = other156.__isset;
  return *this;
}
void NoteResultSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoteResultSpec(";
  out << "includeContent="; (__isset.includeContent ? (out << to_string(includeContent)) : (out << "<null>"));
  out << ", " << "includeResourcesData="; (__isset.includeResourcesData ? (out << to_string(includeResourcesData)) : (out << "<null>"));
  out << ", " << "includeResourcesRecognition="; (__isset.includeResourcesRecognition ? (out << to_string(includeResourcesRecognition)) : (out << "<null>"));
  out << ", " << "includeResourcesAlternateData="; (__isset.includeResourcesAlternateData ? (out << to_string(includeResourcesAlternateData)) : (out << "<null>"));
  out << ", " << "includeSharedNotes="; (__isset.includeSharedNotes ? (out << to_string(includeSharedNotes)) : (out << "<null>"));
  out << ", " << "includeNoteAppDataValues="; (__isset.includeNoteAppDataValues ? (out << to_string(includeNoteAppDataValues)) : (out << "<null>"));
  out << ", " << "includeResourceAppDataValues="; (__isset.includeResourceAppDataValues ? (out << to_string(includeResourceAppDataValues)) : (out << "<null>"));
  out << ", " << "includeAccountLimits="; (__isset.includeAccountLimits ? (out << to_string(includeAccountLimits)) : (out << "<null>"));
  out << ")";
}


NoteEmailParameters::~NoteEmailParameters() throw() {
}


void NoteEmailParameters::__set_guid(const std::string& val) {
  this->guid = val;
__isset.guid = true;
}

void NoteEmailParameters::__set_note(const  ::evernote::edam::Note& val) {
  this->note = val;
__isset.note = true;
}

void NoteEmailParameters::__set_toAddresses(const std::vector<std::string> & val) {
  this->toAddresses = val;
__isset.toAddresses = true;
}

void NoteEmailParameters::__set_ccAddresses(const std::vector<std::string> & val) {
  this->ccAddresses = val;
__isset.ccAddresses = true;
}

void NoteEmailParameters::__set_subject(const std::string& val) {
  this->subject = val;
__isset.subject = true;
}

void NoteEmailParameters::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}

uint32_t NoteEmailParameters::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->note.read(iprot);
          this->__isset.note = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->toAddresses.clear();
            uint32_t _size157;
            ::apache::thrift::protocol::TType _etype160;
            xfer += iprot->readListBegin(_etype160, _size157);
            this->toAddresses.resize(_size157);
            uint32_t _i161;
            for (_i161 = 0; _i161 < _size157; ++_i161)
            {
              xfer += iprot->readString(this->toAddresses[_i161]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.toAddresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ccAddresses.clear();
            uint32_t _size162;
            ::apache::thrift::protocol::TType _etype165;
            xfer += iprot->readListBegin(_etype165, _size162);
            this->ccAddresses.resize(_size162);
            uint32_t _i166;
            for (_i166 = 0; _i166 < _size162; ++_i166)
            {
              xfer += iprot->readString(this->ccAddresses[_i166]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ccAddresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subject);
          this->__isset.subject = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteEmailParameters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteEmailParameters");

  if (this->__isset.guid) {
    xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->guid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.note) {
    xfer += oprot->writeFieldBegin("note", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->note.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.toAddresses) {
    xfer += oprot->writeFieldBegin("toAddresses", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->toAddresses.size()));
      std::vector<std::string> ::const_iterator _iter167;
      for (_iter167 = this->toAddresses.begin(); _iter167 != this->toAddresses.end(); ++_iter167)
      {
        xfer += oprot->writeString((*_iter167));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ccAddresses) {
    xfer += oprot->writeFieldBegin("ccAddresses", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ccAddresses.size()));
      std::vector<std::string> ::const_iterator _iter168;
      for (_iter168 = this->ccAddresses.begin(); _iter168 != this->ccAddresses.end(); ++_iter168)
      {
        xfer += oprot->writeString((*_iter168));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subject) {
    xfer += oprot->writeFieldBegin("subject", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->subject);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoteEmailParameters &a, NoteEmailParameters &b) {
  using ::std::swap;
  swap(a.guid, b.guid);
  swap(a.note, b.note);
  swap(a.toAddresses, b.toAddresses);
  swap(a.ccAddresses, b.ccAddresses);
  swap(a.subject, b.subject);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoteEmailParameters::NoteEmailParameters(const NoteEmailParameters& other169) {
  guid = other169.guid;
  note = other169.note;
  toAddresses = other169.toAddresses;
  ccAddresses = other169.ccAddresses;
  subject = other169.subject;
  message = other169.message;
  __isset = other169.__isset;
}
NoteEmailParameters& NoteEmailParameters::operator=(const NoteEmailParameters& other170) {
  guid = other170.guid;
  note = other170.note;
  toAddresses = other170.toAddresses;
  ccAddresses = other170.ccAddresses;
  subject = other170.subject;
  message = other170.message;
  __isset = other170.__isset;
  return *this;
}
void NoteEmailParameters::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoteEmailParameters(";
  out << "guid="; (__isset.guid ? (out << to_string(guid)) : (out << "<null>"));
  out << ", " << "note="; (__isset.note ? (out << to_string(note)) : (out << "<null>"));
  out << ", " << "toAddresses="; (__isset.toAddresses ? (out << to_string(toAddresses)) : (out << "<null>"));
  out << ", " << "ccAddresses="; (__isset.ccAddresses ? (out << to_string(ccAddresses)) : (out << "<null>"));
  out << ", " << "subject="; (__isset.subject ? (out << to_string(subject)) : (out << "<null>"));
  out << ", " << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ")";
}


NoteVersionId::~NoteVersionId() throw() {
}


void NoteVersionId::__set_updateSequenceNum(const int32_t val) {
  this->updateSequenceNum = val;
}

void NoteVersionId::__set_updated(const  ::evernote::edam::Timestamp val) {
  this->updated = val;
}

void NoteVersionId::__set_saved(const  ::evernote::edam::Timestamp val) {
  this->saved = val;
}

void NoteVersionId::__set_title(const std::string& val) {
  this->title = val;
}

void NoteVersionId::__set_lastEditorId(const  ::evernote::edam::UserID val) {
  this->lastEditorId = val;
__isset.lastEditorId = true;
}

uint32_t NoteVersionId::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_updateSequenceNum = false;
  bool isset_updated = false;
  bool isset_saved = false;
  bool isset_title = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->updateSequenceNum);
          isset_updateSequenceNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updated);
          isset_updated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->saved);
          isset_saved = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          isset_title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastEditorId);
          this->__isset.lastEditorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_updateSequenceNum)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_updated)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_saved)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_title)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NoteVersionId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteVersionId");

  xfer += oprot->writeFieldBegin("updateSequenceNum", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->updateSequenceNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updated", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->updated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("saved", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->saved);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.lastEditorId) {
    xfer += oprot->writeFieldBegin("lastEditorId", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->lastEditorId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoteVersionId &a, NoteVersionId &b) {
  using ::std::swap;
  swap(a.updateSequenceNum, b.updateSequenceNum);
  swap(a.updated, b.updated);
  swap(a.saved, b.saved);
  swap(a.title, b.title);
  swap(a.lastEditorId, b.lastEditorId);
  swap(a.__isset, b.__isset);
}

NoteVersionId::NoteVersionId(const NoteVersionId& other171) {
  updateSequenceNum = other171.updateSequenceNum;
  updated = other171.updated;
  saved = other171.saved;
  title = other171.title;
  lastEditorId = other171.lastEditorId;
  __isset = other171.__isset;
}
NoteVersionId& NoteVersionId::operator=(const NoteVersionId& other172) {
  updateSequenceNum = other172.updateSequenceNum;
  updated = other172.updated;
  saved = other172.saved;
  title = other172.title;
  lastEditorId = other172.lastEditorId;
  __isset = other172.__isset;
  return *this;
}
void NoteVersionId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoteVersionId(";
  out << "updateSequenceNum=" << to_string(updateSequenceNum);
  out << ", " << "updated=" << to_string(updated);
  out << ", " << "saved=" << to_string(saved);
  out << ", " << "title=" << to_string(title);
  out << ", " << "lastEditorId="; (__isset.lastEditorId ? (out << to_string(lastEditorId)) : (out << "<null>"));
  out << ")";
}


RelatedQuery::~RelatedQuery() throw() {
}


void RelatedQuery::__set_noteGuid(const std::string& val) {
  this->noteGuid = val;
__isset.noteGuid = true;
}

void RelatedQuery::__set_plainText(const std::string& val) {
  this->plainText = val;
__isset.plainText = true;
}

void RelatedQuery::__set_filter(const NoteFilter& val) {
  this->filter = val;
__isset.filter = true;
}

void RelatedQuery::__set_referenceUri(const std::string& val) {
  this->referenceUri = val;
__isset.referenceUri = true;
}

void RelatedQuery::__set_context(const std::string& val) {
  this->context = val;
__isset.context = true;
}

void RelatedQuery::__set_cacheKey(const std::string& val) {
  this->cacheKey = val;
__isset.cacheKey = true;
}

uint32_t RelatedQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->noteGuid);
          this->__isset.noteGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->plainText);
          this->__isset.plainText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->filter.read(iprot);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->referenceUri);
          this->__isset.referenceUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->context);
          this->__isset.context = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cacheKey);
          this->__isset.cacheKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RelatedQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RelatedQuery");

  if (this->__isset.noteGuid) {
    xfer += oprot->writeFieldBegin("noteGuid", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->noteGuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.plainText) {
    xfer += oprot->writeFieldBegin("plainText", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->plainText);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filter) {
    xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->filter.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.referenceUri) {
    xfer += oprot->writeFieldBegin("referenceUri", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->referenceUri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.context) {
    xfer += oprot->writeFieldBegin("context", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->context);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheKey) {
    xfer += oprot->writeFieldBegin("cacheKey", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->cacheKey);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RelatedQuery &a, RelatedQuery &b) {
  using ::std::swap;
  swap(a.noteGuid, b.noteGuid);
  swap(a.plainText, b.plainText);
  swap(a.filter, b.filter);
  swap(a.referenceUri, b.referenceUri);
  swap(a.context, b.context);
  swap(a.cacheKey, b.cacheKey);
  swap(a.__isset, b.__isset);
}

RelatedQuery::RelatedQuery(const RelatedQuery& other173) {
  noteGuid = other173.noteGuid;
  plainText = other173.plainText;
  filter = other173.filter;
  referenceUri = other173.referenceUri;
  context = other173.context;
  cacheKey = other173.cacheKey;
  __isset = other173.__isset;
}
RelatedQuery& RelatedQuery::operator=(const RelatedQuery& other174) {
  noteGuid = other174.noteGuid;
  plainText = other174.plainText;
  filter = other174.filter;
  referenceUri = other174.referenceUri;
  context = other174.context;
  cacheKey = other174.cacheKey;
  __isset = other174.__isset;
  return *this;
}
void RelatedQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RelatedQuery(";
  out << "noteGuid="; (__isset.noteGuid ? (out << to_string(noteGuid)) : (out << "<null>"));
  out << ", " << "plainText="; (__isset.plainText ? (out << to_string(plainText)) : (out << "<null>"));
  out << ", " << "filter="; (__isset.filter ? (out << to_string(filter)) : (out << "<null>"));
  out << ", " << "referenceUri="; (__isset.referenceUri ? (out << to_string(referenceUri)) : (out << "<null>"));
  out << ", " << "context="; (__isset.context ? (out << to_string(context)) : (out << "<null>"));
  out << ", " << "cacheKey="; (__isset.cacheKey ? (out << to_string(cacheKey)) : (out << "<null>"));
  out << ")";
}


RelatedResult::~RelatedResult() throw() {
}


void RelatedResult::__set_notes(const std::vector< ::evernote::edam::Note> & val) {
  this->notes = val;
__isset.notes = true;
}

void RelatedResult::__set_notebooks(const std::vector< ::evernote::edam::Notebook> & val) {
  this->notebooks = val;
__isset.notebooks = true;
}

void RelatedResult::__set_tags(const std::vector< ::evernote::edam::Tag> & val) {
  this->tags = val;
__isset.tags = true;
}

void RelatedResult::__set_containingNotebooks(const std::vector< ::evernote::edam::NotebookDescriptor> & val) {
  this->containingNotebooks = val;
__isset.containingNotebooks = true;
}

void RelatedResult::__set_experts(const std::vector< ::evernote::edam::UserProfile> & val) {
  this->experts = val;
__isset.experts = true;
}

void RelatedResult::__set_relatedContent(const std::vector< ::evernote::edam::RelatedContent> & val) {
  this->relatedContent = val;
__isset.relatedContent = true;
}

void RelatedResult::__set_cacheKey(const std::string& val) {
  this->cacheKey = val;
__isset.cacheKey = true;
}

void RelatedResult::__set_cacheExpires(const int32_t val) {
  this->cacheExpires = val;
__isset.cacheExpires = true;
}

uint32_t RelatedResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notes.clear();
            uint32_t _size175;
            ::apache::thrift::protocol::TType _etype178;
            xfer += iprot->readListBegin(_etype178, _size175);
            this->notes.resize(_size175);
            uint32_t _i179;
            for (_i179 = 0; _i179 < _size175; ++_i179)
            {
              xfer += this->notes[_i179].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.notes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notebooks.clear();
            uint32_t _size180;
            ::apache::thrift::protocol::TType _etype183;
            xfer += iprot->readListBegin(_etype183, _size180);
            this->notebooks.resize(_size180);
            uint32_t _i184;
            for (_i184 = 0; _i184 < _size180; ++_i184)
            {
              xfer += this->notebooks[_i184].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.notebooks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tags.clear();
            uint32_t _size185;
            ::apache::thrift::protocol::TType _etype188;
            xfer += iprot->readListBegin(_etype188, _size185);
            this->tags.resize(_size185);
            uint32_t _i189;
            for (_i189 = 0; _i189 < _size185; ++_i189)
            {
              xfer += this->tags[_i189].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->containingNotebooks.clear();
            uint32_t _size190;
            ::apache::thrift::protocol::TType _etype193;
            xfer += iprot->readListBegin(_etype193, _size190);
            this->containingNotebooks.resize(_size190);
            uint32_t _i194;
            for (_i194 = 0; _i194 < _size190; ++_i194)
            {
              xfer += this->containingNotebooks[_i194].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.containingNotebooks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->experts.clear();
            uint32_t _size195;
            ::apache::thrift::protocol::TType _etype198;
            xfer += iprot->readListBegin(_etype198, _size195);
            this->experts.resize(_size195);
            uint32_t _i199;
            for (_i199 = 0; _i199 < _size195; ++_i199)
            {
              xfer += this->experts[_i199].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.experts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->relatedContent.clear();
            uint32_t _size200;
            ::apache::thrift::protocol::TType _etype203;
            xfer += iprot->readListBegin(_etype203, _size200);
            this->relatedContent.resize(_size200);
            uint32_t _i204;
            for (_i204 = 0; _i204 < _size200; ++_i204)
            {
              xfer += this->relatedContent[_i204].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.relatedContent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cacheKey);
          this->__isset.cacheKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cacheExpires);
          this->__isset.cacheExpires = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RelatedResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RelatedResult");

  if (this->__isset.notes) {
    xfer += oprot->writeFieldBegin("notes", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notes.size()));
      std::vector< ::evernote::edam::Note> ::const_iterator _iter205;
      for (_iter205 = this->notes.begin(); _iter205 != this->notes.end(); ++_iter205)
      {
        xfer += (*_iter205).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.notebooks) {
    xfer += oprot->writeFieldBegin("notebooks", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notebooks.size()));
      std::vector< ::evernote::edam::Notebook> ::const_iterator _iter206;
      for (_iter206 = this->notebooks.begin(); _iter206 != this->notebooks.end(); ++_iter206)
      {
        xfer += (*_iter206).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tags) {
    xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tags.size()));
      std::vector< ::evernote::edam::Tag> ::const_iterator _iter207;
      for (_iter207 = this->tags.begin(); _iter207 != this->tags.end(); ++_iter207)
      {
        xfer += (*_iter207).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.containingNotebooks) {
    xfer += oprot->writeFieldBegin("containingNotebooks", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->containingNotebooks.size()));
      std::vector< ::evernote::edam::NotebookDescriptor> ::const_iterator _iter208;
      for (_iter208 = this->containingNotebooks.begin(); _iter208 != this->containingNotebooks.end(); ++_iter208)
      {
        xfer += (*_iter208).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.experts) {
    xfer += oprot->writeFieldBegin("experts", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->experts.size()));
      std::vector< ::evernote::edam::UserProfile> ::const_iterator _iter209;
      for (_iter209 = this->experts.begin(); _iter209 != this->experts.end(); ++_iter209)
      {
        xfer += (*_iter209).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relatedContent) {
    xfer += oprot->writeFieldBegin("relatedContent", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->relatedContent.size()));
      std::vector< ::evernote::edam::RelatedContent> ::const_iterator _iter210;
      for (_iter210 = this->relatedContent.begin(); _iter210 != this->relatedContent.end(); ++_iter210)
      {
        xfer += (*_iter210).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheKey) {
    xfer += oprot->writeFieldBegin("cacheKey", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->cacheKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheExpires) {
    xfer += oprot->writeFieldBegin("cacheExpires", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->cacheExpires);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RelatedResult &a, RelatedResult &b) {
  using ::std::swap;
  swap(a.notes, b.notes);
  swap(a.notebooks, b.notebooks);
  swap(a.tags, b.tags);
  swap(a.containingNotebooks, b.containingNotebooks);
  swap(a.experts, b.experts);
  swap(a.relatedContent, b.relatedContent);
  swap(a.cacheKey, b.cacheKey);
  swap(a.cacheExpires, b.cacheExpires);
  swap(a.__isset, b.__isset);
}

RelatedResult::RelatedResult(const RelatedResult& other211) {
  notes = other211.notes;
  notebooks = other211.notebooks;
  tags = other211.tags;
  containingNotebooks = other211.containingNotebooks;
  experts = other211.experts;
  relatedContent = other211.relatedContent;
  cacheKey = other211.cacheKey;
  cacheExpires = other211.cacheExpires;
  __isset = other211.__isset;
}
RelatedResult& RelatedResult::operator=(const RelatedResult& other212) {
  notes = other212.notes;
  notebooks = other212.notebooks;
  tags = other212.tags;
  containingNotebooks = other212.containingNotebooks;
  experts = other212.experts;
  relatedContent = other212.relatedContent;
  cacheKey = other212.cacheKey;
  cacheExpires = other212.cacheExpires;
  __isset = other212.__isset;
  return *this;
}
void RelatedResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RelatedResult(";
  out << "notes="; (__isset.notes ? (out << to_string(notes)) : (out << "<null>"));
  out << ", " << "notebooks="; (__isset.notebooks ? (out << to_string(notebooks)) : (out << "<null>"));
  out << ", " << "tags="; (__isset.tags ? (out << to_string(tags)) : (out << "<null>"));
  out << ", " << "containingNotebooks="; (__isset.containingNotebooks ? (out << to_string(containingNotebooks)) : (out << "<null>"));
  out << ", " << "experts="; (__isset.experts ? (out << to_string(experts)) : (out << "<null>"));
  out << ", " << "relatedContent="; (__isset.relatedContent ? (out << to_string(relatedContent)) : (out << "<null>"));
  out << ", " << "cacheKey="; (__isset.cacheKey ? (out << to_string(cacheKey)) : (out << "<null>"));
  out << ", " << "cacheExpires="; (__isset.cacheExpires ? (out << to_string(cacheExpires)) : (out << "<null>"));
  out << ")";
}


RelatedResultSpec::~RelatedResultSpec() throw() {
}


void RelatedResultSpec::__set_maxNotes(const int32_t val) {
  this->maxNotes = val;
__isset.maxNotes = true;
}

void RelatedResultSpec::__set_maxNotebooks(const int32_t val) {
  this->maxNotebooks = val;
__isset.maxNotebooks = true;
}

void RelatedResultSpec::__set_maxTags(const int32_t val) {
  this->maxTags = val;
__isset.maxTags = true;
}

void RelatedResultSpec::__set_writableNotebooksOnly(const bool val) {
  this->writableNotebooksOnly = val;
__isset.writableNotebooksOnly = true;
}

void RelatedResultSpec::__set_includeContainingNotebooks(const bool val) {
  this->includeContainingNotebooks = val;
__isset.includeContainingNotebooks = true;
}

void RelatedResultSpec::__set_maxExperts(const int32_t val) {
  this->maxExperts = val;
__isset.maxExperts = true;
}

void RelatedResultSpec::__set_maxRelatedContent(const int32_t val) {
  this->maxRelatedContent = val;
__isset.maxRelatedContent = true;
}

void RelatedResultSpec::__set_relatedContentTypes(const std::set< ::evernote::edam::RelatedContentType::type> & val) {
  this->relatedContentTypes = val;
__isset.relatedContentTypes = true;
}

uint32_t RelatedResultSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxNotes);
          this->__isset.maxNotes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxNotebooks);
          this->__isset.maxNotebooks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxTags);
          this->__isset.maxTags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->writableNotebooksOnly);
          this->__isset.writableNotebooksOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeContainingNotebooks);
          this->__isset.includeContainingNotebooks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxExperts);
          this->__isset.maxExperts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxRelatedContent);
          this->__isset.maxRelatedContent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->relatedContentTypes.clear();
            uint32_t _size213;
            ::apache::thrift::protocol::TType _etype216;
            xfer += iprot->readSetBegin(_etype216, _size213);
            uint32_t _i217;
            for (_i217 = 0; _i217 < _size213; ++_i217)
            {
               ::evernote::edam::RelatedContentType::type _elem218;
              int32_t ecast219;
              xfer += iprot->readI32(ecast219);
              _elem218 = ( ::evernote::edam::RelatedContentType::type)ecast219;
              this->relatedContentTypes.insert(_elem218);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.relatedContentTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RelatedResultSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RelatedResultSpec");

  if (this->__isset.maxNotes) {
    xfer += oprot->writeFieldBegin("maxNotes", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->maxNotes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxNotebooks) {
    xfer += oprot->writeFieldBegin("maxNotebooks", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->maxNotebooks);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxTags) {
    xfer += oprot->writeFieldBegin("maxTags", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->maxTags);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writableNotebooksOnly) {
    xfer += oprot->writeFieldBegin("writableNotebooksOnly", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->writableNotebooksOnly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeContainingNotebooks) {
    xfer += oprot->writeFieldBegin("includeContainingNotebooks", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->includeContainingNotebooks);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxExperts) {
    xfer += oprot->writeFieldBegin("maxExperts", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->maxExperts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxRelatedContent) {
    xfer += oprot->writeFieldBegin("maxRelatedContent", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->maxRelatedContent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relatedContentTypes) {
    xfer += oprot->writeFieldBegin("relatedContentTypes", ::apache::thrift::protocol::T_SET, 9);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->relatedContentTypes.size()));
      std::set< ::evernote::edam::RelatedContentType::type> ::const_iterator _iter220;
      for (_iter220 = this->relatedContentTypes.begin(); _iter220 != this->relatedContentTypes.end(); ++_iter220)
      {
        xfer += oprot->writeI32((int32_t)(*_iter220));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RelatedResultSpec &a, RelatedResultSpec &b) {
  using ::std::swap;
  swap(a.maxNotes, b.maxNotes);
  swap(a.maxNotebooks, b.maxNotebooks);
  swap(a.maxTags, b.maxTags);
  swap(a.writableNotebooksOnly, b.writableNotebooksOnly);
  swap(a.includeContainingNotebooks, b.includeContainingNotebooks);
  swap(a.maxExperts, b.maxExperts);
  swap(a.maxRelatedContent, b.maxRelatedContent);
  swap(a.relatedContentTypes, b.relatedContentTypes);
  swap(a.__isset, b.__isset);
}

RelatedResultSpec::RelatedResultSpec(const RelatedResultSpec& other221) {
  maxNotes = other221.maxNotes;
  maxNotebooks = other221.maxNotebooks;
  maxTags = other221.maxTags;
  writableNotebooksOnly = other221.writableNotebooksOnly;
  includeContainingNotebooks = other221.includeContainingNotebooks;
  maxExperts = other221.maxExperts;
  maxRelatedContent = other221.maxRelatedContent;
  relatedContentTypes = other221.relatedContentTypes;
  __isset = other221.__isset;
}
RelatedResultSpec& RelatedResultSpec::operator=(const RelatedResultSpec& other222) {
  maxNotes = other222.maxNotes;
  maxNotebooks = other222.maxNotebooks;
  maxTags = other222.maxTags;
  writableNotebooksOnly = other222.writableNotebooksOnly;
  includeContainingNotebooks = other222.includeContainingNotebooks;
  maxExperts = other222.maxExperts;
  maxRelatedContent = other222.maxRelatedContent;
  relatedContentTypes = other222.relatedContentTypes;
  __isset = other222.__isset;
  return *this;
}
void RelatedResultSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RelatedResultSpec(";
  out << "maxNotes="; (__isset.maxNotes ? (out << to_string(maxNotes)) : (out << "<null>"));
  out << ", " << "maxNotebooks="; (__isset.maxNotebooks ? (out << to_string(maxNotebooks)) : (out << "<null>"));
  out << ", " << "maxTags="; (__isset.maxTags ? (out << to_string(maxTags)) : (out << "<null>"));
  out << ", " << "writableNotebooksOnly="; (__isset.writableNotebooksOnly ? (out << to_string(writableNotebooksOnly)) : (out << "<null>"));
  out << ", " << "includeContainingNotebooks="; (__isset.includeContainingNotebooks ? (out << to_string(includeContainingNotebooks)) : (out << "<null>"));
  out << ", " << "maxExperts="; (__isset.maxExperts ? (out << to_string(maxExperts)) : (out << "<null>"));
  out << ", " << "maxRelatedContent="; (__isset.maxRelatedContent ? (out << to_string(maxRelatedContent)) : (out << "<null>"));
  out << ", " << "relatedContentTypes="; (__isset.relatedContentTypes ? (out << to_string(relatedContentTypes)) : (out << "<null>"));
  out << ")";
}


UpdateNoteIfUsnMatchesResult::~UpdateNoteIfUsnMatchesResult() throw() {
}


void UpdateNoteIfUsnMatchesResult::__set_note(const  ::evernote::edam::Note& val) {
  this->note = val;
__isset.note = true;
}

void UpdateNoteIfUsnMatchesResult::__set_updated(const bool val) {
  this->updated = val;
__isset.updated = true;
}

uint32_t UpdateNoteIfUsnMatchesResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->note.read(iprot);
          this->__isset.note = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->updated);
          this->__isset.updated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateNoteIfUsnMatchesResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UpdateNoteIfUsnMatchesResult");

  if (this->__isset.note) {
    xfer += oprot->writeFieldBegin("note", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->note.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated) {
    xfer += oprot->writeFieldBegin("updated", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->updated);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateNoteIfUsnMatchesResult &a, UpdateNoteIfUsnMatchesResult &b) {
  using ::std::swap;
  swap(a.note, b.note);
  swap(a.updated, b.updated);
  swap(a.__isset, b.__isset);
}

UpdateNoteIfUsnMatchesResult::UpdateNoteIfUsnMatchesResult(const UpdateNoteIfUsnMatchesResult& other223) {
  note = other223.note;
  updated = other223.updated;
  __isset = other223.__isset;
}
UpdateNoteIfUsnMatchesResult& UpdateNoteIfUsnMatchesResult::operator=(const UpdateNoteIfUsnMatchesResult& other224) {
  note = other224.note;
  updated = other224.updated;
  __isset = other224.__isset;
  return *this;
}
void UpdateNoteIfUsnMatchesResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UpdateNoteIfUsnMatchesResult(";
  out << "note="; (__isset.note ? (out << to_string(note)) : (out << "<null>"));
  out << ", " << "updated="; (__isset.updated ? (out << to_string(updated)) : (out << "<null>"));
  out << ")";
}


ShareRelationshipRestrictions::~ShareRelationshipRestrictions() throw() {
}


void ShareRelationshipRestrictions::__set_noSetReadOnly(const bool val) {
  this->noSetReadOnly = val;
__isset.noSetReadOnly = true;
}

void ShareRelationshipRestrictions::__set_noSetReadPlusActivity(const bool val) {
  this->noSetReadPlusActivity = val;
__isset.noSetReadPlusActivity = true;
}

void ShareRelationshipRestrictions::__set_noSetModify(const bool val) {
  this->noSetModify = val;
__isset.noSetModify = true;
}

void ShareRelationshipRestrictions::__set_noSetFullAccess(const bool val) {
  this->noSetFullAccess = val;
__isset.noSetFullAccess = true;
}

uint32_t ShareRelationshipRestrictions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->noSetReadOnly);
          this->__isset.noSetReadOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->noSetReadPlusActivity);
          this->__isset.noSetReadPlusActivity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->noSetModify);
          this->__isset.noSetModify = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->noSetFullAccess);
          this->__isset.noSetFullAccess = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShareRelationshipRestrictions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShareRelationshipRestrictions");

  if (this->__isset.noSetReadOnly) {
    xfer += oprot->writeFieldBegin("noSetReadOnly", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->noSetReadOnly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.noSetReadPlusActivity) {
    xfer += oprot->writeFieldBegin("noSetReadPlusActivity", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->noSetReadPlusActivity);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.noSetModify) {
    xfer += oprot->writeFieldBegin("noSetModify", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->noSetModify);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.noSetFullAccess) {
    xfer += oprot->writeFieldBegin("noSetFullAccess", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->noSetFullAccess);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShareRelationshipRestrictions &a, ShareRelationshipRestrictions &b) {
  using ::std::swap;
  swap(a.noSetReadOnly, b.noSetReadOnly);
  swap(a.noSetReadPlusActivity, b.noSetReadPlusActivity);
  swap(a.noSetModify, b.noSetModify);
  swap(a.noSetFullAccess, b.noSetFullAccess);
  swap(a.__isset, b.__isset);
}

ShareRelationshipRestrictions::ShareRelationshipRestrictions(const ShareRelationshipRestrictions& other225) {
  noSetReadOnly = other225.noSetReadOnly;
  noSetReadPlusActivity = other225.noSetReadPlusActivity;
  noSetModify = other225.noSetModify;
  noSetFullAccess = other225.noSetFullAccess;
  __isset = other225.__isset;
}
ShareRelationshipRestrictions& ShareRelationshipRestrictions::operator=(const ShareRelationshipRestrictions& other226) {
  noSetReadOnly = other226.noSetReadOnly;
  noSetReadPlusActivity = other226.noSetReadPlusActivity;
  noSetModify = other226.noSetModify;
  noSetFullAccess = other226.noSetFullAccess;
  __isset = other226.__isset;
  return *this;
}
void ShareRelationshipRestrictions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShareRelationshipRestrictions(";
  out << "noSetReadOnly="; (__isset.noSetReadOnly ? (out << to_string(noSetReadOnly)) : (out << "<null>"));
  out << ", " << "noSetReadPlusActivity="; (__isset.noSetReadPlusActivity ? (out << to_string(noSetReadPlusActivity)) : (out << "<null>"));
  out << ", " << "noSetModify="; (__isset.noSetModify ? (out << to_string(noSetModify)) : (out << "<null>"));
  out << ", " << "noSetFullAccess="; (__isset.noSetFullAccess ? (out << to_string(noSetFullAccess)) : (out << "<null>"));
  out << ")";
}


InvitationShareRelationship::~InvitationShareRelationship() throw() {
}


void InvitationShareRelationship::__set_displayName(const std::string& val) {
  this->displayName = val;
__isset.displayName = true;
}

void InvitationShareRelationship::__set_recipientUserIdentity(const  ::evernote::edam::UserIdentity& val) {
  this->recipientUserIdentity = val;
__isset.recipientUserIdentity = true;
}

void InvitationShareRelationship::__set_privilege(const ShareRelationshipPrivilegeLevel::type val) {
  this->privilege = val;
__isset.privilege = true;
}

void InvitationShareRelationship::__set_sharerUserId(const  ::evernote::edam::UserID val) {
  this->sharerUserId = val;
__isset.sharerUserId = true;
}

uint32_t InvitationShareRelationship::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayName);
          this->__isset.displayName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->recipientUserIdentity.read(iprot);
          this->__isset.recipientUserIdentity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast227;
          xfer += iprot->readI32(ecast227);
          this->privilege = (ShareRelationshipPrivilegeLevel::type)ecast227;
          this->__isset.privilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sharerUserId);
          this->__isset.sharerUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvitationShareRelationship::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvitationShareRelationship");

  if (this->__isset.displayName) {
    xfer += oprot->writeFieldBegin("displayName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->displayName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.recipientUserIdentity) {
    xfer += oprot->writeFieldBegin("recipientUserIdentity", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->recipientUserIdentity.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.privilege) {
    xfer += oprot->writeFieldBegin("privilege", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->privilege);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sharerUserId) {
    xfer += oprot->writeFieldBegin("sharerUserId", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->sharerUserId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvitationShareRelationship &a, InvitationShareRelationship &b) {
  using ::std::swap;
  swap(a.displayName, b.displayName);
  swap(a.recipientUserIdentity, b.recipientUserIdentity);
  swap(a.privilege, b.privilege);
  swap(a.sharerUserId, b.sharerUserId);
  swap(a.__isset, b.__isset);
}

InvitationShareRelationship::InvitationShareRelationship(const InvitationShareRelationship& other228) {
  displayName = other228.displayName;
  recipientUserIdentity = other228.recipientUserIdentity;
  privilege = other228.privilege;
  sharerUserId = other228.sharerUserId;
  __isset = other228.__isset;
}
InvitationShareRelationship& InvitationShareRelationship::operator=(const InvitationShareRelationship& other229) {
  displayName = other229.displayName;
  recipientUserIdentity = other229.recipientUserIdentity;
  privilege = other229.privilege;
  sharerUserId = other229.sharerUserId;
  __isset = other229.__isset;
  return *this;
}
void InvitationShareRelationship::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvitationShareRelationship(";
  out << "displayName="; (__isset.displayName ? (out << to_string(displayName)) : (out << "<null>"));
  out << ", " << "recipientUserIdentity="; (__isset.recipientUserIdentity ? (out << to_string(recipientUserIdentity)) : (out << "<null>"));
  out << ", " << "privilege="; (__isset.privilege ? (out << to_string(privilege)) : (out << "<null>"));
  out << ", " << "sharerUserId="; (__isset.sharerUserId ? (out << to_string(sharerUserId)) : (out << "<null>"));
  out << ")";
}


MemberShareRelationship::~MemberShareRelationship() throw() {
}


void MemberShareRelationship::__set_displayName(const std::string& val) {
  this->displayName = val;
__isset.displayName = true;
}

void MemberShareRelationship::__set_recipientUserId(const  ::evernote::edam::UserID val) {
  this->recipientUserId = val;
__isset.recipientUserId = true;
}

void MemberShareRelationship::__set_bestPrivilege(const ShareRelationshipPrivilegeLevel::type val) {
  this->bestPrivilege = val;
__isset.bestPrivilege = true;
}

void MemberShareRelationship::__set_individualPrivilege(const ShareRelationshipPrivilegeLevel::type val) {
  this->individualPrivilege = val;
__isset.individualPrivilege = true;
}

void MemberShareRelationship::__set_restrictions(const ShareRelationshipRestrictions& val) {
  this->restrictions = val;
__isset.restrictions = true;
}

void MemberShareRelationship::__set_sharerUserId(const  ::evernote::edam::UserID val) {
  this->sharerUserId = val;
__isset.sharerUserId = true;
}

uint32_t MemberShareRelationship::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayName);
          this->__isset.displayName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->recipientUserId);
          this->__isset.recipientUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast230;
          xfer += iprot->readI32(ecast230);
          this->bestPrivilege = (ShareRelationshipPrivilegeLevel::type)ecast230;
          this->__isset.bestPrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast231;
          xfer += iprot->readI32(ecast231);
          this->individualPrivilege = (ShareRelationshipPrivilegeLevel::type)ecast231;
          this->__isset.individualPrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->restrictions.read(iprot);
          this->__isset.restrictions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sharerUserId);
          this->__isset.sharerUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MemberShareRelationship::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MemberShareRelationship");

  if (this->__isset.displayName) {
    xfer += oprot->writeFieldBegin("displayName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->displayName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.recipientUserId) {
    xfer += oprot->writeFieldBegin("recipientUserId", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->recipientUserId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bestPrivilege) {
    xfer += oprot->writeFieldBegin("bestPrivilege", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->bestPrivilege);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.individualPrivilege) {
    xfer += oprot->writeFieldBegin("individualPrivilege", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->individualPrivilege);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.restrictions) {
    xfer += oprot->writeFieldBegin("restrictions", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->restrictions.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sharerUserId) {
    xfer += oprot->writeFieldBegin("sharerUserId", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->sharerUserId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MemberShareRelationship &a, MemberShareRelationship &b) {
  using ::std::swap;
  swap(a.displayName, b.displayName);
  swap(a.recipientUserId, b.recipientUserId);
  swap(a.bestPrivilege, b.bestPrivilege);
  swap(a.individualPrivilege, b.individualPrivilege);
  swap(a.restrictions, b.restrictions);
  swap(a.sharerUserId, b.sharerUserId);
  swap(a.__isset, b.__isset);
}

MemberShareRelationship::MemberShareRelationship(const MemberShareRelationship& other232) {
  displayName = other232.displayName;
  recipientUserId = other232.recipientUserId;
  bestPrivilege = other232.bestPrivilege;
  individualPrivilege = other232.individualPrivilege;
  restrictions = other232.restrictions;
  sharerUserId = other232.sharerUserId;
  __isset = other232.__isset;
}
MemberShareRelationship& MemberShareRelationship::operator=(const MemberShareRelationship& other233) {
  displayName = other233.displayName;
  recipientUserId = other233.recipientUserId;
  bestPrivilege = other233.bestPrivilege;
  individualPrivilege = other233.individualPrivilege;
  restrictions = other233.restrictions;
  sharerUserId = other233.sharerUserId;
  __isset = other233.__isset;
  return *this;
}
void MemberShareRelationship::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MemberShareRelationship(";
  out << "displayName="; (__isset.displayName ? (out << to_string(displayName)) : (out << "<null>"));
  out << ", " << "recipientUserId="; (__isset.recipientUserId ? (out << to_string(recipientUserId)) : (out << "<null>"));
  out << ", " << "bestPrivilege="; (__isset.bestPrivilege ? (out << to_string(bestPrivilege)) : (out << "<null>"));
  out << ", " << "individualPrivilege="; (__isset.individualPrivilege ? (out << to_string(individualPrivilege)) : (out << "<null>"));
  out << ", " << "restrictions="; (__isset.restrictions ? (out << to_string(restrictions)) : (out << "<null>"));
  out << ", " << "sharerUserId="; (__isset.sharerUserId ? (out << to_string(sharerUserId)) : (out << "<null>"));
  out << ")";
}


ShareRelationships::~ShareRelationships() throw() {
}


void ShareRelationships::__set_invitations(const std::vector<InvitationShareRelationship> & val) {
  this->invitations = val;
__isset.invitations = true;
}

void ShareRelationships::__set_memberships(const std::vector<MemberShareRelationship> & val) {
  this->memberships = val;
__isset.memberships = true;
}

void ShareRelationships::__set_invitationRestrictions(const ShareRelationshipRestrictions& val) {
  this->invitationRestrictions = val;
__isset.invitationRestrictions = true;
}

uint32_t ShareRelationships::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->invitations.clear();
            uint32_t _size234;
            ::apache::thrift::protocol::TType _etype237;
            xfer += iprot->readListBegin(_etype237, _size234);
            this->invitations.resize(_size234);
            uint32_t _i238;
            for (_i238 = 0; _i238 < _size234; ++_i238)
            {
              xfer += this->invitations[_i238].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.invitations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->memberships.clear();
            uint32_t _size239;
            ::apache::thrift::protocol::TType _etype242;
            xfer += iprot->readListBegin(_etype242, _size239);
            this->memberships.resize(_size239);
            uint32_t _i243;
            for (_i243 = 0; _i243 < _size239; ++_i243)
            {
              xfer += this->memberships[_i243].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.memberships = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->invitationRestrictions.read(iprot);
          this->__isset.invitationRestrictions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShareRelationships::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShareRelationships");

  if (this->__isset.invitations) {
    xfer += oprot->writeFieldBegin("invitations", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->invitations.size()));
      std::vector<InvitationShareRelationship> ::const_iterator _iter244;
      for (_iter244 = this->invitations.begin(); _iter244 != this->invitations.end(); ++_iter244)
      {
        xfer += (*_iter244).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memberships) {
    xfer += oprot->writeFieldBegin("memberships", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->memberships.size()));
      std::vector<MemberShareRelationship> ::const_iterator _iter245;
      for (_iter245 = this->memberships.begin(); _iter245 != this->memberships.end(); ++_iter245)
      {
        xfer += (*_iter245).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.invitationRestrictions) {
    xfer += oprot->writeFieldBegin("invitationRestrictions", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->invitationRestrictions.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShareRelationships &a, ShareRelationships &b) {
  using ::std::swap;
  swap(a.invitations, b.invitations);
  swap(a.memberships, b.memberships);
  swap(a.invitationRestrictions, b.invitationRestrictions);
  swap(a.__isset, b.__isset);
}

ShareRelationships::ShareRelationships(const ShareRelationships& other246) {
  invitations = other246.invitations;
  memberships = other246.memberships;
  invitationRestrictions = other246.invitationRestrictions;
  __isset = other246.__isset;
}
ShareRelationships& ShareRelationships::operator=(const ShareRelationships& other247) {
  invitations = other247.invitations;
  memberships = other247.memberships;
  invitationRestrictions = other247.invitationRestrictions;
  __isset = other247.__isset;
  return *this;
}
void ShareRelationships::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShareRelationships(";
  out << "invitations="; (__isset.invitations ? (out << to_string(invitations)) : (out << "<null>"));
  out << ", " << "memberships="; (__isset.memberships ? (out << to_string(memberships)) : (out << "<null>"));
  out << ", " << "invitationRestrictions="; (__isset.invitationRestrictions ? (out << to_string(invitationRestrictions)) : (out << "<null>"));
  out << ")";
}


ManageNotebookSharesParameters::~ManageNotebookSharesParameters() throw() {
}


void ManageNotebookSharesParameters::__set_notebookGuid(const std::string& val) {
  this->notebookGuid = val;
__isset.notebookGuid = true;
}

void ManageNotebookSharesParameters::__set_inviteMessage(const std::string& val) {
  this->inviteMessage = val;
__isset.inviteMessage = true;
}

void ManageNotebookSharesParameters::__set_membershipsToUpdate(const std::vector<MemberShareRelationship> & val) {
  this->membershipsToUpdate = val;
__isset.membershipsToUpdate = true;
}

void ManageNotebookSharesParameters::__set_invitationsToCreateOrUpdate(const std::vector<InvitationShareRelationship> & val) {
  this->invitationsToCreateOrUpdate = val;
__isset.invitationsToCreateOrUpdate = true;
}

void ManageNotebookSharesParameters::__set_unshares(const std::vector< ::evernote::edam::UserIdentity> & val) {
  this->unshares = val;
__isset.unshares = true;
}

uint32_t ManageNotebookSharesParameters::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->notebookGuid);
          this->__isset.notebookGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->inviteMessage);
          this->__isset.inviteMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->membershipsToUpdate.clear();
            uint32_t _size248;
            ::apache::thrift::protocol::TType _etype251;
            xfer += iprot->readListBegin(_etype251, _size248);
            this->membershipsToUpdate.resize(_size248);
            uint32_t _i252;
            for (_i252 = 0; _i252 < _size248; ++_i252)
            {
              xfer += this->membershipsToUpdate[_i252].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.membershipsToUpdate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->invitationsToCreateOrUpdate.clear();
            uint32_t _size253;
            ::apache::thrift::protocol::TType _etype256;
            xfer += iprot->readListBegin(_etype256, _size253);
            this->invitationsToCreateOrUpdate.resize(_size253);
            uint32_t _i257;
            for (_i257 = 0; _i257 < _size253; ++_i257)
            {
              xfer += this->invitationsToCreateOrUpdate[_i257].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.invitationsToCreateOrUpdate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->unshares.clear();
            uint32_t _size258;
            ::apache::thrift::protocol::TType _etype261;
            xfer += iprot->readListBegin(_etype261, _size258);
            this->unshares.resize(_size258);
            uint32_t _i262;
            for (_i262 = 0; _i262 < _size258; ++_i262)
            {
              xfer += this->unshares[_i262].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.unshares = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ManageNotebookSharesParameters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ManageNotebookSharesParameters");

  if (this->__isset.notebookGuid) {
    xfer += oprot->writeFieldBegin("notebookGuid", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->notebookGuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.inviteMessage) {
    xfer += oprot->writeFieldBegin("inviteMessage", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->inviteMessage);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.membershipsToUpdate) {
    xfer += oprot->writeFieldBegin("membershipsToUpdate", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->membershipsToUpdate.size()));
      std::vector<MemberShareRelationship> ::const_iterator _iter263;
      for (_iter263 = this->membershipsToUpdate.begin(); _iter263 != this->membershipsToUpdate.end(); ++_iter263)
      {
        xfer += (*_iter263).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.invitationsToCreateOrUpdate) {
    xfer += oprot->writeFieldBegin("invitationsToCreateOrUpdate", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->invitationsToCreateOrUpdate.size()));
      std::vector<InvitationShareRelationship> ::const_iterator _iter264;
      for (_iter264 = this->invitationsToCreateOrUpdate.begin(); _iter264 != this->invitationsToCreateOrUpdate.end(); ++_iter264)
      {
        xfer += (*_iter264).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unshares) {
    xfer += oprot->writeFieldBegin("unshares", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->unshares.size()));
      std::vector< ::evernote::edam::UserIdentity> ::const_iterator _iter265;
      for (_iter265 = this->unshares.begin(); _iter265 != this->unshares.end(); ++_iter265)
      {
        xfer += (*_iter265).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ManageNotebookSharesParameters &a, ManageNotebookSharesParameters &b) {
  using ::std::swap;
  swap(a.notebookGuid, b.notebookGuid);
  swap(a.inviteMessage, b.inviteMessage);
  swap(a.membershipsToUpdate, b.membershipsToUpdate);
  swap(a.invitationsToCreateOrUpdate, b.invitationsToCreateOrUpdate);
  swap(a.unshares, b.unshares);
  swap(a.__isset, b.__isset);
}

ManageNotebookSharesParameters::ManageNotebookSharesParameters(const ManageNotebookSharesParameters& other266) {
  notebookGuid = other266.notebookGuid;
  inviteMessage = other266.inviteMessage;
  membershipsToUpdate = other266.membershipsToUpdate;
  invitationsToCreateOrUpdate = other266.invitationsToCreateOrUpdate;
  unshares = other266.unshares;
  __isset = other266.__isset;
}
ManageNotebookSharesParameters& ManageNotebookSharesParameters::operator=(const ManageNotebookSharesParameters& other267) {
  notebookGuid = other267.notebookGuid;
  inviteMessage = other267.inviteMessage;
  membershipsToUpdate = other267.membershipsToUpdate;
  invitationsToCreateOrUpdate = other267.invitationsToCreateOrUpdate;
  unshares = other267.unshares;
  __isset = other267.__isset;
  return *this;
}
void ManageNotebookSharesParameters::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ManageNotebookSharesParameters(";
  out << "notebookGuid="; (__isset.notebookGuid ? (out << to_string(notebookGuid)) : (out << "<null>"));
  out << ", " << "inviteMessage="; (__isset.inviteMessage ? (out << to_string(inviteMessage)) : (out << "<null>"));
  out << ", " << "membershipsToUpdate="; (__isset.membershipsToUpdate ? (out << to_string(membershipsToUpdate)) : (out << "<null>"));
  out << ", " << "invitationsToCreateOrUpdate="; (__isset.invitationsToCreateOrUpdate ? (out << to_string(invitationsToCreateOrUpdate)) : (out << "<null>"));
  out << ", " << "unshares="; (__isset.unshares ? (out << to_string(unshares)) : (out << "<null>"));
  out << ")";
}


ManageNotebookSharesError::~ManageNotebookSharesError() throw() {
}


void ManageNotebookSharesError::__set_userIdentity(const  ::evernote::edam::UserIdentity& val) {
  this->userIdentity = val;
__isset.userIdentity = true;
}

void ManageNotebookSharesError::__set_userException(const  ::evernote::edam::EDAMUserException& val) {
  this->userException = val;
__isset.userException = true;
}

void ManageNotebookSharesError::__set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val) {
  this->notFoundException = val;
__isset.notFoundException = true;
}

uint32_t ManageNotebookSharesError::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userIdentity.read(iprot);
          this->__isset.userIdentity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ManageNotebookSharesError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ManageNotebookSharesError");

  if (this->__isset.userIdentity) {
    xfer += oprot->writeFieldBegin("userIdentity", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userIdentity.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ManageNotebookSharesError &a, ManageNotebookSharesError &b) {
  using ::std::swap;
  swap(a.userIdentity, b.userIdentity);
  swap(a.userException, b.userException);
  swap(a.notFoundException, b.notFoundException);
  swap(a.__isset, b.__isset);
}

ManageNotebookSharesError::ManageNotebookSharesError(const ManageNotebookSharesError& other268) {
  userIdentity = other268.userIdentity;
  userException = other268.userException;
  notFoundException = other268.notFoundException;
  __isset = other268.__isset;
}
ManageNotebookSharesError& ManageNotebookSharesError::operator=(const ManageNotebookSharesError& other269) {
  userIdentity = other269.userIdentity;
  userException = other269.userException;
  notFoundException = other269.notFoundException;
  __isset = other269.__isset;
  return *this;
}
void ManageNotebookSharesError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ManageNotebookSharesError(";
  out << "userIdentity="; (__isset.userIdentity ? (out << to_string(userIdentity)) : (out << "<null>"));
  out << ", " << "userException="; (__isset.userException ? (out << to_string(userException)) : (out << "<null>"));
  out << ", " << "notFoundException="; (__isset.notFoundException ? (out << to_string(notFoundException)) : (out << "<null>"));
  out << ")";
}


ManageNotebookSharesResult::~ManageNotebookSharesResult() throw() {
}


void ManageNotebookSharesResult::__set_errors(const std::vector<ManageNotebookSharesError> & val) {
  this->errors = val;
__isset.errors = true;
}

uint32_t ManageNotebookSharesResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->errors.clear();
            uint32_t _size270;
            ::apache::thrift::protocol::TType _etype273;
            xfer += iprot->readListBegin(_etype273, _size270);
            this->errors.resize(_size270);
            uint32_t _i274;
            for (_i274 = 0; _i274 < _size270; ++_i274)
            {
              xfer += this->errors[_i274].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.errors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ManageNotebookSharesResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ManageNotebookSharesResult");

  if (this->__isset.errors) {
    xfer += oprot->writeFieldBegin("errors", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->errors.size()));
      std::vector<ManageNotebookSharesError> ::const_iterator _iter275;
      for (_iter275 = this->errors.begin(); _iter275 != this->errors.end(); ++_iter275)
      {
        xfer += (*_iter275).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ManageNotebookSharesResult &a, ManageNotebookSharesResult &b) {
  using ::std::swap;
  swap(a.errors, b.errors);
  swap(a.__isset, b.__isset);
}

ManageNotebookSharesResult::ManageNotebookSharesResult(const ManageNotebookSharesResult& other276) {
  errors = other276.errors;
  __isset = other276.__isset;
}
ManageNotebookSharesResult& ManageNotebookSharesResult::operator=(const ManageNotebookSharesResult& other277) {
  errors = other277.errors;
  __isset = other277.__isset;
  return *this;
}
void ManageNotebookSharesResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ManageNotebookSharesResult(";
  out << "errors="; (__isset.errors ? (out << to_string(errors)) : (out << "<null>"));
  out << ")";
}


SharedNoteTemplate::~SharedNoteTemplate() throw() {
}


void SharedNoteTemplate::__set_noteGuid(const  ::evernote::edam::Guid& val) {
  this->noteGuid = val;
__isset.noteGuid = true;
}

void SharedNoteTemplate::__set_recipientThreadId(const  ::evernote::edam::MessageThreadID val) {
  this->recipientThreadId = val;
__isset.recipientThreadId = true;
}

void SharedNoteTemplate::__set_recipientContacts(const std::vector< ::evernote::edam::Contact> & val) {
  this->recipientContacts = val;
__isset.recipientContacts = true;
}

void SharedNoteTemplate::__set_privilege(const  ::evernote::edam::SharedNotePrivilegeLevel::type val) {
  this->privilege = val;
__isset.privilege = true;
}

uint32_t SharedNoteTemplate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->noteGuid);
          this->__isset.noteGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->recipientThreadId);
          this->__isset.recipientThreadId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->recipientContacts.clear();
            uint32_t _size278;
            ::apache::thrift::protocol::TType _etype281;
            xfer += iprot->readListBegin(_etype281, _size278);
            this->recipientContacts.resize(_size278);
            uint32_t _i282;
            for (_i282 = 0; _i282 < _size278; ++_i282)
            {
              xfer += this->recipientContacts[_i282].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.recipientContacts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast283;
          xfer += iprot->readI32(ecast283);
          this->privilege = ( ::evernote::edam::SharedNotePrivilegeLevel::type)ecast283;
          this->__isset.privilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SharedNoteTemplate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SharedNoteTemplate");

  if (this->__isset.noteGuid) {
    xfer += oprot->writeFieldBegin("noteGuid", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->noteGuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.recipientContacts) {
    xfer += oprot->writeFieldBegin("recipientContacts", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->recipientContacts.size()));
      std::vector< ::evernote::edam::Contact> ::const_iterator _iter284;
      for (_iter284 = this->recipientContacts.begin(); _iter284 != this->recipientContacts.end(); ++_iter284)
      {
        xfer += (*_iter284).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.privilege) {
    xfer += oprot->writeFieldBegin("privilege", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->privilege);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.recipientThreadId) {
    xfer += oprot->writeFieldBegin("recipientThreadId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->recipientThreadId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SharedNoteTemplate &a, SharedNoteTemplate &b) {
  using ::std::swap;
  swap(a.noteGuid, b.noteGuid);
  swap(a.recipientThreadId, b.recipientThreadId);
  swap(a.recipientContacts, b.recipientContacts);
  swap(a.privilege, b.privilege);
  swap(a.__isset, b.__isset);
}

SharedNoteTemplate::SharedNoteTemplate(const SharedNoteTemplate& other285) {
  noteGuid = other285.noteGuid;
  recipientThreadId = other285.recipientThreadId;
  recipientContacts = other285.recipientContacts;
  privilege = other285.privilege;
  __isset = other285.__isset;
}
SharedNoteTemplate& SharedNoteTemplate::operator=(const SharedNoteTemplate& other286) {
  noteGuid = other286.noteGuid;
  recipientThreadId = other286.recipientThreadId;
  recipientContacts = other286.recipientContacts;
  privilege = other286.privilege;
  __isset = other286.__isset;
  return *this;
}
void SharedNoteTemplate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SharedNoteTemplate(";
  out << "noteGuid="; (__isset.noteGuid ? (out << to_string(noteGuid)) : (out << "<null>"));
  out << ", " << "recipientThreadId="; (__isset.recipientThreadId ? (out << to_string(recipientThreadId)) : (out << "<null>"));
  out << ", " << "recipientContacts="; (__isset.recipientContacts ? (out << to_string(recipientContacts)) : (out << "<null>"));
  out << ", " << "privilege="; (__isset.privilege ? (out << to_string(privilege)) : (out << "<null>"));
  out << ")";
}


NotebookShareTemplate::~NotebookShareTemplate() throw() {
}


void NotebookShareTemplate::__set_notebookGuid(const  ::evernote::edam::Guid& val) {
  this->notebookGuid = val;
__isset.notebookGuid = true;
}

void NotebookShareTemplate::__set_recipientThreadId(const  ::evernote::edam::MessageThreadID val) {
  this->recipientThreadId = val;
__isset.recipientThreadId = true;
}

void NotebookShareTemplate::__set_recipientContacts(const std::vector< ::evernote::edam::Contact> & val) {
  this->recipientContacts = val;
__isset.recipientContacts = true;
}

void NotebookShareTemplate::__set_privilege(const  ::evernote::edam::SharedNotebookPrivilegeLevel::type val) {
  this->privilege = val;
__isset.privilege = true;
}

uint32_t NotebookShareTemplate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->notebookGuid);
          this->__isset.notebookGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->recipientThreadId);
          this->__isset.recipientThreadId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->recipientContacts.clear();
            uint32_t _size287;
            ::apache::thrift::protocol::TType _etype290;
            xfer += iprot->readListBegin(_etype290, _size287);
            this->recipientContacts.resize(_size287);
            uint32_t _i291;
            for (_i291 = 0; _i291 < _size287; ++_i291)
            {
              xfer += this->recipientContacts[_i291].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.recipientContacts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast292;
          xfer += iprot->readI32(ecast292);
          this->privilege = ( ::evernote::edam::SharedNotebookPrivilegeLevel::type)ecast292;
          this->__isset.privilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotebookShareTemplate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotebookShareTemplate");

  if (this->__isset.notebookGuid) {
    xfer += oprot->writeFieldBegin("notebookGuid", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->notebookGuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.recipientContacts) {
    xfer += oprot->writeFieldBegin("recipientContacts", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->recipientContacts.size()));
      std::vector< ::evernote::edam::Contact> ::const_iterator _iter293;
      for (_iter293 = this->recipientContacts.begin(); _iter293 != this->recipientContacts.end(); ++_iter293)
      {
        xfer += (*_iter293).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.privilege) {
    xfer += oprot->writeFieldBegin("privilege", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->privilege);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.recipientThreadId) {
    xfer += oprot->writeFieldBegin("recipientThreadId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->recipientThreadId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotebookShareTemplate &a, NotebookShareTemplate &b) {
  using ::std::swap;
  swap(a.notebookGuid, b.notebookGuid);
  swap(a.recipientThreadId, b.recipientThreadId);
  swap(a.recipientContacts, b.recipientContacts);
  swap(a.privilege, b.privilege);
  swap(a.__isset, b.__isset);
}

NotebookShareTemplate::NotebookShareTemplate(const NotebookShareTemplate& other294) {
  notebookGuid = other294.notebookGuid;
  recipientThreadId = other294.recipientThreadId;
  recipientContacts = other294.recipientContacts;
  privilege = other294.privilege;
  __isset = other294.__isset;
}
NotebookShareTemplate& NotebookShareTemplate::operator=(const NotebookShareTemplate& other295) {
  notebookGuid = other295.notebookGuid;
  recipientThreadId = other295.recipientThreadId;
  recipientContacts = other295.recipientContacts;
  privilege = other295.privilege;
  __isset = other295.__isset;
  return *this;
}
void NotebookShareTemplate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotebookShareTemplate(";
  out << "notebookGuid="; (__isset.notebookGuid ? (out << to_string(notebookGuid)) : (out << "<null>"));
  out << ", " << "recipientThreadId="; (__isset.recipientThreadId ? (out << to_string(recipientThreadId)) : (out << "<null>"));
  out << ", " << "recipientContacts="; (__isset.recipientContacts ? (out << to_string(recipientContacts)) : (out << "<null>"));
  out << ", " << "privilege="; (__isset.privilege ? (out << to_string(privilege)) : (out << "<null>"));
  out << ")";
}


CreateOrUpdateNotebookSharesResult::~CreateOrUpdateNotebookSharesResult() throw() {
}


void CreateOrUpdateNotebookSharesResult::__set_updateSequenceNum(const int32_t val) {
  this->updateSequenceNum = val;
__isset.updateSequenceNum = true;
}

void CreateOrUpdateNotebookSharesResult::__set_matchingShares(const std::vector< ::evernote::edam::SharedNotebook> & val) {
  this->matchingShares = val;
__isset.matchingShares = true;
}

uint32_t CreateOrUpdateNotebookSharesResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->updateSequenceNum);
          this->__isset.updateSequenceNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->matchingShares.clear();
            uint32_t _size296;
            ::apache::thrift::protocol::TType _etype299;
            xfer += iprot->readListBegin(_etype299, _size296);
            this->matchingShares.resize(_size296);
            uint32_t _i300;
            for (_i300 = 0; _i300 < _size296; ++_i300)
            {
              xfer += this->matchingShares[_i300].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.matchingShares = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateOrUpdateNotebookSharesResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateOrUpdateNotebookSharesResult");

  if (this->__isset.updateSequenceNum) {
    xfer += oprot->writeFieldBegin("updateSequenceNum", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->updateSequenceNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.matchingShares) {
    xfer += oprot->writeFieldBegin("matchingShares", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->matchingShares.size()));
      std::vector< ::evernote::edam::SharedNotebook> ::const_iterator _iter301;
      for (_iter301 = this->matchingShares.begin(); _iter301 != this->matchingShares.end(); ++_iter301)
      {
        xfer += (*_iter301).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateOrUpdateNotebookSharesResult &a, CreateOrUpdateNotebookSharesResult &b) {
  using ::std::swap;
  swap(a.updateSequenceNum, b.updateSequenceNum);
  swap(a.matchingShares, b.matchingShares);
  swap(a.__isset, b.__isset);
}

CreateOrUpdateNotebookSharesResult::CreateOrUpdateNotebookSharesResult(const CreateOrUpdateNotebookSharesResult& other302) {
  updateSequenceNum = other302.updateSequenceNum;
  matchingShares = other302.matchingShares;
  __isset = other302.__isset;
}
CreateOrUpdateNotebookSharesResult& CreateOrUpdateNotebookSharesResult::operator=(const CreateOrUpdateNotebookSharesResult& other303) {
  updateSequenceNum = other303.updateSequenceNum;
  matchingShares = other303.matchingShares;
  __isset = other303.__isset;
  return *this;
}
void CreateOrUpdateNotebookSharesResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateOrUpdateNotebookSharesResult(";
  out << "updateSequenceNum="; (__isset.updateSequenceNum ? (out << to_string(updateSequenceNum)) : (out << "<null>"));
  out << ", " << "matchingShares="; (__isset.matchingShares ? (out << to_string(matchingShares)) : (out << "<null>"));
  out << ")";
}


NoteShareRelationshipRestrictions::~NoteShareRelationshipRestrictions() throw() {
}


void NoteShareRelationshipRestrictions::__set_noSetReadNote(const bool val) {
  this->noSetReadNote = val;
__isset.noSetReadNote = true;
}

void NoteShareRelationshipRestrictions::__set_noSetModifyNote(const bool val) {
  this->noSetModifyNote = val;
__isset.noSetModifyNote = true;
}

void NoteShareRelationshipRestrictions::__set_noSetFullAccess(const bool val) {
  this->noSetFullAccess = val;
__isset.noSetFullAccess = true;
}

uint32_t NoteShareRelationshipRestrictions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->noSetReadNote);
          this->__isset.noSetReadNote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->noSetModifyNote);
          this->__isset.noSetModifyNote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->noSetFullAccess);
          this->__isset.noSetFullAccess = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteShareRelationshipRestrictions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteShareRelationshipRestrictions");

  if (this->__isset.noSetReadNote) {
    xfer += oprot->writeFieldBegin("noSetReadNote", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->noSetReadNote);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.noSetModifyNote) {
    xfer += oprot->writeFieldBegin("noSetModifyNote", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->noSetModifyNote);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.noSetFullAccess) {
    xfer += oprot->writeFieldBegin("noSetFullAccess", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->noSetFullAccess);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoteShareRelationshipRestrictions &a, NoteShareRelationshipRestrictions &b) {
  using ::std::swap;
  swap(a.noSetReadNote, b.noSetReadNote);
  swap(a.noSetModifyNote, b.noSetModifyNote);
  swap(a.noSetFullAccess, b.noSetFullAccess);
  swap(a.__isset, b.__isset);
}

NoteShareRelationshipRestrictions::NoteShareRelationshipRestrictions(const NoteShareRelationshipRestrictions& other304) {
  noSetReadNote = other304.noSetReadNote;
  noSetModifyNote = other304.noSetModifyNote;
  noSetFullAccess = other304.noSetFullAccess;
  __isset = other304.__isset;
}
NoteShareRelationshipRestrictions& NoteShareRelationshipRestrictions::operator=(const NoteShareRelationshipRestrictions& other305) {
  noSetReadNote = other305.noSetReadNote;
  noSetModifyNote = other305.noSetModifyNote;
  noSetFullAccess = other305.noSetFullAccess;
  __isset = other305.__isset;
  return *this;
}
void NoteShareRelationshipRestrictions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoteShareRelationshipRestrictions(";
  out << "noSetReadNote="; (__isset.noSetReadNote ? (out << to_string(noSetReadNote)) : (out << "<null>"));
  out << ", " << "noSetModifyNote="; (__isset.noSetModifyNote ? (out << to_string(noSetModifyNote)) : (out << "<null>"));
  out << ", " << "noSetFullAccess="; (__isset.noSetFullAccess ? (out << to_string(noSetFullAccess)) : (out << "<null>"));
  out << ")";
}


NoteMemberShareRelationship::~NoteMemberShareRelationship() throw() {
}


void NoteMemberShareRelationship::__set_displayName(const std::string& val) {
  this->displayName = val;
__isset.displayName = true;
}

void NoteMemberShareRelationship::__set_recipientUserId(const  ::evernote::edam::UserID val) {
  this->recipientUserId = val;
__isset.recipientUserId = true;
}

void NoteMemberShareRelationship::__set_privilege(const  ::evernote::edam::SharedNotePrivilegeLevel::type val) {
  this->privilege = val;
__isset.privilege = true;
}

void NoteMemberShareRelationship::__set_restrictions(const NoteShareRelationshipRestrictions& val) {
  this->restrictions = val;
__isset.restrictions = true;
}

void NoteMemberShareRelationship::__set_sharerUserId(const  ::evernote::edam::UserID val) {
  this->sharerUserId = val;
__isset.sharerUserId = true;
}

uint32_t NoteMemberShareRelationship::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayName);
          this->__isset.displayName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->recipientUserId);
          this->__isset.recipientUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast306;
          xfer += iprot->readI32(ecast306);
          this->privilege = ( ::evernote::edam::SharedNotePrivilegeLevel::type)ecast306;
          this->__isset.privilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->restrictions.read(iprot);
          this->__isset.restrictions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sharerUserId);
          this->__isset.sharerUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteMemberShareRelationship::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteMemberShareRelationship");

  if (this->__isset.displayName) {
    xfer += oprot->writeFieldBegin("displayName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->displayName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.recipientUserId) {
    xfer += oprot->writeFieldBegin("recipientUserId", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->recipientUserId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.privilege) {
    xfer += oprot->writeFieldBegin("privilege", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->privilege);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.restrictions) {
    xfer += oprot->writeFieldBegin("restrictions", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->restrictions.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sharerUserId) {
    xfer += oprot->writeFieldBegin("sharerUserId", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->sharerUserId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoteMemberShareRelationship &a, NoteMemberShareRelationship &b) {
  using ::std::swap;
  swap(a.displayName, b.displayName);
  swap(a.recipientUserId, b.recipientUserId);
  swap(a.privilege, b.privilege);
  swap(a.restrictions, b.restrictions);
  swap(a.sharerUserId, b.sharerUserId);
  swap(a.__isset, b.__isset);
}

NoteMemberShareRelationship::NoteMemberShareRelationship(const NoteMemberShareRelationship& other307) {
  displayName = other307.displayName;
  recipientUserId = other307.recipientUserId;
  privilege = other307.privilege;
  restrictions = other307.restrictions;
  sharerUserId = other307.sharerUserId;
  __isset = other307.__isset;
}
NoteMemberShareRelationship& NoteMemberShareRelationship::operator=(const NoteMemberShareRelationship& other308) {
  displayName = other308.displayName;
  recipientUserId = other308.recipientUserId;
  privilege = other308.privilege;
  restrictions = other308.restrictions;
  sharerUserId = other308.sharerUserId;
  __isset = other308.__isset;
  return *this;
}
void NoteMemberShareRelationship::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoteMemberShareRelationship(";
  out << "displayName="; (__isset.displayName ? (out << to_string(displayName)) : (out << "<null>"));
  out << ", " << "recipientUserId="; (__isset.recipientUserId ? (out << to_string(recipientUserId)) : (out << "<null>"));
  out << ", " << "privilege="; (__isset.privilege ? (out << to_string(privilege)) : (out << "<null>"));
  out << ", " << "restrictions="; (__isset.restrictions ? (out << to_string(restrictions)) : (out << "<null>"));
  out << ", " << "sharerUserId="; (__isset.sharerUserId ? (out << to_string(sharerUserId)) : (out << "<null>"));
  out << ")";
}


NoteInvitationShareRelationship::~NoteInvitationShareRelationship() throw() {
}


void NoteInvitationShareRelationship::__set_displayName(const std::string& val) {
  this->displayName = val;
__isset.displayName = true;
}

void NoteInvitationShareRelationship::__set_recipientIdentityId(const  ::evernote::edam::IdentityID val) {
  this->recipientIdentityId = val;
__isset.recipientIdentityId = true;
}

void NoteInvitationShareRelationship::__set_privilege(const  ::evernote::edam::SharedNotePrivilegeLevel::type val) {
  this->privilege = val;
__isset.privilege = true;
}

void NoteInvitationShareRelationship::__set_sharerUserId(const  ::evernote::edam::UserID val) {
  this->sharerUserId = val;
__isset.sharerUserId = true;
}

uint32_t NoteInvitationShareRelationship::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayName);
          this->__isset.displayName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->recipientIdentityId);
          this->__isset.recipientIdentityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast309;
          xfer += iprot->readI32(ecast309);
          this->privilege = ( ::evernote::edam::SharedNotePrivilegeLevel::type)ecast309;
          this->__isset.privilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sharerUserId);
          this->__isset.sharerUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteInvitationShareRelationship::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteInvitationShareRelationship");

  if (this->__isset.displayName) {
    xfer += oprot->writeFieldBegin("displayName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->displayName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.recipientIdentityId) {
    xfer += oprot->writeFieldBegin("recipientIdentityId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->recipientIdentityId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.privilege) {
    xfer += oprot->writeFieldBegin("privilege", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->privilege);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sharerUserId) {
    xfer += oprot->writeFieldBegin("sharerUserId", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->sharerUserId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoteInvitationShareRelationship &a, NoteInvitationShareRelationship &b) {
  using ::std::swap;
  swap(a.displayName, b.displayName);
  swap(a.recipientIdentityId, b.recipientIdentityId);
  swap(a.privilege, b.privilege);
  swap(a.sharerUserId, b.sharerUserId);
  swap(a.__isset, b.__isset);
}

NoteInvitationShareRelationship::NoteInvitationShareRelationship(const NoteInvitationShareRelationship& other310) {
  displayName = other310.displayName;
  recipientIdentityId = other310.recipientIdentityId;
  privilege = other310.privilege;
  sharerUserId = other310.sharerUserId;
  __isset = other310.__isset;
}
NoteInvitationShareRelationship& NoteInvitationShareRelationship::operator=(const NoteInvitationShareRelationship& other311) {
  displayName = other311.displayName;
  recipientIdentityId = other311.recipientIdentityId;
  privilege = other311.privilege;
  sharerUserId = other311.sharerUserId;
  __isset = other311.__isset;
  return *this;
}
void NoteInvitationShareRelationship::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoteInvitationShareRelationship(";
  out << "displayName="; (__isset.displayName ? (out << to_string(displayName)) : (out << "<null>"));
  out << ", " << "recipientIdentityId="; (__isset.recipientIdentityId ? (out << to_string(recipientIdentityId)) : (out << "<null>"));
  out << ", " << "privilege="; (__isset.privilege ? (out << to_string(privilege)) : (out << "<null>"));
  out << ", " << "sharerUserId="; (__isset.sharerUserId ? (out << to_string(sharerUserId)) : (out << "<null>"));
  out << ")";
}


NoteShareRelationships::~NoteShareRelationships() throw() {
}


void NoteShareRelationships::__set_invitations(const std::vector<NoteInvitationShareRelationship> & val) {
  this->invitations = val;
__isset.invitations = true;
}

void NoteShareRelationships::__set_memberships(const std::vector<NoteMemberShareRelationship> & val) {
  this->memberships = val;
__isset.memberships = true;
}

void NoteShareRelationships::__set_invitationRestrictions(const NoteShareRelationshipRestrictions& val) {
  this->invitationRestrictions = val;
__isset.invitationRestrictions = true;
}

uint32_t NoteShareRelationships::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->invitations.clear();
            uint32_t _size312;
            ::apache::thrift::protocol::TType _etype315;
            xfer += iprot->readListBegin(_etype315, _size312);
            this->invitations.resize(_size312);
            uint32_t _i316;
            for (_i316 = 0; _i316 < _size312; ++_i316)
            {
              xfer += this->invitations[_i316].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.invitations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->memberships.clear();
            uint32_t _size317;
            ::apache::thrift::protocol::TType _etype320;
            xfer += iprot->readListBegin(_etype320, _size317);
            this->memberships.resize(_size317);
            uint32_t _i321;
            for (_i321 = 0; _i321 < _size317; ++_i321)
            {
              xfer += this->memberships[_i321].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.memberships = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->invitationRestrictions.read(iprot);
          this->__isset.invitationRestrictions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteShareRelationships::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteShareRelationships");

  if (this->__isset.invitations) {
    xfer += oprot->writeFieldBegin("invitations", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->invitations.size()));
      std::vector<NoteInvitationShareRelationship> ::const_iterator _iter322;
      for (_iter322 = this->invitations.begin(); _iter322 != this->invitations.end(); ++_iter322)
      {
        xfer += (*_iter322).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memberships) {
    xfer += oprot->writeFieldBegin("memberships", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->memberships.size()));
      std::vector<NoteMemberShareRelationship> ::const_iterator _iter323;
      for (_iter323 = this->memberships.begin(); _iter323 != this->memberships.end(); ++_iter323)
      {
        xfer += (*_iter323).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.invitationRestrictions) {
    xfer += oprot->writeFieldBegin("invitationRestrictions", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->invitationRestrictions.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoteShareRelationships &a, NoteShareRelationships &b) {
  using ::std::swap;
  swap(a.invitations, b.invitations);
  swap(a.memberships, b.memberships);
  swap(a.invitationRestrictions, b.invitationRestrictions);
  swap(a.__isset, b.__isset);
}

NoteShareRelationships::NoteShareRelationships(const NoteShareRelationships& other324) {
  invitations = other324.invitations;
  memberships = other324.memberships;
  invitationRestrictions = other324.invitationRestrictions;
  __isset = other324.__isset;
}
NoteShareRelationships& NoteShareRelationships::operator=(const NoteShareRelationships& other325) {
  invitations = other325.invitations;
  memberships = other325.memberships;
  invitationRestrictions = other325.invitationRestrictions;
  __isset = other325.__isset;
  return *this;
}
void NoteShareRelationships::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoteShareRelationships(";
  out << "invitations="; (__isset.invitations ? (out << to_string(invitations)) : (out << "<null>"));
  out << ", " << "memberships="; (__isset.memberships ? (out << to_string(memberships)) : (out << "<null>"));
  out << ", " << "invitationRestrictions="; (__isset.invitationRestrictions ? (out << to_string(invitationRestrictions)) : (out << "<null>"));
  out << ")";
}


ManageNoteSharesParameters::~ManageNoteSharesParameters() throw() {
}


void ManageNoteSharesParameters::__set_noteGuid(const std::string& val) {
  this->noteGuid = val;
__isset.noteGuid = true;
}

void ManageNoteSharesParameters::__set_membershipsToUpdate(const std::vector<NoteMemberShareRelationship> & val) {
  this->membershipsToUpdate = val;
__isset.membershipsToUpdate = true;
}

void ManageNoteSharesParameters::__set_invitationsToUpdate(const std::vector<NoteInvitationShareRelationship> & val) {
  this->invitationsToUpdate = val;
__isset.invitationsToUpdate = true;
}

void ManageNoteSharesParameters::__set_membershipsToUnshare(const std::vector< ::evernote::edam::UserID> & val) {
  this->membershipsToUnshare = val;
__isset.membershipsToUnshare = true;
}

void ManageNoteSharesParameters::__set_invitationsToUnshare(const std::vector< ::evernote::edam::IdentityID> & val) {
  this->invitationsToUnshare = val;
__isset.invitationsToUnshare = true;
}

uint32_t ManageNoteSharesParameters::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->noteGuid);
          this->__isset.noteGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->membershipsToUpdate.clear();
            uint32_t _size326;
            ::apache::thrift::protocol::TType _etype329;
            xfer += iprot->readListBegin(_etype329, _size326);
            this->membershipsToUpdate.resize(_size326);
            uint32_t _i330;
            for (_i330 = 0; _i330 < _size326; ++_i330)
            {
              xfer += this->membershipsToUpdate[_i330].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.membershipsToUpdate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->invitationsToUpdate.clear();
            uint32_t _size331;
            ::apache::thrift::protocol::TType _etype334;
            xfer += iprot->readListBegin(_etype334, _size331);
            this->invitationsToUpdate.resize(_size331);
            uint32_t _i335;
            for (_i335 = 0; _i335 < _size331; ++_i335)
            {
              xfer += this->invitationsToUpdate[_i335].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.invitationsToUpdate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->membershipsToUnshare.clear();
            uint32_t _size336;
            ::apache::thrift::protocol::TType _etype339;
            xfer += iprot->readListBegin(_etype339, _size336);
            this->membershipsToUnshare.resize(_size336);
            uint32_t _i340;
            for (_i340 = 0; _i340 < _size336; ++_i340)
            {
              xfer += iprot->readI32(this->membershipsToUnshare[_i340]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.membershipsToUnshare = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->invitationsToUnshare.clear();
            uint32_t _size341;
            ::apache::thrift::protocol::TType _etype344;
            xfer += iprot->readListBegin(_etype344, _size341);
            this->invitationsToUnshare.resize(_size341);
            uint32_t _i345;
            for (_i345 = 0; _i345 < _size341; ++_i345)
            {
              xfer += iprot->readI64(this->invitationsToUnshare[_i345]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.invitationsToUnshare = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ManageNoteSharesParameters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ManageNoteSharesParameters");

  if (this->__isset.noteGuid) {
    xfer += oprot->writeFieldBegin("noteGuid", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->noteGuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.membershipsToUpdate) {
    xfer += oprot->writeFieldBegin("membershipsToUpdate", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->membershipsToUpdate.size()));
      std::vector<NoteMemberShareRelationship> ::const_iterator _iter346;
      for (_iter346 = this->membershipsToUpdate.begin(); _iter346 != this->membershipsToUpdate.end(); ++_iter346)
      {
        xfer += (*_iter346).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.invitationsToUpdate) {
    xfer += oprot->writeFieldBegin("invitationsToUpdate", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->invitationsToUpdate.size()));
      std::vector<NoteInvitationShareRelationship> ::const_iterator _iter347;
      for (_iter347 = this->invitationsToUpdate.begin(); _iter347 != this->invitationsToUpdate.end(); ++_iter347)
      {
        xfer += (*_iter347).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.membershipsToUnshare) {
    xfer += oprot->writeFieldBegin("membershipsToUnshare", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->membershipsToUnshare.size()));
      std::vector< ::evernote::edam::UserID> ::const_iterator _iter348;
      for (_iter348 = this->membershipsToUnshare.begin(); _iter348 != this->membershipsToUnshare.end(); ++_iter348)
      {
        xfer += oprot->writeI32((*_iter348));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.invitationsToUnshare) {
    xfer += oprot->writeFieldBegin("invitationsToUnshare", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->invitationsToUnshare.size()));
      std::vector< ::evernote::edam::IdentityID> ::const_iterator _iter349;
      for (_iter349 = this->invitationsToUnshare.begin(); _iter349 != this->invitationsToUnshare.end(); ++_iter349)
      {
        xfer += oprot->writeI64((*_iter349));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ManageNoteSharesParameters &a, ManageNoteSharesParameters &b) {
  using ::std::swap;
  swap(a.noteGuid, b.noteGuid);
  swap(a.membershipsToUpdate, b.membershipsToUpdate);
  swap(a.invitationsToUpdate, b.invitationsToUpdate);
  swap(a.membershipsToUnshare, b.membershipsToUnshare);
  swap(a.invitationsToUnshare, b.invitationsToUnshare);
  swap(a.__isset, b.__isset);
}

ManageNoteSharesParameters::ManageNoteSharesParameters(const ManageNoteSharesParameters& other350) {
  noteGuid = other350.noteGuid;
  membershipsToUpdate = other350.membershipsToUpdate;
  invitationsToUpdate = other350.invitationsToUpdate;
  membershipsToUnshare = other350.membershipsToUnshare;
  invitationsToUnshare = other350.invitationsToUnshare;
  __isset = other350.__isset;
}
ManageNoteSharesParameters& ManageNoteSharesParameters::operator=(const ManageNoteSharesParameters& other351) {
  noteGuid = other351.noteGuid;
  membershipsToUpdate = other351.membershipsToUpdate;
  invitationsToUpdate = other351.invitationsToUpdate;
  membershipsToUnshare = other351.membershipsToUnshare;
  invitationsToUnshare = other351.invitationsToUnshare;
  __isset = other351.__isset;
  return *this;
}
void ManageNoteSharesParameters::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ManageNoteSharesParameters(";
  out << "noteGuid="; (__isset.noteGuid ? (out << to_string(noteGuid)) : (out << "<null>"));
  out << ", " << "membershipsToUpdate="; (__isset.membershipsToUpdate ? (out << to_string(membershipsToUpdate)) : (out << "<null>"));
  out << ", " << "invitationsToUpdate="; (__isset.invitationsToUpdate ? (out << to_string(invitationsToUpdate)) : (out << "<null>"));
  out << ", " << "membershipsToUnshare="; (__isset.membershipsToUnshare ? (out << to_string(membershipsToUnshare)) : (out << "<null>"));
  out << ", " << "invitationsToUnshare="; (__isset.invitationsToUnshare ? (out << to_string(invitationsToUnshare)) : (out << "<null>"));
  out << ")";
}


ManageNoteSharesError::~ManageNoteSharesError() throw() {
}


void ManageNoteSharesError::__set_identityID(const  ::evernote::edam::IdentityID val) {
  this->identityID = val;
__isset.identityID = true;
}

void ManageNoteSharesError::__set_userID(const  ::evernote::edam::UserID val) {
  this->userID = val;
__isset.userID = true;
}

void ManageNoteSharesError::__set_userException(const  ::evernote::edam::EDAMUserException& val) {
  this->userException = val;
__isset.userException = true;
}

void ManageNoteSharesError::__set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val) {
  this->notFoundException = val;
__isset.notFoundException = true;
}

uint32_t ManageNoteSharesError::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->identityID);
          this->__isset.identityID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userID);
          this->__isset.userID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ManageNoteSharesError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ManageNoteSharesError");

  if (this->__isset.identityID) {
    xfer += oprot->writeFieldBegin("identityID", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->identityID);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userID) {
    xfer += oprot->writeFieldBegin("userID", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->userID);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ManageNoteSharesError &a, ManageNoteSharesError &b) {
  using ::std::swap;
  swap(a.identityID, b.identityID);
  swap(a.userID, b.userID);
  swap(a.userException, b.userException);
  swap(a.notFoundException, b.notFoundException);
  swap(a.__isset, b.__isset);
}

ManageNoteSharesError::ManageNoteSharesError(const ManageNoteSharesError& other352) {
  identityID = other352.identityID;
  userID = other352.userID;
  userException = other352.userException;
  notFoundException = other352.notFoundException;
  __isset = other352.__isset;
}
ManageNoteSharesError& ManageNoteSharesError::operator=(const ManageNoteSharesError& other353) {
  identityID = other353.identityID;
  userID = other353.userID;
  userException = other353.userException;
  notFoundException = other353.notFoundException;
  __isset = other353.__isset;
  return *this;
}
void ManageNoteSharesError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ManageNoteSharesError(";
  out << "identityID="; (__isset.identityID ? (out << to_string(identityID)) : (out << "<null>"));
  out << ", " << "userID="; (__isset.userID ? (out << to_string(userID)) : (out << "<null>"));
  out << ", " << "userException="; (__isset.userException ? (out << to_string(userException)) : (out << "<null>"));
  out << ", " << "notFoundException="; (__isset.notFoundException ? (out << to_string(notFoundException)) : (out << "<null>"));
  out << ")";
}


ManageNoteSharesResult::~ManageNoteSharesResult() throw() {
}


void ManageNoteSharesResult::__set_errors(const std::vector<ManageNoteSharesError> & val) {
  this->errors = val;
__isset.errors = true;
}

uint32_t ManageNoteSharesResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->errors.clear();
            uint32_t _size354;
            ::apache::thrift::protocol::TType _etype357;
            xfer += iprot->readListBegin(_etype357, _size354);
            this->errors.resize(_size354);
            uint32_t _i358;
            for (_i358 = 0; _i358 < _size354; ++_i358)
            {
              xfer += this->errors[_i358].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.errors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ManageNoteSharesResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ManageNoteSharesResult");

  if (this->__isset.errors) {
    xfer += oprot->writeFieldBegin("errors", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->errors.size()));
      std::vector<ManageNoteSharesError> ::const_iterator _iter359;
      for (_iter359 = this->errors.begin(); _iter359 != this->errors.end(); ++_iter359)
      {
        xfer += (*_iter359).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ManageNoteSharesResult &a, ManageNoteSharesResult &b) {
  using ::std::swap;
  swap(a.errors, b.errors);
  swap(a.__isset, b.__isset);
}

ManageNoteSharesResult::ManageNoteSharesResult(const ManageNoteSharesResult& other360) {
  errors = other360.errors;
  __isset = other360.__isset;
}
ManageNoteSharesResult& ManageNoteSharesResult::operator=(const ManageNoteSharesResult& other361) {
  errors = other361.errors;
  __isset = other361.__isset;
  return *this;
}
void ManageNoteSharesResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ManageNoteSharesResult(";
  out << "errors="; (__isset.errors ? (out << to_string(errors)) : (out << "<null>"));
  out << ")";
}

}} // namespace
