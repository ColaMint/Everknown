/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Errors_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace evernote { namespace edam {

int _kEDAMErrorCodeValues[] = {
  EDAMErrorCode::UNKNOWN,
  EDAMErrorCode::BAD_DATA_FORMAT,
  EDAMErrorCode::PERMISSION_DENIED,
  EDAMErrorCode::INTERNAL_ERROR,
  EDAMErrorCode::DATA_REQUIRED,
  EDAMErrorCode::LIMIT_REACHED,
  EDAMErrorCode::QUOTA_REACHED,
  EDAMErrorCode::INVALID_AUTH,
  EDAMErrorCode::AUTH_EXPIRED,
  EDAMErrorCode::DATA_CONFLICT,
  EDAMErrorCode::ENML_VALIDATION,
  EDAMErrorCode::SHARD_UNAVAILABLE,
  EDAMErrorCode::LEN_TOO_SHORT,
  EDAMErrorCode::LEN_TOO_LONG,
  EDAMErrorCode::TOO_FEW,
  EDAMErrorCode::TOO_MANY,
  EDAMErrorCode::UNSUPPORTED_OPERATION,
  EDAMErrorCode::TAKEN_DOWN,
  EDAMErrorCode::RATE_LIMIT_REACHED,
  EDAMErrorCode::BUSINESS_SECURITY_LOGIN_REQUIRED,
  EDAMErrorCode::DEVICE_LIMIT_REACHED
};
const char* _kEDAMErrorCodeNames[] = {
  "UNKNOWN",
  "BAD_DATA_FORMAT",
  "PERMISSION_DENIED",
  "INTERNAL_ERROR",
  "DATA_REQUIRED",
  "LIMIT_REACHED",
  "QUOTA_REACHED",
  "INVALID_AUTH",
  "AUTH_EXPIRED",
  "DATA_CONFLICT",
  "ENML_VALIDATION",
  "SHARD_UNAVAILABLE",
  "LEN_TOO_SHORT",
  "LEN_TOO_LONG",
  "TOO_FEW",
  "TOO_MANY",
  "UNSUPPORTED_OPERATION",
  "TAKEN_DOWN",
  "RATE_LIMIT_REACHED",
  "BUSINESS_SECURITY_LOGIN_REQUIRED",
  "DEVICE_LIMIT_REACHED"
};
const std::map<int, const char*> _EDAMErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(21, _kEDAMErrorCodeValues, _kEDAMErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kEDAMInvalidContactReasonValues[] = {
  EDAMInvalidContactReason::BAD_ADDRESS,
  EDAMInvalidContactReason::DUPLICATE_CONTACT,
  EDAMInvalidContactReason::NO_CONNECTION
};
const char* _kEDAMInvalidContactReasonNames[] = {
  "BAD_ADDRESS",
  "DUPLICATE_CONTACT",
  "NO_CONNECTION"
};
const std::map<int, const char*> _EDAMInvalidContactReason_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kEDAMInvalidContactReasonValues, _kEDAMInvalidContactReasonNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


EDAMUserException::~EDAMUserException() throw() {
}


void EDAMUserException::__set_errorCode(const EDAMErrorCode::type val) {
  this->errorCode = val;
}

void EDAMUserException::__set_parameter(const std::string& val) {
  this->parameter = val;
__isset.parameter = true;
}

uint32_t EDAMUserException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_errorCode = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->errorCode = (EDAMErrorCode::type)ecast0;
          isset_errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parameter);
          this->__isset.parameter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_errorCode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t EDAMUserException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EDAMUserException");

  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->errorCode);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.parameter) {
    xfer += oprot->writeFieldBegin("parameter", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->parameter);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EDAMUserException &a, EDAMUserException &b) {
  using ::std::swap;
  swap(a.errorCode, b.errorCode);
  swap(a.parameter, b.parameter);
  swap(a.__isset, b.__isset);
}

EDAMUserException::EDAMUserException(const EDAMUserException& other1) : TException() {
  errorCode = other1.errorCode;
  parameter = other1.parameter;
  __isset = other1.__isset;
}
EDAMUserException& EDAMUserException::operator=(const EDAMUserException& other2) {
  errorCode = other2.errorCode;
  parameter = other2.parameter;
  __isset = other2.__isset;
  return *this;
}
void EDAMUserException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EDAMUserException(";
  out << "errorCode=" << to_string(errorCode);
  out << ", " << "parameter="; (__isset.parameter ? (out << to_string(parameter)) : (out << "<null>"));
  out << ")";
}

const char* EDAMUserException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: EDAMUserException";
  }
}


EDAMSystemException::~EDAMSystemException() throw() {
}


void EDAMSystemException::__set_errorCode(const EDAMErrorCode::type val) {
  this->errorCode = val;
}

void EDAMSystemException::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}

void EDAMSystemException::__set_rateLimitDuration(const int32_t val) {
  this->rateLimitDuration = val;
__isset.rateLimitDuration = true;
}

uint32_t EDAMSystemException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_errorCode = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->errorCode = (EDAMErrorCode::type)ecast3;
          isset_errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rateLimitDuration);
          this->__isset.rateLimitDuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_errorCode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t EDAMSystemException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EDAMSystemException");

  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->errorCode);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rateLimitDuration) {
    xfer += oprot->writeFieldBegin("rateLimitDuration", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->rateLimitDuration);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EDAMSystemException &a, EDAMSystemException &b) {
  using ::std::swap;
  swap(a.errorCode, b.errorCode);
  swap(a.message, b.message);
  swap(a.rateLimitDuration, b.rateLimitDuration);
  swap(a.__isset, b.__isset);
}

EDAMSystemException::EDAMSystemException(const EDAMSystemException& other4) : TException() {
  errorCode = other4.errorCode;
  message = other4.message;
  rateLimitDuration = other4.rateLimitDuration;
  __isset = other4.__isset;
}
EDAMSystemException& EDAMSystemException::operator=(const EDAMSystemException& other5) {
  errorCode = other5.errorCode;
  message = other5.message;
  rateLimitDuration = other5.rateLimitDuration;
  __isset = other5.__isset;
  return *this;
}
void EDAMSystemException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EDAMSystemException(";
  out << "errorCode=" << to_string(errorCode);
  out << ", " << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ", " << "rateLimitDuration="; (__isset.rateLimitDuration ? (out << to_string(rateLimitDuration)) : (out << "<null>"));
  out << ")";
}

const char* EDAMSystemException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: EDAMSystemException";
  }
}


EDAMNotFoundException::~EDAMNotFoundException() throw() {
}


void EDAMNotFoundException::__set_identifier(const std::string& val) {
  this->identifier = val;
__isset.identifier = true;
}

void EDAMNotFoundException::__set_key(const std::string& val) {
  this->key = val;
__isset.key = true;
}

uint32_t EDAMNotFoundException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->identifier);
          this->__isset.identifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EDAMNotFoundException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EDAMNotFoundException");

  if (this->__isset.identifier) {
    xfer += oprot->writeFieldBegin("identifier", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->identifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->key);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EDAMNotFoundException &a, EDAMNotFoundException &b) {
  using ::std::swap;
  swap(a.identifier, b.identifier);
  swap(a.key, b.key);
  swap(a.__isset, b.__isset);
}

EDAMNotFoundException::EDAMNotFoundException(const EDAMNotFoundException& other6) : TException() {
  identifier = other6.identifier;
  key = other6.key;
  __isset = other6.__isset;
}
EDAMNotFoundException& EDAMNotFoundException::operator=(const EDAMNotFoundException& other7) {
  identifier = other7.identifier;
  key = other7.key;
  __isset = other7.__isset;
  return *this;
}
void EDAMNotFoundException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EDAMNotFoundException(";
  out << "identifier="; (__isset.identifier ? (out << to_string(identifier)) : (out << "<null>"));
  out << ", " << "key="; (__isset.key ? (out << to_string(key)) : (out << "<null>"));
  out << ")";
}

const char* EDAMNotFoundException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: EDAMNotFoundException";
  }
}


EDAMInvalidContactsException::~EDAMInvalidContactsException() throw() {
}


void EDAMInvalidContactsException::__set_contacts(const std::vector< ::evernote::edam::Contact> & val) {
  this->contacts = val;
}

void EDAMInvalidContactsException::__set_parameter(const std::string& val) {
  this->parameter = val;
__isset.parameter = true;
}

void EDAMInvalidContactsException::__set_reasons(const std::vector<EDAMInvalidContactReason::type> & val) {
  this->reasons = val;
__isset.reasons = true;
}

uint32_t EDAMInvalidContactsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_contacts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->contacts.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->contacts.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->contacts[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_contacts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parameter);
          this->__isset.parameter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->reasons.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->reasons.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              int32_t ecast18;
              xfer += iprot->readI32(ecast18);
              this->reasons[_i17] = (EDAMInvalidContactReason::type)ecast18;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.reasons = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_contacts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t EDAMInvalidContactsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EDAMInvalidContactsException");

  xfer += oprot->writeFieldBegin("contacts", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->contacts.size()));
    std::vector< ::evernote::edam::Contact> ::const_iterator _iter19;
    for (_iter19 = this->contacts.begin(); _iter19 != this->contacts.end(); ++_iter19)
    {
      xfer += (*_iter19).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.parameter) {
    xfer += oprot->writeFieldBegin("parameter", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->parameter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reasons) {
    xfer += oprot->writeFieldBegin("reasons", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->reasons.size()));
      std::vector<EDAMInvalidContactReason::type> ::const_iterator _iter20;
      for (_iter20 = this->reasons.begin(); _iter20 != this->reasons.end(); ++_iter20)
      {
        xfer += oprot->writeI32((int32_t)(*_iter20));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EDAMInvalidContactsException &a, EDAMInvalidContactsException &b) {
  using ::std::swap;
  swap(a.contacts, b.contacts);
  swap(a.parameter, b.parameter);
  swap(a.reasons, b.reasons);
  swap(a.__isset, b.__isset);
}

EDAMInvalidContactsException::EDAMInvalidContactsException(const EDAMInvalidContactsException& other21) : TException() {
  contacts = other21.contacts;
  parameter = other21.parameter;
  reasons = other21.reasons;
  __isset = other21.__isset;
}
EDAMInvalidContactsException& EDAMInvalidContactsException::operator=(const EDAMInvalidContactsException& other22) {
  contacts = other22.contacts;
  parameter = other22.parameter;
  reasons = other22.reasons;
  __isset = other22.__isset;
  return *this;
}
void EDAMInvalidContactsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EDAMInvalidContactsException(";
  out << "contacts=" << to_string(contacts);
  out << ", " << "parameter="; (__isset.parameter ? (out << to_string(parameter)) : (out << "<null>"));
  out << ", " << "reasons="; (__isset.reasons ? (out << to_string(reasons)) : (out << "<null>"));
  out << ")";
}

const char* EDAMInvalidContactsException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: EDAMInvalidContactsException";
  }
}

}} // namespace
