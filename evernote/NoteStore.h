/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef NoteStore_H
#define NoteStore_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "NoteStore_types.h"

namespace evernote { namespace edam {

#ifdef _WIN32
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class NoteStoreIf {
 public:
  virtual ~NoteStoreIf() {}

  /**
   * Asks the NoteStore to provide information about the status of the user
   * account corresponding to the provided authentication token.
   * 
   * @param authenticationToken
   */
  virtual void getSyncState(SyncState& _return, const std::string& authenticationToken) = 0;

  /**
   * Asks the NoteStore to provide the state of the account in order of
   * last modification.  This request retrieves one block of the server's
   * state so that a client can make several small requests against a large
   * account rather than getting the entire state in one big message.
   * This call gives fine-grained control of the data that will
   * be received by a client by omitting data elements that a client doesn't
   * need. This may reduce network traffic and sync times.
   * 
   * @param afterUSN
   *   The client can pass this value to ask only for objects that
   *   have been updated after a certain point.  This allows the client to
   *   receive updates after its last checkpoint rather than doing a full
   *   synchronization on every pass.  The default value of "0" indicates
   *   that the client wants to get objects from the start of the account.
   * 
   * @param maxEntries
   *   The maximum number of modified objects that should be
   *   returned in the result SyncChunk.  This can be used to limit the size
   *   of each individual message to be friendly for network transfer.
   * 
   * @param filter
   *   The caller must set some of the flags in this structure to specify which
   *   data types should be returned during the synchronization.  See
   *   the SyncChunkFilter structure for information on each flag.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "afterUSN" - if negative
   *   </li>
   *   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param afterUSN
   * @param maxEntries
   * @param filter
   */
  virtual void getFilteredSyncChunk(SyncChunk& _return, const std::string& authenticationToken, const int32_t afterUSN, const int32_t maxEntries, const SyncChunkFilter& filter) = 0;

  /**
   * Asks the NoteStore to provide information about the status of a linked
   * notebook that has been shared with the caller, or that is public to the
   * world.
   * This will return a result that is similar to getSyncState, but may omit
   * SyncState.uploaded if the caller doesn't have permission to write to
   * the linked notebook.
   * 
   * This function must be called on the shard that owns the referenced
   * notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
   * same as LinkedNotebook.shardId.)
   * 
   * @param authenticationToken
   *   This should be an authenticationToken for the guest who has received
   *   the invitation to the share.  (I.e. this should not be the result of
   *   NoteStore.authenticateToSharedNotebook)
   * 
   * @param linkedNotebook
   *   This structure should contain identifying information and permissions
   *   to access the notebook in question.
   * 
   * @throws EDAMUserException <ul>
   *   <li>DATA_REQUIRED "LinkedNotebook.username" - The username field must be
   *       populated with the current username of the owner of the notebook for which
   *       you are obtaining sync state.
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li>"LinkedNotebook.username" - If the LinkedNotebook.username field does not
   *       correspond to a current user on the service.
   *   </li>
   * </ul>
   * 
   * @throws SystemException <ul>
   *   <li>SHARD_UNAVAILABLE - If the provided LinkedNotebook.username corresponds to a
   *       user whose account is on a shard other than that on which this method was
   *       invoked.
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param linkedNotebook
   */
  virtual void getLinkedNotebookSyncState(SyncState& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook) = 0;

  /**
   * Asks the NoteStore to provide information about the contents of a linked
   * notebook that has been shared with the caller, or that is public to the
   * world.
   * This will return a result that is similar to getSyncChunk, but will only
   * contain entries that are visible to the caller.  I.e. only that particular
   * Notebook will be visible, along with its Notes, and Tags on those Notes.
   * 
   * This function must be called on the shard that owns the referenced
   * notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
   * same as LinkedNotebook.shardId.)
   * 
   * @param authenticationToken
   *   This should be an authenticationToken for the guest who has received
   *   the invitation to the share.  (I.e. this should not be the result of
   *   NoteStore.authenticateToSharedNotebook)
   * 
   * @param linkedNotebook
   *   This structure should contain identifying information and permissions
   *   to access the notebook in question.  This must contain the valid fields
   *   for either a shared notebook (e.g. shareKey)
   *   or a public notebook (e.g. username, uri)
   * 
   * @param afterUSN
   *   The client can pass this value to ask only for objects that
   *   have been updated after a certain point.  This allows the client to
   *   receive updates after its last checkpoint rather than doing a full
   *   synchronization on every pass.  The default value of "0" indicates
   *   that the client wants to get objects from the start of the account.
   * 
   * @param maxEntries
   *   The maximum number of modified objects that should be
   *   returned in the result SyncChunk.  This can be used to limit the size
   *   of each individual message to be friendly for network transfer.
   *   Applications should not request more than 256 objects at a time,
   *   and must handle the case where the service returns less than the
   *   requested number of objects in a given request even though more
   *   objects are available on the service.
   * 
   * @param fullSyncOnly
   *   If true, then the client only wants initial data for a full sync.
   *   In this case, the service will not return any expunged objects,
   *   and will not return any Resources, since these are also provided
   *   in their corresponding Notes.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "afterUSN" - if negative
   *   </li>
   *   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "LinkedNotebook" - if the provided information doesn't match any
   *     valid notebook
   *   </li>
   *   <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
   *     valid notebook
   *   </li>
   *   <li> "SharedNotebook.id" - if the provided information indicates a
   *      shared notebook that no longer exists
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param linkedNotebook
   * @param afterUSN
   * @param maxEntries
   * @param fullSyncOnly
   */
  virtual void getLinkedNotebookSyncChunk(SyncChunk& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook, const int32_t afterUSN, const int32_t maxEntries, const bool fullSyncOnly) = 0;

  /**
   * Returns a list of all of the notebooks in the account.
   * 
   * @param authenticationToken
   */
  virtual void listNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const std::string& authenticationToken) = 0;

  /**
   * Returns a list of all the notebooks in a business that the user has permission to access,
   * regardless of whether the user has joined them. This includes notebooks that have been shared
   * with the entire business as well as notebooks that have been shared directly with the user.
   * 
   * @param authenticationToken A business authentication token obtained by calling
   *   UserStore.authenticateToBusiness.
   * 
   * @throws EDAMUserException <ul>
   *   <li> INVALID_AUTH "authenticationToken" - if the authentication token is not a
   *     business auth token.</li>
   * </ul>
   * 
   * @param authenticationToken
   */
  virtual void listAccessibleBusinessNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const std::string& authenticationToken) = 0;

  /**
   * Returns the current state of the notebook with the provided GUID.
   * The notebook may be active or deleted (but not expunged).
   * 
   * @param guid
   *   The GUID of the notebook to be retrieved.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Notebook.guid" - tag not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void getNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Returns the notebook that should be used to store new notes in the
   * user's account when no other notebooks are specified.
   * 
   * @param authenticationToken
   */
  virtual void getDefaultNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken) = 0;

  /**
   * Asks the service to make a notebook with the provided name.
   * 
   * @param notebook
   *   The desired fields for the notebook must be provided on this
   *   object.  The name of the notebook must be set, and either the 'active'
   *   or 'defaultNotebook' fields may be set by the client at creation.
   *   If a notebook exists in the account with the same name (via
   *   case-insensitive compare), this will throw an EDAMUserException.
   * 
   * @return
   *   The newly created Notebook.  The server-side GUID will be
   *   saved in this object's 'guid' field.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
   *   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
   *   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
   *   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
   *   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
   *   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
   *   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
   *   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
   *   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
   *        is set to 'true' for a Notebook that is not owned by the user identified by
   *        the passed authenticationToken.</li>
   *   <li> LIMIT_REACHED "Notebook" - at max number of notebooks</li>
   * </ul>
   * 
   * @param authenticationToken
   * @param notebook
   */
  virtual void createNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook) = 0;

  /**
   * Submits notebook changes to the service.  The provided data must include
   * the notebook's guid field for identification.
   * 
   * @param notebook
   *   The notebook object containing the requested changes.
   * 
   * @return
   *   The Update Sequence Number for this change within the account.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
   *   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
   *   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
   *   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
   *   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
   *   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
   *   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
   *   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
   *   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
   *        is set to 'true' for a Notebook that is not owned by the user identified by
   *        the passed authenticationToken.</li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Notebook.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param notebook
   */
  virtual int32_t updateNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook) = 0;

  /**
   * Permanently removes the notebook from the user's account.
   * After this action, the notebook is no longer available for undeletion, etc.
   * If the notebook contains any Notes, they will be moved to the current
   * default notebook and moved into the trash (i.e. Note.active=false).
   * <p/>
   * NOTE: This function is generally not available to third party applications.
   * Calls will result in an EDAMUserException with the error code
   * PERMISSION_DENIED.
   * 
   * @param guid
   *   The GUID of the notebook to delete.
   * 
   * @return
   *   The Update Sequence Number for this change within the account.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
   *   </li>
   *   <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
   *   </li>
   *   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual int32_t expungeNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Returns a list of the tags in the account.  Evernote does not support
   * the undeletion of tags, so this will only include active tags.
   * 
   * @param authenticationToken
   */
  virtual void listTags(std::vector< ::evernote::edam::Tag> & _return, const std::string& authenticationToken) = 0;

  /**
   * Returns a list of the tags that are applied to at least one note within
   * the provided notebook.  If the notebook is public, the authenticationToken
   * may be ignored.
   * 
   * @param notebookGuid
   *    the GUID of the notebook to use to find tags
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Notebook.guid" - notebook not found by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param notebookGuid
   */
  virtual void listTagsByNotebook(std::vector< ::evernote::edam::Tag> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& notebookGuid) = 0;

  /**
   * Returns the current state of the Tag with the provided GUID.
   * 
   * @param guid
   *   The GUID of the tag to be retrieved.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Tag.guid" - tag not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void getTag( ::evernote::edam::Tag& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Asks the service to make a tag with a set of information.
   * 
   * @param tag
   *   The desired list of fields for the tag are specified in this
   *   object.  The caller must specify the tag name, and may provide
   *   the parentGUID.
   * 
   * @return
   *   The newly created Tag.  The server-side GUID will be
   *   saved in this object.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
   *   </li>
   *   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
   *   </li>
   *   <li> DATA_CONFLICT "Tag.name" - name already in use
   *   </li>
   *   <li> LIMIT_REACHED "Tag" - at max number of tags
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Tag.parentGuid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param tag
   */
  virtual void createTag( ::evernote::edam::Tag& _return, const std::string& authenticationToken, const  ::evernote::edam::Tag& tag) = 0;

  /**
   * Submits tag changes to the service.  The provided data must include
   * the tag's guid field for identification.  The service will apply
   * updates to the following tag fields:  name, parentGuid
   * 
   * @param tag
   *   The tag object containing the requested changes.
   * 
   * @return
   *   The Update Sequence Number for this change within the account.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
   *   </li>
   *   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
   *   </li>
   *   <li> DATA_CONFLICT "Tag.name" - name already in use
   *   </li>
   *   <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
   *   </li>
   *   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Tag.guid" - tag not found, by GUID
   *   </li>
   *   <li> "Tag.parentGuid" - parent not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param tag
   */
  virtual int32_t updateTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag) = 0;

  /**
   * Removes the provided tag from every note that is currently tagged with
   * this tag.  If this operation is successful, the tag will still be in
   * the account, but it will not be tagged on any notes.
   * 
   * This function is not indended for use by full synchronizing clients, since
   * it does not provide enough result information to the client to reconcile
   * the local state without performing a follow-up sync from the service.  This
   * is intended for "thin clients" that need to efficiently support this as
   * a UI operation.
   * 
   * @param guid
   *   The GUID of the tag to remove from all notes.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Tag.guid" - tag not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void untagAll(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Permanently deletes the tag with the provided GUID, if present.
   * <p/>
   * NOTE: This function is not generally available to third party applications.
   * Calls will result in an EDAMUserException with the error code
   * PERMISSION_DENIED.
   * 
   * @param guid
   *   The GUID of the tag to delete.
   * 
   * @return
   *   The Update Sequence Number for this change within the account.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Tag.guid" - tag not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual int32_t expungeTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Returns a list of the searches in the account.  Evernote does not support
   * the undeletion of searches, so this will only include active searches.
   * 
   * @param authenticationToken
   */
  virtual void listSearches(std::vector< ::evernote::edam::SavedSearch> & _return, const std::string& authenticationToken) = 0;

  /**
   * Returns the current state of the search with the provided GUID.
   * 
   * @param guid
   *   The GUID of the search to be retrieved.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
   *   </li>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "SavedSearch.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void getSearch( ::evernote::edam::SavedSearch& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Asks the service to make a saved search with a set of information.
   * 
   * @param search
   *   The desired list of fields for the search are specified in this
   *   object. The caller must specify the name and query for the
   *   search, and may optionally specify a search scope.
   *   The SavedSearch.format field is ignored by the service.
   * 
   * @return
   *   The newly created SavedSearch.  The server-side GUID will be
   *   saved in this object.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
   *   </li>
   *   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
   *   </li>
   *   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
   *   </li>
   *   <li> LIMIT_REACHED "SavedSearch" - at max number of searches
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param search
   */
  virtual void createSearch( ::evernote::edam::SavedSearch& _return, const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search) = 0;

  /**
   * Submits search changes to the service. The provided data must include
   * the search's guid field for identification. The service will apply
   * updates to the following search fields: name, query, and scope.
   * 
   * @param search
   *   The search object containing the requested changes.
   * 
   * @return
   *   The Update Sequence Number for this change within the account.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
   *   </li>
   *   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
   *   </li>
   *   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
   *   </li>
   *   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "SavedSearch.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param search
   */
  virtual int32_t updateSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search) = 0;

  /**
   * Permanently deletes the saved search with the provided GUID, if present.
   * <p/>
   * NOTE: This function is generally not available to third party applications.
   * Calls will result in an EDAMUserException with the error code
   * PERMISSION_DENIED.
   * 
   * @param guid
   *   The GUID of the search to delete.
   * 
   * @return
   *   The Update Sequence Number for this change within the account.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
   *   </li>
   *   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "SavedSearch.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual int32_t expungeSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Finds the position of a note within a sorted subset of all of the user's
   * notes. This may be useful for thin clients that are displaying a paginated
   * listing of a large account, which need to know where a particular note
   * sits in the list without retrieving all notes first.
   * 
   * @param authenticationToken
   *   Must be a valid token for the user's account unless the NoteFilter
   *   'notebookGuid' is the GUID of a public notebook.
   * 
   * @param filter
   *   The list of criteria that will constrain the notes to be returned.
   * 
   * @param guid
   *   The GUID of the note to be retrieved.
   * 
   * @return
   *   If the note with the provided GUID is found within the matching note
   *   list, this will return the offset of that note within that list (where
   *   the first offset is 0).  If the note is not found within the set of
   *   notes, this will return -1.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
   *   </li>
   *   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
   *   </li>
   *   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
   *   </li>
   *   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
   *   </li>
   *   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
   *   </li>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Notebook.guid" - not found, by GUID
   *   </li>
   *   <li> "Note.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param filter
   * @param guid
   */
  virtual int32_t findNoteOffset(const std::string& authenticationToken, const NoteFilter& filter, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Used to find the high-level information about a set of the notes from a
   * user's account based on various criteria specified via a NoteFilter object.
   * <p/>
   * Web applications that wish to periodically check for new content in a user's
   * Evernote account should consider using webhooks instead of polling this API.
   * See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
   * for more information.
   * 
   * @param authenticationToken
   *   Must be a valid token for the user's account unless the NoteFilter
   *   'notebookGuid' is the GUID of a public notebook.
   * 
   * @param filter
   *   The list of criteria that will constrain the notes to be returned.
   * 
   * @param offset
   *   The numeric index of the first note to show within the sorted
   *   results.  The numbering scheme starts with "0".  This can be used for
   *   pagination.
   * 
   * @param maxNotes
   *   The maximum notes to return in this query.  The service will return a set
   *   of notes that is no larger than this number, but may return fewer notes
   *   if needed.  The NoteList.totalNotes field in the return value will
   *   indicate whether there are more values available after the returned set.
   *   Currently, the service will not return more than 250 notes in a single request,
   *   but this number may change in the future.
   * 
   * @param resultSpec
   *   This specifies which information should be returned for each matching
   *   Note. The fields on this structure can be used to eliminate data that
   *   the client doesn't need, which will reduce the time and bandwidth
   *   to receive and process the reply.
   * 
   * @return
   *   The list of notes that match the criteria.
   *   The Notes.sharedNotes field will not be set.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
   *   </li>
   *   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
   *   </li>
   *   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
   *   </li>
   *   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
   *   </li>
   *   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Notebook.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param filter
   * @param offset
   * @param maxNotes
   * @param resultSpec
   */
  virtual void findNotesMetadata(NotesMetadataList& _return, const std::string& authenticationToken, const NoteFilter& filter, const int32_t offset, const int32_t maxNotes, const NotesMetadataResultSpec& resultSpec) = 0;

  /**
   * This function is used to determine how many notes are found for each
   * notebook and tag in the user's account, given a current set of filter
   * parameters that determine the current selection.  This function will
   * return a structure that gives the note count for each notebook and tag
   * that has at least one note under the requested filter.  Any notebook or
   * tag that has zero notes in the filtered set will not be listed in the
   * reply to this function (so they can be assumed to be 0).
   * 
   * @param authenticationToken
   *   Must be a valid token for the user's account unless the NoteFilter
   *   'notebookGuid' is the GUID of a public notebook.
   * 
   * @param filter
   *   The note selection filter that is currently being applied.  The note
   *   counts are to be calculated with this filter applied to the total set
   *   of notes in the user's account.
   * 
   * @param withTrash
   *   If true, then the NoteCollectionCounts.trashCount will be calculated
   *   and supplied in the reply. Otherwise, the trash value will be omitted.
   * 
   * @throws EDAMUserException <ul>
   *   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed</li>
   *   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed</li>
   *   <li>BAD_DATA_FORMAT "NoteFilter.words" - if search string too long</li>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Notebook.guid" - not found, by GUID</li>
   * </ul>
   * 
   * @param authenticationToken
   * @param filter
   * @param withTrash
   */
  virtual void findNoteCounts(NoteCollectionCounts& _return, const std::string& authenticationToken, const NoteFilter& filter, const bool withTrash) = 0;

  /**
   * Returns the current state of the note in the service with the provided
   * GUID.  The ENML contents of the note will only be provided if the
   * 'withContent' parameter is true.  The service will include the meta-data
   * for each resource in the note, but the binary contents of the resources
   * and their recognition data will be omitted.
   * If the Note is found in a public notebook, the authenticationToken
   * will be ignored (so it could be an empty string).  The applicationData
   * fields are returned as keysOnly.
   * 
   * @param authenticationToken
   *   An authentication token that grants the caller access to the requested note.
   * 
   * @param guid
   *   The GUID of the note to be retrieved.
   * 
   * @param resultSpec
   *   A structure specifying the fields of the note that the caller would like to get.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   * @param resultSpec
   */
  virtual void getNoteWithResultSpec( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const NoteResultSpec& resultSpec) = 0;

  /**
   * DEPRECATED. See getNoteWithResultSpec.
   * 
   * This function is equivalent to getNoteWithResultSpec, with each of the boolean parameters
   * mapping to the equivalent field of a NoteResultSpec. The Note.sharedNotes field is never
   * populated on the returned note. To get a note with its shares, use getNoteWithResultSpec.
   * 
   * @param authenticationToken
   * @param guid
   * @param withContent
   * @param withResourcesData
   * @param withResourcesRecognition
   * @param withResourcesAlternateData
   */
  virtual void getNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withContent, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData) = 0;

  /**
   * Get all of the application data for the note identified by GUID,
   * with values returned within the LazyMap fullMap field.
   * If there are no applicationData entries, then a LazyMap
   * with an empty fullMap will be returned. If your application
   * only needs to fetch its own applicationData entry, use
   * getNoteApplicationDataEntry instead.
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void getNoteApplicationData( ::evernote::edam::LazyMap& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Get the value of a single entry in the applicationData map
   * for the note identified by GUID.
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note.guid" - note not found, by GUID</li>
   *   <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   * @param key
   */
  virtual void getNoteApplicationDataEntry(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key) = 0;

  /**
   * Update, or create, an entry in the applicationData map for
   * the note identified by guid.
   * 
   * @param authenticationToken
   * @param guid
   * @param key
   * @param value
   */
  virtual int32_t setNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value) = 0;

  /**
   * Remove an entry identified by 'key' from the applicationData map for
   * the note identified by 'guid'. Silently ignores an unset of a
   * non-existing key.
   * 
   * @param authenticationToken
   * @param guid
   * @param key
   */
  virtual int32_t unsetNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key) = 0;

  /**
   * Returns XHTML contents of the note with the provided GUID.
   * If the Note is found in a public notebook, the authenticationToken
   * will be ignored (so it could be an empty string).
   * 
   * @param guid
   *   The GUID of the note to be retrieved.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void getNoteContent(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Returns a block of the extracted plain text contents of the note with the
   * provided GUID.  This text can be indexed for search purposes by a light
   * client that doesn't have capabilities to extract all of the searchable
   * text content from the note and its resources.
   * 
   * If the Note is found in a public notebook, the authenticationToken
   * will be ignored (so it could be an empty string).
   * 
   * @param guid
   *   The GUID of the note to be retrieved.
   * 
   * @param noteOnly
   *   If true, this will only return the text extracted from the ENML contents
   *   of the note itself.  If false, this will also include the extracted text
   *   from any text-bearing resources (PDF, recognized images)
   * 
   * @param tokenizeForIndexing
   *   If true, this will break the text into cleanly separated and sanitized
   *   tokens.  If false, this will return the more raw text extraction, with
   *   its original punctuation, capitalization, spacing, etc.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   * @param noteOnly
   * @param tokenizeForIndexing
   */
  virtual void getNoteSearchText(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool noteOnly, const bool tokenizeForIndexing) = 0;

  /**
   * Returns a block of the extracted plain text contents of the resource with
   * the provided GUID.  This text can be indexed for search purposes by a light
   * client that doesn't have capability to extract all of the searchable
   * text content from a resource.
   * 
   * If the Resource is found in a public notebook, the authenticationToken
   * will be ignored (so it could be an empty string).
   * 
   * @param guid
   *   The GUID of the resource to be retrieved.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Resource.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void getResourceSearchText(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Returns a list of the names of the tags for the note with the provided
   * guid.  This can be used with authentication to get the tags for a
   * user's own note, or can be used without valid authentication to retrieve
   * the names of the tags for a note in a public notebook.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void getNoteTagNames(std::vector<std::string> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Asks the service to make a note with the provided set of information.
   * 
   * @param note
   *   A Note object containing the desired fields to be populated on
   *   the service.
   * 
   * @return
   *   The newly created Note from the service.  The server-side
   *   GUIDs for the Note and any Resources will be saved in this object.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
   *   </li>
   *   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
   *   </li>
   *   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
   *   </li>
   *   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
   *   </li>
   *   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
   *   </li>
   *   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
   *   </li>
   *   <li> DATA_REQUIRED "Resource.data" - resource data body missing
   *   </li>
   *   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
   *   </li>
   *   <li> LIMIT_REACHED "Note" - at max number per account
   *   </li>
   *   <li> LIMIT_REACHED "Note.size" - total note size too large
   *   </li>
   *   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
   *   </li>
   *   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
   *   </li>
   *   <li> LIMIT_REACHED "Resource.data.size" - resource too large
   *   </li>
   *   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
   *   </li>
   *   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
   *   </li>
   *   <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
   *   </li>
   *   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
   *   </li>
   *   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
   *     of the specified tags had an invalid length or pattern
   *   </li>
   *   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
   *     new tags would exceed the maximum number per account
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note.notebookGuid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param note
   */
  virtual void createNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note) = 0;

  /**
   * Submit a set of changes to a note to the service.  The provided data
   * must include the note's guid field for identification. The note's
   * title must also be set.
   * 
   * @param note
   *   A Note object containing the desired fields to be populated on
   *   the service. With the exception of the note's title and guid, fields
   *   that are not being changed do not need to be set. If the content is not
   *   being modified, note.content should be left unset. If the list of
   *   resources is not being modified, note.resources should be left unset.
   * 
   * @return
   *   The metadata (no contents) for the Note on the server after the update.
   *   The Note.sharedNotes field will not be set.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
   *   </li>
   *   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
   *   </li>
   *   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
   *   </li>
   *   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
   *   </li>
   *   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
   *   </li>
   *   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
   *   </li>
   *   <li> DATA_REQUIRED "Resource.data" - resource data body missing
   *   </li>
   *   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
   *   </li>
   *   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
   *   </li>
   *   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
   *   </li>
   *   <li> LIMIT_REACHED "Note.size" - total note size too large
   *   </li>
   *   <li> LIMIT_REACHED "Resource.data.size" - resource too large
   *   </li>
   *   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
   *   </li>
   *   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
   *   </li>
   *   <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
   *   <li> PERMISSION_DENIED "Note.tags" - user doesn't have permission to
   *     modify the note's tags. note.tags must be unset.
   *   </li>
   *   <li> PERMISSION_DENIED "Note.attributes" - user doesn't have permission
   *     to modify the note's attributes. note.attributes must be unset.
   *   </li>
   *   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
   *   </li>
   *   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
   *     of the specified tags had an invalid length or pattern
   *   </li>
   *   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
   *     new tags would exceed the maximum number per account
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note.guid" - note not found, by GUID
   *   </li>
   *   <li> "Note.notebookGuid" - if notebookGuid provided, but not found
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param note
   */
  virtual void updateNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note) = 0;

  /**
   * Moves the note into the trash. The note may still be undeleted, unless it
   * is expunged.  This is equivalent to calling updateNote() after setting
   * Note.active = false
   * 
   * @param guid
   *   The GUID of the note to delete.
   * 
   * @return
   *   The Update Sequence Number for this change within the account.
   * 
   * @throws EDAMUserException <ul>
   *   <li> PERMISSION_DENIED "Note" - user doesn't have permission to
   *          update the note.
   *   </li>
   * </ul>
   * 
   * @throws EDAMUserException <ul>
   *   <li> DATA_CONFLICT "Note.guid" - the note is already deleted
   *   </li>
   * </ul>
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual int32_t deleteNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Permanently removes a Note, and all of its Resources,
   * from the service.
   * <p/>
   * NOTE: This function is not available to third party applications.
   * Calls will result in an EDAMUserException with the error code
   * PERMISSION_DENIED.
   * 
   * @param guid
   *   The GUID of the note to delete.
   * 
   * @return
   *   The Update Sequence Number for this change within the account.
   * 
   * @throws EDAMUserException <ul>
   *   <li> PERMISSION_DENIED "Note" - user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual int32_t expungeNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Performs a deep copy of the Note with the provided GUID 'noteGuid' into
   * the Notebook with the provided GUID 'toNotebookGuid'.
   * The caller must be the owner of both the Note and the Notebook.
   * This creates a new Note in the destination Notebook with new content and
   * Resources that match all of the content and Resources from the original
   * Note, but with new GUID identifiers.
   * The original Note is not modified by this operation.
   * The copied note is considered as an "upload" for the purpose of upload
   * transfer limit calculation, so its size is added to the upload count for
   * the owner.
   * 
   * If the original note has been shared and has SharedNote records, the shares
   * are NOT copied.
   * 
   * @param noteGuid
   *   The GUID of the Note to copy.
   * 
   * @param toNotebookGuid
   *   The GUID of the Notebook that should receive the new Note.
   * 
   * @return
   *   The metadata for the new Note that was created.  This will include the
   *   new GUID for this Note (and any copied Resources), but will not include
   *   the content body or the binary bodies of any Resources.
   * 
   * @throws EDAMUserException <ul>
   *   <li> LIMIT_REACHED "Note" - at max number per account
   *   </li>
   *   <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
   *   </li>
   *   <li> PERMISSION_DENIED "Note" - user doesn't own
   *   </li>
   *   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Notebook.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param noteGuid
   * @param toNotebookGuid
   */
  virtual void copyNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const  ::evernote::edam::Guid& toNotebookGuid) = 0;

  /**
   * Returns a list of the prior versions of a particular note that are
   * saved within the service.  These prior versions are stored to provide a
   * recovery from unintentional removal of content from a note. The identifiers
   * that are returned by this call can be used with getNoteVersion to retrieve
   * the previous note.
   * The identifiers will be listed from the most recent versions to the oldest.
   * This call is only available for notes in Premium accounts. (I.e. access
   * to past versions of Notes is a Premium-only feature.)
   * 
   * @throws EDAMUserException <ul>
   *   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
   *   </li>
   *   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note.guid" - not found, by GUID.
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param noteGuid
   */
  virtual void listNoteVersions(std::vector<NoteVersionId> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid) = 0;

  /**
   * This can be used to retrieve a previous version of a Note after it has been
   * updated within the service.  The caller must identify the note (via its
   * guid) and the version (via the updateSequenceNumber of that version).
   * to find a listing of the stored version USNs for a note, call
   * listNoteVersions.
   * This call is only available for notes in Premium accounts. (I.e. access
   * to past versions of Notes is a Premium-only feature.)
   * 
   * @param noteGuid
   *   The GUID of the note to be retrieved.
   * 
   * @param updateSequenceNum
   *   The USN of the version of the note that is being retrieved
   * 
   * @param withResourcesData
   *   If true, any Resource elements in this Note will include the binary
   *   contents of their 'data' field's body.
   * 
   * @param withResourcesRecognition
   *   If true, any Resource elements will include the binary contents of the
   *   'recognition' field's body if recognition data is present.
   * 
   * @param withResourcesAlternateData
   *   If true, any Resource elements in this Note will include the binary
   *   contents of their 'alternateData' fields' body, if an alternate form
   *   is present.
   * 
   * @throws EDAMUserException <ul>
   *   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
   *   </li>
   *   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note.guid" - not found, by GUID.
   *   </li>
   *   <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
   *      the corresponding USN.
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param noteGuid
   * @param updateSequenceNum
   * @param withResourcesData
   * @param withResourcesRecognition
   * @param withResourcesAlternateData
   */
  virtual void getNoteVersion( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const int32_t updateSequenceNum, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData) = 0;

  /**
   * Returns the current state of the resource in the service with the
   * provided GUID.
   * If the Resource is found in a public notebook, the authenticationToken
   * will be ignored (so it could be an empty string).  Only the
   * keys for the applicationData will be returned.
   * 
   * @param guid
   *   The GUID of the resource to be retrieved.
   * 
   * @param withData
   *   If true, the Resource will include the binary contents of the
   *   'data' field's body.
   * 
   * @param withRecognition
   *   If true, the Resource will include the binary contents of the
   *   'recognition' field's body if recognition data is present.
   * 
   * @param withAttributes
   *   If true, the Resource will include the attributes
   * 
   * @param withAlternateData
   *   If true, the Resource will include the binary contents of the
   *   'alternateData' field's body, if an alternate form is present.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Resource.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   * @param withData
   * @param withRecognition
   * @param withAttributes
   * @param withAlternateData
   */
  virtual void getResource( ::evernote::edam::Resource& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withData, const bool withRecognition, const bool withAttributes, const bool withAlternateData) = 0;

  /**
   * Get all of the application data for the Resource identified by GUID,
   * with values returned within the LazyMap fullMap field.
   * If there are no applicationData entries, then a LazyMap
   * with an empty fullMap will be returned. If your application
   * only needs to fetch its own applicationData entry, use
   * getResourceApplicationDataEntry instead.
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void getResourceApplicationData( ::evernote::edam::LazyMap& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Get the value of a single entry in the applicationData map
   * for the Resource identified by GUID.
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Resource.guid" - Resource not found, by GUID</li>
   *   <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   * @param key
   */
  virtual void getResourceApplicationDataEntry(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key) = 0;

  /**
   * Update, or create, an entry in the applicationData map for
   * the Resource identified by guid.
   * 
   * @param authenticationToken
   * @param guid
   * @param key
   * @param value
   */
  virtual int32_t setResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value) = 0;

  /**
   * Remove an entry identified by 'key' from the applicationData map for
   * the Resource identified by 'guid'.
   * 
   * @param authenticationToken
   * @param guid
   * @param key
   */
  virtual int32_t unsetResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key) = 0;

  /**
   * Submit a set of changes to a resource to the service.  This can be used
   * to update the meta-data about the resource, but cannot be used to change
   * the binary contents of the resource (including the length and hash).  These
   * cannot be changed directly without creating a new resource and removing the
   * old one via updateNote.
   * 
   * @param resource
   *   A Resource object containing the desired fields to be populated on
   *   the service.  The service will attempt to update the resource with the
   *   following fields from the client:
   *   <ul>
   *      <li>guid:  must be provided to identify the resource
   *      </li>
   *      <li>mime
   *      </li>
   *      <li>width
   *      </li>
   *      <li>height
   *      </li>
   *      <li>duration
   *      </li>
   *      <li>attributes:  optional.  if present, the set of attributes will
   *           be replaced.
   *      </li>
   *   </ul>
   * 
   * @return
   *   The Update Sequence Number of the resource after the changes have been
   *   applied.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
   *   </li>
   *   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
   *   </li>
   *   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
   *   </li>
   *   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
   *   </li>
   *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Resource.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param resource
   */
  virtual int32_t updateResource(const std::string& authenticationToken, const  ::evernote::edam::Resource& resource) = 0;

  /**
   * Returns binary data of the resource with the provided GUID.  For
   * example, if this were an image resource, this would contain the
   * raw bits of the image.
   * If the Resource is found in a public notebook, the authenticationToken
   * will be ignored (so it could be an empty string).
   * 
   * @param guid
   *   The GUID of the resource to be retrieved.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Resource.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void getResourceData(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Returns the current state of a resource, referenced by containing
   * note GUID and resource content hash.
   * 
   * @param noteGuid
   *   The GUID of the note that holds the resource to be retrieved.
   * 
   * @param contentHash
   *   The MD5 checksum of the resource within that note. Note that
   *   this is the binary checksum, for example from Resource.data.bodyHash,
   *   and not the hex-encoded checksum that is used within an en-media
   *   tag in a note body.
   * 
   * @param withData
   *   If true, the Resource will include the binary contents of the
   *   'data' field's body.
   * 
   * @param withRecognition
   *   If true, the Resource will include the binary contents of the
   *   'recognition' field's body.
   * 
   * @param withAlternateData
   *   If true, the Resource will include the binary contents of the
   *   'alternateData' field's body, if an alternate form is present.
   * 
   * @throws EDAMUserException <ul>
   *   <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
   *   </li>
   *   <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
   *   </li>
   *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note" - not found, by guid
   *   </li>
   *   <li> "Resource" - not found, by hash
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param noteGuid
   * @param contentHash
   * @param withData
   * @param withRecognition
   * @param withAlternateData
   */
  virtual void getResourceByHash( ::evernote::edam::Resource& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const std::string& contentHash, const bool withData, const bool withRecognition, const bool withAlternateData) = 0;

  /**
   * Returns the binary contents of the recognition index for the resource
   * with the provided GUID.  If the caller asks about a resource that has
   * no recognition data, this will throw EDAMNotFoundException.
   * If the Resource is found in a public notebook, the authenticationToken
   * will be ignored (so it could be an empty string).
   * 
   * @param guid
   *   The GUID of the resource whose recognition data should be retrieved.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Resource.guid" - not found, by GUID
   *   </li>
   *   <li> "Resource.recognition" - resource has no recognition
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void getResourceRecognition(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * If the Resource with the provided GUID has an alternate data representation
   * (indicated via the Resource.alternateData field), then this request can
   * be used to retrieve the binary contents of that alternate data file.
   * If the caller asks about a resource that has no alternate data form, this
   * will throw EDAMNotFoundException.
   * 
   * @param guid
   *    The GUID of the resource whose recognition data should be retrieved.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Resource.guid" - not found, by GUID
   *   </li>
   *   <li> "Resource.alternateData" - resource has no recognition
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void getResourceAlternateData(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Returns the set of attributes for the Resource with the provided GUID.
   * If the Resource is found in a public notebook, the authenticationToken
   * will be ignored (so it could be an empty string).
   * 
   * @param guid
   *   The GUID of the resource whose attributes should be retrieved.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
   *   </li>
   *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Resource.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void getResourceAttributes( ::evernote::edam::ResourceAttributes& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * <p>
   * Looks for a user account with the provided userId on this NoteStore
   * shard and determines whether that account contains a public notebook
   * with the given URI.  If the account is not found, or no public notebook
   * exists with this URI, this will throw an EDAMNotFoundException,
   * otherwise this will return the information for that Notebook.
   * </p>
   * <p>
   * If a notebook is visible on the web with a full URL like
   * http://www.evernote.com/pub/sethdemo/api
   * Then 'sethdemo' is the username that can be used to look up the userId,
   * and 'api' is the publicUri.
   * </p>
   * 
   * @param userId
   *    The numeric identifier for the user who owns the public notebook.
   *    To find this value based on a username string, you can invoke
   *    UserStore.getPublicUserInfo
   * 
   * @param publicUri
   *    The uri string for the public notebook, from Notebook.publishing.uri.
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li>"Publishing.uri" - not found, by URI</li>
   * </ul>
   * 
   * @throws EDAMSystemException <ul>
   *   <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
   *     taken down (for all requesters).</li>
   *   <li> TAKEN_DOWN "Country" - The specified public notebook is taken
   *     down for the requester because of an IP-based country lookup.</li>
   * </ul>
   * 
   * @param userId
   * @param publicUri
   */
  virtual void getPublicNotebook( ::evernote::edam::Notebook& _return, const  ::evernote::edam::UserID userId, const std::string& publicUri) = 0;

  /**
   * @Deprecated for first-party clients. See createOrUpdateNotebookShares.
   * 
   * Share a notebook with an email address, and optionally to a specific
   * recipient. If an existing SharedNotebook associated with
   * sharedNotebook.notebookGuid is found by recipientUsername or email, then
   * the values of sharedNotebook will be used to update the existing record,
   * else a new record will be created.
   * 
   * If recipientUsername is set and there is already a SharedNotebook
   * for that Notebook with that recipientUsername and the privileges on the
   * existing notebook are lower, than on this one, this will update the
   * privileges and sharerUserId. If there isn't an existing SharedNotebook for
   * recipientUsername, this will create and return a shared notebook for that
   * email and recipientUsername. If recipientUsername is not set and there
   * already is a SharedNotebook for a Notebook for that email address and the
   * privileges on the existing SharedNotebook are lower than on this one, this
   * will update the privileges and sharerUserId, and return the updated
   * SharedNotebook. Otherwise, this will create and return a SharedNotebook for
   * the email address.
   * 
   * If the authenticationToken is a Business auth token, recipientUsername is
   * set and the recipient is in the same business as the business auth token,
   * this method will also auto-join the business user to the SharedNotebook -
   * that is it will set serviceJoined on the SharedNotebook and create a
   * LinkedNotebook on the recipient's account pointing to the SharedNotebook.
   * The LinkedNotebook creation happens out-of-band, so there will be a delay
   * on the order of half a minute between the SharedNotebook and LinkedNotebook
   * creation.
   * 
   * Also handles sending an email to the email addresses: if a SharedNotebook
   * is being created, this will send the shared notebook invite email, and
   * if a SharedNotebook already exists, it will send the shared notebook
   * reminder email. Both these emails contain a link to join the notebook.
   * If the notebook is being auto-joined, it sends an email with that
   * information to the recipient.
   * 
   * @param authenticationToken
   *   Must be an authentication token from the owner or a shared notebook
   *   authentication token or business authentication token with sufficient
   *   permissions to change invitations for a notebook.
   * 
   * @param sharedNotebook
   *   A shared notebook object populated with the email address of the share
   *   recipient, the notebook guid and the access permissions. All other
   *   attributes of the shared object are ignored. The SharedNotebook.allowPreview
   *   field must be explicitly set with either a true or false value.
   * 
   * @param message
   *   The sharer-defined message to put in the email sent out.
   * 
   * @return
   *   The fully populated SharedNotebook object including the server assigned
   *   globalId which can both be used to uniquely identify the SharedNotebook.
   * 
   * @throws EDAMUserException <ul>
   *   <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
   *   <li>DATA_REQUIRED "SharedNotebook.privilege" - if the
   *       SharedNotebook.privilegeLevel was not set.</li>
   *   <li>BAD_DATA_FORMAT "SharedNotebook.requireLogin" - if requireLogin was
   *       set. requireLogin is deprecated.</li>
   *   <li>BAD_DATA_FORMAT "SharedNotebook.privilegeLevel" - if the
   *       SharedNotebook.privilegeLevel field was unset or set to GROUP.</li>
   *   <li>PERMISSION_DENIED "emailConfirmation" - if the email address on the
   *       authenticationToken's owner's account is not confirmed.</li>
   *   <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
   *       recipientSettings is set in the sharedNotebook.  Only the recipient
   *       can set these values via the setSharedNotebookRecipientSettings
   *       method.</li>
   *   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - The notebook already has
   *       EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX shares.</li>
   *   </ul>
   * @throws EDAMNotFoundException <ul>
   *   <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
   *   </li>
   *   </ul>
   * 
   * @param authenticationToken
   * @param sharedNotebook
   * @param message
   */
  virtual void shareNotebook( ::evernote::edam::SharedNotebook& _return, const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook, const std::string& message) = 0;

  /**
   * Share a notebook by a messaging thread ID or a list of contacts. This function is
   * intended to be used in conjunction with Evernote messaging, and as such does not
   * notify the recipient that a notebook has been shared with them.
   * 
   * Sharing with a subset of participants on a thread is accomplished by specifying both
   * a thread ID and a list of contacts. This ensures that even if those contacts are
   * on the thread under a deactivated identity, the correct user (the one who has the
   * given contact on the thread) receives the share.
   * 
   * @param authenticationToken
   *   An authentication token that grants the caller permission to share the notebook.
   *   This should be an owner token if the notebook is owned by the caller.
   *   If the notebook is a business notebook to which the caller has full access,
   *   this should be their business authentication token. If the notebook is a shared
   *   (non-business) notebook to which the caller has full access, this should be the
   *   shared notebook authentication token returned by NoteStore.authenticateToNotebook.
   * 
   * @param shareTemplate
   *   Specifies the GUID of the notebook to be shared, the privilege at which the notebook
   *   should be shared, and the recipient information.
   * 
   * @return
   *   A structure containing the USN of the Notebook after the change and a list of created
   *   or updated SharedNotebooks.
   * 
   * @throws EDAMUserException <ul>
   *   <li>DATA_REQUIRED "Notebook.guid" - if no notebook GUID was specified</li>
   *   <li>BAD_DATA_FORMAT "Notebook.guid" - if shareTemplate.notebookGuid is not a
   *     valid GUID</li>
   *   <li>DATA_REQUIRED "shareTemplate" - if the shareTemplate parameter was missing</li>
   *   <li>DATA_REQUIRED "NotebookShareTemplate.privilege" - if no privilege was
   *     specified</li>
   *   <li>DATA_CONFLICT "NotebookShareTemplate.privilege" - if the specified privilege
   *     is not allowed.</li>
   *   <li>DATA_REQUIRED "NotebookShareTemplate.recipients" - if no recipients were
   *     specified, either by thread ID or as a list of contacts</li>
   *   <li>LIMIT_REACHED "SharedNotebook" - if the notebook has reached its maximum
   *     number of shares</li>
   * </ul>
   * 
   * @throws EDAMInvalidContactsException <ul>
   *   <li>"NotebookShareTemplate.recipients" - if one or more of the recipients specified
   *     in shareTemplate.recipients was not syntactically valid, or if attempting to
   *     share a notebook with an Evernote identity that the sharer does not have a
   *     connection to. The exception will specify which recipients were invalid.</li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li>"Notebook.guid" - if no notebook with the specified GUID was found</li>
   *   <li>"NotebookShareTemplate.recipientThreadId" - if the recipient thread ID was
   *     specified, but no thread with that ID exists</li>
   * </ul>
   * 
   * @param authenticationToken
   * @param shareTemplate
   */
  virtual void createOrUpdateNotebookShares(CreateOrUpdateNotebookSharesResult& _return, const std::string& authenticationToken, const NotebookShareTemplate& shareTemplate) = 0;

  /**
   * @Deprecated See createOrUpdateNotebookShares and manageNotebookShares.
   * 
   * @param authenticationToken
   * @param sharedNotebook
   */
  virtual int32_t updateSharedNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook) = 0;

  /**
   * Set values for the recipient settings associated with a notebook share. Only the
   * recipient of the share can update their recipient settings.
   * 
   * If you do <i>not</i> wish to, or cannot, change one of the recipient settings fields,
   * you must leave that field unset in recipientSettings.
   * This method will skip that field for updates and attempt to leave the existing value as
   * it is.
   * 
   * If recipientSettings.inMyList is false, both reminderNotifyInApp and reminderNotifyEmail
   * will be either left as null or converted to false (if currently true).
   * 
   * @param authenticationToken The owner authentication token for the recipient of the share.
   * 
   * @return The updated Notebook with the new recipient settings. Note that some of the
   * recipient settings may differ from what was requested. Clients should update their state
   * based on this return value.
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li>Notebook.guid - Thrown if the service does not have a notebook record with the
   *       notebookGuid on the given shard.</li>
   *   <li>Publishing.publishState - Thrown if the business notebook is not shared with the
   *       user and is also not published to their business.</li>
   * </ul>
   * 
   * @throws EDAMUserException <ul>
   *   <li>PEMISSION_DENIED "authenticationToken" - If the owner of the given token is not
   *       allowed to set recipient settings on the specified notebook.</li>
   *   <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting reminderNotifyEmail
   *       is allowed only for notebooks which belong to the same business as the user.</li>
   *   <li>DATA_CONFLICT "recipientSettings.inMyList" - If the request is setting inMyList
   *       to false and any of reminder* settings to true.</li>
   * </ul>
   * 
   * @param authenticationToken
   * @param notebookGuid
   * @param recipientSettings
   */
  virtual void setNotebookRecipientSettings( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const std::string& notebookGuid, const  ::evernote::edam::NotebookRecipientSettings& recipientSettings) = 0;

  /**
   * Lists the collection of shared notebooks for all notebooks in the
   * users account.
   * 
   * @return
   *  The list of all SharedNotebooks for the user
   * 
   * @param authenticationToken
   */
  virtual void listSharedNotebooks(std::vector< ::evernote::edam::SharedNotebook> & _return, const std::string& authenticationToken) = 0;

  /**
   * Asks the service to make a linked notebook with the provided name, username
   * of the owner and identifiers provided. A linked notebook can be either a
   * link to a public notebook or to a private shared notebook.
   * 
   * @param linkedNotebook
   *   The desired fields for the linked notebook must be provided on this
   *   object.  The name of the linked notebook must be set. Either a username
   *   uri or a shard id and share key must be provided otherwise a
   *   EDAMUserException is thrown.
   * 
   * @return
   *   The newly created LinkedNotebook.  The server-side id will be
   *   saved in this object's 'id' field.
   * 
   * @throws EDAMUserException <ul>
   *   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
   *   <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid shareName length or pattern
   *   </li>
   *   <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
   *   </li>
   *   <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
   *     if public notebook set but bad uri
   *   </li>
   *   <li> DATA_REQUIRED "LinkedNotebook.shardId" -
   *     if private notebook but shard id not provided
   *   </li>
   *   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
   *   </li>
   * </ul>
   * 
   * @throws EDAMSystemException <ul>
   *   <li> BAD_DATA_FORMAT "LinkedNotebook.sharedNotebookGlobalId" -
   *     if a bad global identifer was set on a private notebook
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param linkedNotebook
   */
  virtual void createLinkedNotebook( ::evernote::edam::LinkedNotebook& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook) = 0;

  /**
   * @param linkedNotebook
   *   Updates the name of a linked notebook.
   * 
   * @return
   *   The Update Sequence Number for this change within the account.
   * 
   * @throws EDAMUserException <ul>
   *   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
   *   </li>
   *   <li> BAD_DATA_FORMAT "LinkedNotebook.shareName" - invalid shareName length or pattern
   *   </li>
   *   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param linkedNotebook
   */
  virtual int32_t updateLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook) = 0;

  /**
   * Returns a list of linked notebooks
   * 
   * @param authenticationToken
   */
  virtual void listLinkedNotebooks(std::vector< ::evernote::edam::LinkedNotebook> & _return, const std::string& authenticationToken) = 0;

  /**
   * Permanently expunges the linked notebook from the account.
   * <p/>
   * NOTE: This function is generally not available to third party applications.
   * Calls will result in an EDAMUserException with the error code
   * PERMISSION_DENIED.
   * 
   * @param guid
   *   The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
   *   from the account.
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual int32_t expungeLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Asks the service to produce an authentication token that can be used to
   * access the contents of a shared notebook from someone else's account.
   * This authenticationToken can be used with the various other NoteStore
   * calls to find and retrieve notes, and if the permissions in the shared
   * notebook are sufficient, to make changes to the contents of the notebook.
   * 
   * @param shareKeyOrGlobalId
   *   May be one of the following:
   *   <ul>
   *     <li>A share key for a shared notebook that was granted to some recipient
   *         Must be used if you are joining a notebook unless it was shared via
   *         createOrUpdateNotebookShares. Share keys are delivered out-of-band
   *         and are generally not available to clients. For security reasons,
   *         share keys may be invalidated at the discretion of the service.
   *     </li>
   *     <li>The shared notebook global identifier. May be used to access a
   *         notebook that is already joined.
   *     </li>
   *     <li>The Notebook GUID. May be used to access a notebook that was already
   *         joined, or to access a notebook that was shared with the recipient
   *         via createOrUpdateNotebookShares.
   *     </li>
   *   </ul>
   * 
   * @param authenticationToken
   *   If a non-empty string is provided, this is the full user-based
   *   authentication token that identifies the user who is currently logged in
   *   and trying to access the shared notebook.
   *   If this string is empty, the service will attempt to authenticate to the
   *   shared notebook without any logged in user.
   * 
   * @throws EDAMSystemException <ul>
   *   <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string</li>
   *   <li> INVALID_AUTH "shareKey" - bad signature on shareKey string</li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "SharedNotebook.id" - the shared notebook no longer exists</li>
   * </ul>
   * 
   * @throws EDAMUserException <ul>
   *   <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
   *          no valid authentication token was provided.
   *   </li>
   *   <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
   *          and another username has already been bound to this notebook.
   *   </li>
   * </ul>
   * 
   * @param shareKeyOrGlobalId
   * @param authenticationToken
   */
  virtual void authenticateToSharedNotebook( ::evernote::edam::AuthenticationResult& _return, const std::string& shareKeyOrGlobalId, const std::string& authenticationToken) = 0;

  /**
   * This function is used to retrieve extended information about a shared
   * notebook by a guest who has already authenticated to access that notebook.
   * This requires an 'authenticationToken' parameter which should be the
   * resut of a call to authenticateToSharedNotebook(...).
   * I.e. this is the token that gives access to the particular shared notebook
   * in someone else's account -- it's not the authenticationToken for the
   * owner of the notebook itself.
   * 
   * @param authenticationToken
   *   Should be the authentication token retrieved from the reply of
   *   authenticateToSharedNotebook(), proving access to a particular shared
   *   notebook.
   * 
   * @throws EDAMUserException <ul>
   *   <li> PERMISSION_DENIED "authenticationToken" -
   *          authentication token doesn't correspond to a valid shared notebook
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "SharedNotebook.id" - the shared notebook no longer exists
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   */
  virtual void getSharedNotebookByAuth( ::evernote::edam::SharedNotebook& _return, const std::string& authenticationToken) = 0;

  /**
   * Attempts to send a single note to one or more email recipients.
   * <p/>
   * NOTE: This function is generally not available to third party applications.
   * Calls will result in an EDAMUserException with the error code
   * PERMISSION_DENIED.
   * 
   * @param authenticationToken
   *    The note will be sent as the user logged in via this token, using that
   *    user's registered email address.  If the authenticated user doesn't
   *    have permission to read that note, the emailing will fail.
   * 
   * @param parameters
   *    The note must be specified either by GUID (in which case it will be
   *    sent using the existing data in the service), or else the full Note
   *    must be passed to this call.  This also specifies the additional
   *    email fields that will be used in the email.
   * 
   * @throws EDAMUserException <ul>
   *   <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
   *     The email can't be sent because this would exceed the user's daily
   *     email limit.
   *   </li>
   *   <li> BAD_DATA_FORMAT "(email address)" -
   *     email address malformed
   *   </li>
   *   <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
   *     if there are no To: or Cc: addresses provided.
   *   </li>
   *   <li> DATA_REQUIRED "Note.title" -
   *     if the caller provides a Note parameter with no title
   *   </li>
   *   <li> DATA_REQUIRED "Note.content" -
   *     if the caller provides a Note parameter with no content
   *   </li>
   *   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
   *   </li>
   *   <li> DATA_REQUIRED "NoteEmailParameters.note" -
   *     if no guid or note provided
   *   </li>
   *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note.guid" - not found, by GUID
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param parameters
   */
  virtual void emailNote(const std::string& authenticationToken, const NoteEmailParameters& parameters) = 0;

  /**
   * If this note is not already shared publicly (via its own direct URL), then this
   * will start sharing that note.
   * This will return the secret "Note Key" for this note that
   * can currently be used in conjunction with the Note's GUID to gain direct
   * read-only access to the Note.
   * If the note is already shared, then this won't make any changes to the
   * note, and the existing "Note Key" will be returned.  The only way to change
   * the Note Key for an existing note is to stopSharingNote first, and then
   * call this function.
   * 
   * @param guid
   *   The GUID of the note to be shared.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
   *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "Note.guid" - not found, by GUID</li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void shareNote(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * If this note is shared publicly then this will stop sharing that note
   * and invalidate its "Note Key", so any existing URLs to access that Note
   * will stop working.
   * 
   * If the Note is not shared, then this function will do nothing.
   * 
   * This function does not remove invididual shares for the note. To remove
   * individual shares, see stopSharingNoteWithRecipients.
   * 
   * @param guid
   *   The GUID of the note to be un-shared.
   * 
   * @throws EDAMUserException <ul>
   *   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
   *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li>"Note.guid" - not found, by GUID</li>
   * </ul>
   * 
   * @param authenticationToken
   * @param guid
   */
  virtual void stopSharingNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) = 0;

  /**
   * Asks the service to produce an authentication token that can be used to
   * access the contents of a single Note which was individually shared
   * from someone's account.
   * This authenticationToken can be used with the various other NoteStore
   * calls to find and retrieve the Note and its directly-referenced children.
   * 
   * @param guid
   *   The GUID identifying this Note on this shard.
   * 
   * @param noteKey
   *   The 'noteKey' identifier from the Note that was originally created via
   *   a call to shareNote() and then given to a recipient to access.
   * 
   * @param authenticationToken
   *   An optional authenticationToken that identifies the user accessing the
   *   shared note. This parameter may be required to access some shared notes.
   * 
   * @throws EDAMUserException <ul>
   *   <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
   *     shared, or the noteKey doesn't match the current key for this note
   *   </li>
   *   <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
   *     required to access this Note, but either no authentication token or a
   *     "non-owner" authentication token was provided.
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li> "guid" - the note with that GUID is not found
   *   </li>
   * </ul>
   * 
   * @throws EDAMSystemException <ul>
   *   <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
   *     all requesters).
   *   </li>
   *   <li> TAKEN_DOWN "Country" - The specified shared note is taken down
   *     for the requester because of an IP-based country lookup.
   *   </ul>
   * </ul>
   * 
   * @param guid
   * @param noteKey
   * @param authenticationToken
   */
  virtual void authenticateToSharedNote( ::evernote::edam::AuthenticationResult& _return, const std::string& guid, const std::string& noteKey, const std::string& authenticationToken) = 0;

  /**
   * Identify related entities on the service, such as notes,
   * notebooks, tags and users in a business related to notes or content.
   * 
   * @param query
   *   The information about which we are finding related entities.
   * 
   * @param resultSpec
   *   Allows the client to indicate the type and quantity of
   *   information to be returned, allowing a saving of time and
   *   bandwidth.
   * 
   * @return
   *   The result of the query, with information considered
   *   to likely be relevantly related to the information
   *   described by the query.
   * 
   * @throws EDAMUserException <ul>
   *   <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
   *     a zero-length plain text value.
   *   </li>
   *   <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
   *     invalid Note GUID, that is, one that does not match the constraints
   *     defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
   *   </li>
   *   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
   *   </li>
   *   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
   *   </li>
   *   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
   *   </li>
   *   <li>PERMISSION_DENIED "Note" - If the caller does not have access to
   *     the note identified by RelatedQuery.noteGuid.
   *   </li>
   *   <li>PERMISSION_DENIED "authenticationToken" - If the caller has requested to
   *     findExperts in the context of a non business user (i.e. The authenticationToken
   *     is not a business auth token).
   *   </li>
   *   <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
   *     in the result spec.
   *   </li>
   * </ul>
   * 
   * @throws EDAMNotFoundException <ul>
   *   <li>"RelatedQuery.noteGuid" - the note with that GUID is not
   *     found, if that field has been set in the query.
   *   </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param query
   * @param resultSpec
   */
  virtual void findRelated(RelatedResult& _return, const std::string& authenticationToken, const RelatedQuery& query, const RelatedResultSpec& resultSpec) = 0;

  /**
   * Perform the same operation as updateNote() would provided that the update
   * sequence number on the parameter Note object matches the current update sequence
   * number that the service has for the note.  If they do <i>not</i> match, then
   * <i>no</i> update is performed and the return value will have the current server
   * state in the note field and updated will be false.  If the update sequence
   * numbers between the client and server do match, then the note will be updated
   * and the note field of the return value will be returned as it would be for the
   * updateNote method.  This method allows you to check for an update to the note
   * on the service, by another client instance, from when you obtained the
   * note state as a baseline for your edits and the time when you wish to save your
   * edits.  If your client can merge the conflict, you can avoid overwriting changes
   * that were saved to the service by the other client.
   * 
   * See the updateNote method for information on the exceptions and parameters for
   * this method.  The only difference is that you must have an update sequence number
   * defined on the note parameter (equal to the USN of the note as synched to the
   * client), and the following additional exceptions might be thrown.
   * 
   * @throws EDAMUserException <ul>
   *   <li>DATA_REQUIRED "Note.updateSequenceNum" - If the update sequence number was
   *       not provided.  This includes a value that is set as 0.</li>
   *   <li>BAD_DATA_FORMAT "Note.updateSequenceNum" - If the note has an update
   *       sequence number that is larger than the current server value, which should
   *       not happen if your client is working correctly.</li>
   * </ul>
   * 
   * @param authenticationToken
   * @param note
   */
  virtual void updateNoteIfUsnMatches(UpdateNoteIfUsnMatchesResult& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note) = 0;

  /**
   * Manage invitations and memberships associated with a given notebook.
   * 
   * <i>Note:</i> Beta method! This method is currently intended for
   * limited use by Evernote clients that have discussed using this
   * routine with the platform team.
   * 
   * @param parameters A structure containing all parameters for the updates.
   *    See the structure documentation for details.
   * 
   * @throws EDAMUserException <ul>
   *   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - Trying to share a
   *    notebook while the notebook already has EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX
   *    shares.</li>
   * </ul>
   * 
   * @param authenticationToken
   * @param parameters
   */
  virtual void manageNotebookShares(ManageNotebookSharesResult& _return, const std::string& authenticationToken, const ManageNotebookSharesParameters& parameters) = 0;

  /**
   * Return the share relationships for the given notebook, including
   * both the invitations and the memberships.
   * 
   * <i>Note:</i> Beta method! This method is currently intended for
   * limited use by Evernote clients that have discussed using this
   * routine with the platform team.
   * 
   * @param authenticationToken
   * @param notebookGuid
   */
  virtual void getNotebookShares(ShareRelationships& _return, const std::string& authenticationToken, const std::string& notebookGuid) = 0;
};

class NoteStoreIfFactory {
 public:
  typedef NoteStoreIf Handler;

  virtual ~NoteStoreIfFactory() {}

  virtual NoteStoreIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(NoteStoreIf* /* handler */) = 0;
};

class NoteStoreIfSingletonFactory : virtual public NoteStoreIfFactory {
 public:
  NoteStoreIfSingletonFactory(const boost::shared_ptr<NoteStoreIf>& iface) : iface_(iface) {}
  virtual ~NoteStoreIfSingletonFactory() {}

  virtual NoteStoreIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(NoteStoreIf* /* handler */) {}

 protected:
  boost::shared_ptr<NoteStoreIf> iface_;
};

class NoteStoreNull : virtual public NoteStoreIf {
 public:
  virtual ~NoteStoreNull() {}
  void getSyncState(SyncState& /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void getFilteredSyncChunk(SyncChunk& /* _return */, const std::string& /* authenticationToken */, const int32_t /* afterUSN */, const int32_t /* maxEntries */, const SyncChunkFilter& /* filter */) {
    return;
  }
  void getLinkedNotebookSyncState(SyncState& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::LinkedNotebook& /* linkedNotebook */) {
    return;
  }
  void getLinkedNotebookSyncChunk(SyncChunk& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::LinkedNotebook& /* linkedNotebook */, const int32_t /* afterUSN */, const int32_t /* maxEntries */, const bool /* fullSyncOnly */) {
    return;
  }
  void listNotebooks(std::vector< ::evernote::edam::Notebook> & /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void listAccessibleBusinessNotebooks(std::vector< ::evernote::edam::Notebook> & /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void getNotebook( ::evernote::edam::Notebook& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void getDefaultNotebook( ::evernote::edam::Notebook& /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void createNotebook( ::evernote::edam::Notebook& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Notebook& /* notebook */) {
    return;
  }
  int32_t updateNotebook(const std::string& /* authenticationToken */, const  ::evernote::edam::Notebook& /* notebook */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t expungeNotebook(const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    int32_t _return = 0;
    return _return;
  }
  void listTags(std::vector< ::evernote::edam::Tag> & /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void listTagsByNotebook(std::vector< ::evernote::edam::Tag> & /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* notebookGuid */) {
    return;
  }
  void getTag( ::evernote::edam::Tag& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void createTag( ::evernote::edam::Tag& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Tag& /* tag */) {
    return;
  }
  int32_t updateTag(const std::string& /* authenticationToken */, const  ::evernote::edam::Tag& /* tag */) {
    int32_t _return = 0;
    return _return;
  }
  void untagAll(const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  int32_t expungeTag(const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    int32_t _return = 0;
    return _return;
  }
  void listSearches(std::vector< ::evernote::edam::SavedSearch> & /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void getSearch( ::evernote::edam::SavedSearch& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void createSearch( ::evernote::edam::SavedSearch& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::SavedSearch& /* search */) {
    return;
  }
  int32_t updateSearch(const std::string& /* authenticationToken */, const  ::evernote::edam::SavedSearch& /* search */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t expungeSearch(const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t findNoteOffset(const std::string& /* authenticationToken */, const NoteFilter& /* filter */, const  ::evernote::edam::Guid& /* guid */) {
    int32_t _return = 0;
    return _return;
  }
  void findNotesMetadata(NotesMetadataList& /* _return */, const std::string& /* authenticationToken */, const NoteFilter& /* filter */, const int32_t /* offset */, const int32_t /* maxNotes */, const NotesMetadataResultSpec& /* resultSpec */) {
    return;
  }
  void findNoteCounts(NoteCollectionCounts& /* _return */, const std::string& /* authenticationToken */, const NoteFilter& /* filter */, const bool /* withTrash */) {
    return;
  }
  void getNoteWithResultSpec( ::evernote::edam::Note& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */, const NoteResultSpec& /* resultSpec */) {
    return;
  }
  void getNote( ::evernote::edam::Note& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */, const bool /* withContent */, const bool /* withResourcesData */, const bool /* withResourcesRecognition */, const bool /* withResourcesAlternateData */) {
    return;
  }
  void getNoteApplicationData( ::evernote::edam::LazyMap& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void getNoteApplicationDataEntry(std::string& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */, const std::string& /* key */) {
    return;
  }
  int32_t setNoteApplicationDataEntry(const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */, const std::string& /* key */, const std::string& /* value */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t unsetNoteApplicationDataEntry(const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */, const std::string& /* key */) {
    int32_t _return = 0;
    return _return;
  }
  void getNoteContent(std::string& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void getNoteSearchText(std::string& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */, const bool /* noteOnly */, const bool /* tokenizeForIndexing */) {
    return;
  }
  void getResourceSearchText(std::string& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void getNoteTagNames(std::vector<std::string> & /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void createNote( ::evernote::edam::Note& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Note& /* note */) {
    return;
  }
  void updateNote( ::evernote::edam::Note& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Note& /* note */) {
    return;
  }
  int32_t deleteNote(const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t expungeNote(const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    int32_t _return = 0;
    return _return;
  }
  void copyNote( ::evernote::edam::Note& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* noteGuid */, const  ::evernote::edam::Guid& /* toNotebookGuid */) {
    return;
  }
  void listNoteVersions(std::vector<NoteVersionId> & /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* noteGuid */) {
    return;
  }
  void getNoteVersion( ::evernote::edam::Note& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* noteGuid */, const int32_t /* updateSequenceNum */, const bool /* withResourcesData */, const bool /* withResourcesRecognition */, const bool /* withResourcesAlternateData */) {
    return;
  }
  void getResource( ::evernote::edam::Resource& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */, const bool /* withData */, const bool /* withRecognition */, const bool /* withAttributes */, const bool /* withAlternateData */) {
    return;
  }
  void getResourceApplicationData( ::evernote::edam::LazyMap& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void getResourceApplicationDataEntry(std::string& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */, const std::string& /* key */) {
    return;
  }
  int32_t setResourceApplicationDataEntry(const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */, const std::string& /* key */, const std::string& /* value */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t unsetResourceApplicationDataEntry(const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */, const std::string& /* key */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t updateResource(const std::string& /* authenticationToken */, const  ::evernote::edam::Resource& /* resource */) {
    int32_t _return = 0;
    return _return;
  }
  void getResourceData(std::string& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void getResourceByHash( ::evernote::edam::Resource& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* noteGuid */, const std::string& /* contentHash */, const bool /* withData */, const bool /* withRecognition */, const bool /* withAlternateData */) {
    return;
  }
  void getResourceRecognition(std::string& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void getResourceAlternateData(std::string& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void getResourceAttributes( ::evernote::edam::ResourceAttributes& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void getPublicNotebook( ::evernote::edam::Notebook& /* _return */, const  ::evernote::edam::UserID /* userId */, const std::string& /* publicUri */) {
    return;
  }
  void shareNotebook( ::evernote::edam::SharedNotebook& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::SharedNotebook& /* sharedNotebook */, const std::string& /* message */) {
    return;
  }
  void createOrUpdateNotebookShares(CreateOrUpdateNotebookSharesResult& /* _return */, const std::string& /* authenticationToken */, const NotebookShareTemplate& /* shareTemplate */) {
    return;
  }
  int32_t updateSharedNotebook(const std::string& /* authenticationToken */, const  ::evernote::edam::SharedNotebook& /* sharedNotebook */) {
    int32_t _return = 0;
    return _return;
  }
  void setNotebookRecipientSettings( ::evernote::edam::Notebook& /* _return */, const std::string& /* authenticationToken */, const std::string& /* notebookGuid */, const  ::evernote::edam::NotebookRecipientSettings& /* recipientSettings */) {
    return;
  }
  void listSharedNotebooks(std::vector< ::evernote::edam::SharedNotebook> & /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void createLinkedNotebook( ::evernote::edam::LinkedNotebook& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::LinkedNotebook& /* linkedNotebook */) {
    return;
  }
  int32_t updateLinkedNotebook(const std::string& /* authenticationToken */, const  ::evernote::edam::LinkedNotebook& /* linkedNotebook */) {
    int32_t _return = 0;
    return _return;
  }
  void listLinkedNotebooks(std::vector< ::evernote::edam::LinkedNotebook> & /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  int32_t expungeLinkedNotebook(const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    int32_t _return = 0;
    return _return;
  }
  void authenticateToSharedNotebook( ::evernote::edam::AuthenticationResult& /* _return */, const std::string& /* shareKeyOrGlobalId */, const std::string& /* authenticationToken */) {
    return;
  }
  void getSharedNotebookByAuth( ::evernote::edam::SharedNotebook& /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void emailNote(const std::string& /* authenticationToken */, const NoteEmailParameters& /* parameters */) {
    return;
  }
  void shareNote(std::string& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void stopSharingNote(const std::string& /* authenticationToken */, const  ::evernote::edam::Guid& /* guid */) {
    return;
  }
  void authenticateToSharedNote( ::evernote::edam::AuthenticationResult& /* _return */, const std::string& /* guid */, const std::string& /* noteKey */, const std::string& /* authenticationToken */) {
    return;
  }
  void findRelated(RelatedResult& /* _return */, const std::string& /* authenticationToken */, const RelatedQuery& /* query */, const RelatedResultSpec& /* resultSpec */) {
    return;
  }
  void updateNoteIfUsnMatches(UpdateNoteIfUsnMatchesResult& /* _return */, const std::string& /* authenticationToken */, const  ::evernote::edam::Note& /* note */) {
    return;
  }
  void manageNotebookShares(ManageNotebookSharesResult& /* _return */, const std::string& /* authenticationToken */, const ManageNotebookSharesParameters& /* parameters */) {
    return;
  }
  void getNotebookShares(ShareRelationships& /* _return */, const std::string& /* authenticationToken */, const std::string& /* notebookGuid */) {
    return;
  }
};

typedef struct _NoteStore_getSyncState_args__isset {
  _NoteStore_getSyncState_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _NoteStore_getSyncState_args__isset;

class NoteStore_getSyncState_args {
 public:

  NoteStore_getSyncState_args(const NoteStore_getSyncState_args&);
  NoteStore_getSyncState_args& operator=(const NoteStore_getSyncState_args&);
  NoteStore_getSyncState_args() : authenticationToken() {
  }

  virtual ~NoteStore_getSyncState_args() throw();
  std::string authenticationToken;

  _NoteStore_getSyncState_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const NoteStore_getSyncState_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getSyncState_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getSyncState_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getSyncState_pargs {
 public:


  virtual ~NoteStore_getSyncState_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getSyncState_result__isset {
  _NoteStore_getSyncState_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_getSyncState_result__isset;

class NoteStore_getSyncState_result {
 public:

  NoteStore_getSyncState_result(const NoteStore_getSyncState_result&);
  NoteStore_getSyncState_result& operator=(const NoteStore_getSyncState_result&);
  NoteStore_getSyncState_result() {
  }

  virtual ~NoteStore_getSyncState_result() throw();
  SyncState success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_getSyncState_result__isset __isset;

  void __set_success(const SyncState& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_getSyncState_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getSyncState_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getSyncState_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getSyncState_presult__isset {
  _NoteStore_getSyncState_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_getSyncState_presult__isset;

class NoteStore_getSyncState_presult {
 public:


  virtual ~NoteStore_getSyncState_presult() throw();
  SyncState* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_getSyncState_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getFilteredSyncChunk_args__isset {
  _NoteStore_getFilteredSyncChunk_args__isset() : authenticationToken(false), afterUSN(false), maxEntries(false), filter(false) {}
  bool authenticationToken :1;
  bool afterUSN :1;
  bool maxEntries :1;
  bool filter :1;
} _NoteStore_getFilteredSyncChunk_args__isset;

class NoteStore_getFilteredSyncChunk_args {
 public:

  NoteStore_getFilteredSyncChunk_args(const NoteStore_getFilteredSyncChunk_args&);
  NoteStore_getFilteredSyncChunk_args& operator=(const NoteStore_getFilteredSyncChunk_args&);
  NoteStore_getFilteredSyncChunk_args() : authenticationToken(), afterUSN(0), maxEntries(0) {
  }

  virtual ~NoteStore_getFilteredSyncChunk_args() throw();
  std::string authenticationToken;
  int32_t afterUSN;
  int32_t maxEntries;
  SyncChunkFilter filter;

  _NoteStore_getFilteredSyncChunk_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_afterUSN(const int32_t val);

  void __set_maxEntries(const int32_t val);

  void __set_filter(const SyncChunkFilter& val);

  bool operator == (const NoteStore_getFilteredSyncChunk_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(afterUSN == rhs.afterUSN))
      return false;
    if (!(maxEntries == rhs.maxEntries))
      return false;
    if (!(filter == rhs.filter))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getFilteredSyncChunk_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getFilteredSyncChunk_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getFilteredSyncChunk_pargs {
 public:


  virtual ~NoteStore_getFilteredSyncChunk_pargs() throw();
  const std::string* authenticationToken;
  const int32_t* afterUSN;
  const int32_t* maxEntries;
  const SyncChunkFilter* filter;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getFilteredSyncChunk_result__isset {
  _NoteStore_getFilteredSyncChunk_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_getFilteredSyncChunk_result__isset;

class NoteStore_getFilteredSyncChunk_result {
 public:

  NoteStore_getFilteredSyncChunk_result(const NoteStore_getFilteredSyncChunk_result&);
  NoteStore_getFilteredSyncChunk_result& operator=(const NoteStore_getFilteredSyncChunk_result&);
  NoteStore_getFilteredSyncChunk_result() {
  }

  virtual ~NoteStore_getFilteredSyncChunk_result() throw();
  SyncChunk success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_getFilteredSyncChunk_result__isset __isset;

  void __set_success(const SyncChunk& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_getFilteredSyncChunk_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getFilteredSyncChunk_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getFilteredSyncChunk_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getFilteredSyncChunk_presult__isset {
  _NoteStore_getFilteredSyncChunk_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_getFilteredSyncChunk_presult__isset;

class NoteStore_getFilteredSyncChunk_presult {
 public:


  virtual ~NoteStore_getFilteredSyncChunk_presult() throw();
  SyncChunk* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_getFilteredSyncChunk_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getLinkedNotebookSyncState_args__isset {
  _NoteStore_getLinkedNotebookSyncState_args__isset() : authenticationToken(false), linkedNotebook(false) {}
  bool authenticationToken :1;
  bool linkedNotebook :1;
} _NoteStore_getLinkedNotebookSyncState_args__isset;

class NoteStore_getLinkedNotebookSyncState_args {
 public:

  NoteStore_getLinkedNotebookSyncState_args(const NoteStore_getLinkedNotebookSyncState_args&);
  NoteStore_getLinkedNotebookSyncState_args& operator=(const NoteStore_getLinkedNotebookSyncState_args&);
  NoteStore_getLinkedNotebookSyncState_args() : authenticationToken() {
  }

  virtual ~NoteStore_getLinkedNotebookSyncState_args() throw();
  std::string authenticationToken;
   ::evernote::edam::LinkedNotebook linkedNotebook;

  _NoteStore_getLinkedNotebookSyncState_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_linkedNotebook(const  ::evernote::edam::LinkedNotebook& val);

  bool operator == (const NoteStore_getLinkedNotebookSyncState_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(linkedNotebook == rhs.linkedNotebook))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getLinkedNotebookSyncState_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getLinkedNotebookSyncState_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getLinkedNotebookSyncState_pargs {
 public:


  virtual ~NoteStore_getLinkedNotebookSyncState_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::LinkedNotebook* linkedNotebook;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getLinkedNotebookSyncState_result__isset {
  _NoteStore_getLinkedNotebookSyncState_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getLinkedNotebookSyncState_result__isset;

class NoteStore_getLinkedNotebookSyncState_result {
 public:

  NoteStore_getLinkedNotebookSyncState_result(const NoteStore_getLinkedNotebookSyncState_result&);
  NoteStore_getLinkedNotebookSyncState_result& operator=(const NoteStore_getLinkedNotebookSyncState_result&);
  NoteStore_getLinkedNotebookSyncState_result() {
  }

  virtual ~NoteStore_getLinkedNotebookSyncState_result() throw();
  SyncState success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getLinkedNotebookSyncState_result__isset __isset;

  void __set_success(const SyncState& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getLinkedNotebookSyncState_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getLinkedNotebookSyncState_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getLinkedNotebookSyncState_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getLinkedNotebookSyncState_presult__isset {
  _NoteStore_getLinkedNotebookSyncState_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getLinkedNotebookSyncState_presult__isset;

class NoteStore_getLinkedNotebookSyncState_presult {
 public:


  virtual ~NoteStore_getLinkedNotebookSyncState_presult() throw();
  SyncState* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getLinkedNotebookSyncState_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getLinkedNotebookSyncChunk_args__isset {
  _NoteStore_getLinkedNotebookSyncChunk_args__isset() : authenticationToken(false), linkedNotebook(false), afterUSN(false), maxEntries(false), fullSyncOnly(false) {}
  bool authenticationToken :1;
  bool linkedNotebook :1;
  bool afterUSN :1;
  bool maxEntries :1;
  bool fullSyncOnly :1;
} _NoteStore_getLinkedNotebookSyncChunk_args__isset;

class NoteStore_getLinkedNotebookSyncChunk_args {
 public:

  NoteStore_getLinkedNotebookSyncChunk_args(const NoteStore_getLinkedNotebookSyncChunk_args&);
  NoteStore_getLinkedNotebookSyncChunk_args& operator=(const NoteStore_getLinkedNotebookSyncChunk_args&);
  NoteStore_getLinkedNotebookSyncChunk_args() : authenticationToken(), afterUSN(0), maxEntries(0), fullSyncOnly(0) {
  }

  virtual ~NoteStore_getLinkedNotebookSyncChunk_args() throw();
  std::string authenticationToken;
   ::evernote::edam::LinkedNotebook linkedNotebook;
  int32_t afterUSN;
  int32_t maxEntries;
  bool fullSyncOnly;

  _NoteStore_getLinkedNotebookSyncChunk_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_linkedNotebook(const  ::evernote::edam::LinkedNotebook& val);

  void __set_afterUSN(const int32_t val);

  void __set_maxEntries(const int32_t val);

  void __set_fullSyncOnly(const bool val);

  bool operator == (const NoteStore_getLinkedNotebookSyncChunk_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(linkedNotebook == rhs.linkedNotebook))
      return false;
    if (!(afterUSN == rhs.afterUSN))
      return false;
    if (!(maxEntries == rhs.maxEntries))
      return false;
    if (!(fullSyncOnly == rhs.fullSyncOnly))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getLinkedNotebookSyncChunk_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getLinkedNotebookSyncChunk_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getLinkedNotebookSyncChunk_pargs {
 public:


  virtual ~NoteStore_getLinkedNotebookSyncChunk_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::LinkedNotebook* linkedNotebook;
  const int32_t* afterUSN;
  const int32_t* maxEntries;
  const bool* fullSyncOnly;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getLinkedNotebookSyncChunk_result__isset {
  _NoteStore_getLinkedNotebookSyncChunk_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getLinkedNotebookSyncChunk_result__isset;

class NoteStore_getLinkedNotebookSyncChunk_result {
 public:

  NoteStore_getLinkedNotebookSyncChunk_result(const NoteStore_getLinkedNotebookSyncChunk_result&);
  NoteStore_getLinkedNotebookSyncChunk_result& operator=(const NoteStore_getLinkedNotebookSyncChunk_result&);
  NoteStore_getLinkedNotebookSyncChunk_result() {
  }

  virtual ~NoteStore_getLinkedNotebookSyncChunk_result() throw();
  SyncChunk success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getLinkedNotebookSyncChunk_result__isset __isset;

  void __set_success(const SyncChunk& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getLinkedNotebookSyncChunk_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getLinkedNotebookSyncChunk_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getLinkedNotebookSyncChunk_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getLinkedNotebookSyncChunk_presult__isset {
  _NoteStore_getLinkedNotebookSyncChunk_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getLinkedNotebookSyncChunk_presult__isset;

class NoteStore_getLinkedNotebookSyncChunk_presult {
 public:


  virtual ~NoteStore_getLinkedNotebookSyncChunk_presult() throw();
  SyncChunk* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getLinkedNotebookSyncChunk_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_listNotebooks_args__isset {
  _NoteStore_listNotebooks_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _NoteStore_listNotebooks_args__isset;

class NoteStore_listNotebooks_args {
 public:

  NoteStore_listNotebooks_args(const NoteStore_listNotebooks_args&);
  NoteStore_listNotebooks_args& operator=(const NoteStore_listNotebooks_args&);
  NoteStore_listNotebooks_args() : authenticationToken() {
  }

  virtual ~NoteStore_listNotebooks_args() throw();
  std::string authenticationToken;

  _NoteStore_listNotebooks_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const NoteStore_listNotebooks_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listNotebooks_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listNotebooks_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_listNotebooks_pargs {
 public:


  virtual ~NoteStore_listNotebooks_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listNotebooks_result__isset {
  _NoteStore_listNotebooks_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_listNotebooks_result__isset;

class NoteStore_listNotebooks_result {
 public:

  NoteStore_listNotebooks_result(const NoteStore_listNotebooks_result&);
  NoteStore_listNotebooks_result& operator=(const NoteStore_listNotebooks_result&);
  NoteStore_listNotebooks_result() {
  }

  virtual ~NoteStore_listNotebooks_result() throw();
  std::vector< ::evernote::edam::Notebook>  success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_listNotebooks_result__isset __isset;

  void __set_success(const std::vector< ::evernote::edam::Notebook> & val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_listNotebooks_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listNotebooks_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listNotebooks_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listNotebooks_presult__isset {
  _NoteStore_listNotebooks_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_listNotebooks_presult__isset;

class NoteStore_listNotebooks_presult {
 public:


  virtual ~NoteStore_listNotebooks_presult() throw();
  std::vector< ::evernote::edam::Notebook> * success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_listNotebooks_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_listAccessibleBusinessNotebooks_args__isset {
  _NoteStore_listAccessibleBusinessNotebooks_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _NoteStore_listAccessibleBusinessNotebooks_args__isset;

class NoteStore_listAccessibleBusinessNotebooks_args {
 public:

  NoteStore_listAccessibleBusinessNotebooks_args(const NoteStore_listAccessibleBusinessNotebooks_args&);
  NoteStore_listAccessibleBusinessNotebooks_args& operator=(const NoteStore_listAccessibleBusinessNotebooks_args&);
  NoteStore_listAccessibleBusinessNotebooks_args() : authenticationToken() {
  }

  virtual ~NoteStore_listAccessibleBusinessNotebooks_args() throw();
  std::string authenticationToken;

  _NoteStore_listAccessibleBusinessNotebooks_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const NoteStore_listAccessibleBusinessNotebooks_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listAccessibleBusinessNotebooks_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listAccessibleBusinessNotebooks_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_listAccessibleBusinessNotebooks_pargs {
 public:


  virtual ~NoteStore_listAccessibleBusinessNotebooks_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listAccessibleBusinessNotebooks_result__isset {
  _NoteStore_listAccessibleBusinessNotebooks_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_listAccessibleBusinessNotebooks_result__isset;

class NoteStore_listAccessibleBusinessNotebooks_result {
 public:

  NoteStore_listAccessibleBusinessNotebooks_result(const NoteStore_listAccessibleBusinessNotebooks_result&);
  NoteStore_listAccessibleBusinessNotebooks_result& operator=(const NoteStore_listAccessibleBusinessNotebooks_result&);
  NoteStore_listAccessibleBusinessNotebooks_result() {
  }

  virtual ~NoteStore_listAccessibleBusinessNotebooks_result() throw();
  std::vector< ::evernote::edam::Notebook>  success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_listAccessibleBusinessNotebooks_result__isset __isset;

  void __set_success(const std::vector< ::evernote::edam::Notebook> & val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_listAccessibleBusinessNotebooks_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listAccessibleBusinessNotebooks_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listAccessibleBusinessNotebooks_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listAccessibleBusinessNotebooks_presult__isset {
  _NoteStore_listAccessibleBusinessNotebooks_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_listAccessibleBusinessNotebooks_presult__isset;

class NoteStore_listAccessibleBusinessNotebooks_presult {
 public:


  virtual ~NoteStore_listAccessibleBusinessNotebooks_presult() throw();
  std::vector< ::evernote::edam::Notebook> * success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_listAccessibleBusinessNotebooks_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getNotebook_args__isset {
  _NoteStore_getNotebook_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_getNotebook_args__isset;

class NoteStore_getNotebook_args {
 public:

  NoteStore_getNotebook_args(const NoteStore_getNotebook_args&);
  NoteStore_getNotebook_args& operator=(const NoteStore_getNotebook_args&);
  NoteStore_getNotebook_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_getNotebook_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_getNotebook_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_getNotebook_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNotebook_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNotebook_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getNotebook_pargs {
 public:


  virtual ~NoteStore_getNotebook_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNotebook_result__isset {
  _NoteStore_getNotebook_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNotebook_result__isset;

class NoteStore_getNotebook_result {
 public:

  NoteStore_getNotebook_result(const NoteStore_getNotebook_result&);
  NoteStore_getNotebook_result& operator=(const NoteStore_getNotebook_result&);
  NoteStore_getNotebook_result() {
  }

  virtual ~NoteStore_getNotebook_result() throw();
   ::evernote::edam::Notebook success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNotebook_result__isset __isset;

  void __set_success(const  ::evernote::edam::Notebook& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getNotebook_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNotebook_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNotebook_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNotebook_presult__isset {
  _NoteStore_getNotebook_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNotebook_presult__isset;

class NoteStore_getNotebook_presult {
 public:


  virtual ~NoteStore_getNotebook_presult() throw();
   ::evernote::edam::Notebook* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNotebook_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getDefaultNotebook_args__isset {
  _NoteStore_getDefaultNotebook_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _NoteStore_getDefaultNotebook_args__isset;

class NoteStore_getDefaultNotebook_args {
 public:

  NoteStore_getDefaultNotebook_args(const NoteStore_getDefaultNotebook_args&);
  NoteStore_getDefaultNotebook_args& operator=(const NoteStore_getDefaultNotebook_args&);
  NoteStore_getDefaultNotebook_args() : authenticationToken() {
  }

  virtual ~NoteStore_getDefaultNotebook_args() throw();
  std::string authenticationToken;

  _NoteStore_getDefaultNotebook_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const NoteStore_getDefaultNotebook_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getDefaultNotebook_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getDefaultNotebook_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getDefaultNotebook_pargs {
 public:


  virtual ~NoteStore_getDefaultNotebook_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getDefaultNotebook_result__isset {
  _NoteStore_getDefaultNotebook_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_getDefaultNotebook_result__isset;

class NoteStore_getDefaultNotebook_result {
 public:

  NoteStore_getDefaultNotebook_result(const NoteStore_getDefaultNotebook_result&);
  NoteStore_getDefaultNotebook_result& operator=(const NoteStore_getDefaultNotebook_result&);
  NoteStore_getDefaultNotebook_result() {
  }

  virtual ~NoteStore_getDefaultNotebook_result() throw();
   ::evernote::edam::Notebook success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_getDefaultNotebook_result__isset __isset;

  void __set_success(const  ::evernote::edam::Notebook& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_getDefaultNotebook_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getDefaultNotebook_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getDefaultNotebook_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getDefaultNotebook_presult__isset {
  _NoteStore_getDefaultNotebook_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_getDefaultNotebook_presult__isset;

class NoteStore_getDefaultNotebook_presult {
 public:


  virtual ~NoteStore_getDefaultNotebook_presult() throw();
   ::evernote::edam::Notebook* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_getDefaultNotebook_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_createNotebook_args__isset {
  _NoteStore_createNotebook_args__isset() : authenticationToken(false), notebook(false) {}
  bool authenticationToken :1;
  bool notebook :1;
} _NoteStore_createNotebook_args__isset;

class NoteStore_createNotebook_args {
 public:

  NoteStore_createNotebook_args(const NoteStore_createNotebook_args&);
  NoteStore_createNotebook_args& operator=(const NoteStore_createNotebook_args&);
  NoteStore_createNotebook_args() : authenticationToken() {
  }

  virtual ~NoteStore_createNotebook_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Notebook notebook;

  _NoteStore_createNotebook_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_notebook(const  ::evernote::edam::Notebook& val);

  bool operator == (const NoteStore_createNotebook_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(notebook == rhs.notebook))
      return false;
    return true;
  }
  bool operator != (const NoteStore_createNotebook_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_createNotebook_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_createNotebook_pargs {
 public:


  virtual ~NoteStore_createNotebook_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Notebook* notebook;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_createNotebook_result__isset {
  _NoteStore_createNotebook_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_createNotebook_result__isset;

class NoteStore_createNotebook_result {
 public:

  NoteStore_createNotebook_result(const NoteStore_createNotebook_result&);
  NoteStore_createNotebook_result& operator=(const NoteStore_createNotebook_result&);
  NoteStore_createNotebook_result() {
  }

  virtual ~NoteStore_createNotebook_result() throw();
   ::evernote::edam::Notebook success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_createNotebook_result__isset __isset;

  void __set_success(const  ::evernote::edam::Notebook& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_createNotebook_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_createNotebook_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_createNotebook_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_createNotebook_presult__isset {
  _NoteStore_createNotebook_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_createNotebook_presult__isset;

class NoteStore_createNotebook_presult {
 public:


  virtual ~NoteStore_createNotebook_presult() throw();
   ::evernote::edam::Notebook* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_createNotebook_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_updateNotebook_args__isset {
  _NoteStore_updateNotebook_args__isset() : authenticationToken(false), notebook(false) {}
  bool authenticationToken :1;
  bool notebook :1;
} _NoteStore_updateNotebook_args__isset;

class NoteStore_updateNotebook_args {
 public:

  NoteStore_updateNotebook_args(const NoteStore_updateNotebook_args&);
  NoteStore_updateNotebook_args& operator=(const NoteStore_updateNotebook_args&);
  NoteStore_updateNotebook_args() : authenticationToken() {
  }

  virtual ~NoteStore_updateNotebook_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Notebook notebook;

  _NoteStore_updateNotebook_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_notebook(const  ::evernote::edam::Notebook& val);

  bool operator == (const NoteStore_updateNotebook_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(notebook == rhs.notebook))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateNotebook_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateNotebook_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_updateNotebook_pargs {
 public:


  virtual ~NoteStore_updateNotebook_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Notebook* notebook;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateNotebook_result__isset {
  _NoteStore_updateNotebook_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_updateNotebook_result__isset;

class NoteStore_updateNotebook_result {
 public:

  NoteStore_updateNotebook_result(const NoteStore_updateNotebook_result&);
  NoteStore_updateNotebook_result& operator=(const NoteStore_updateNotebook_result&);
  NoteStore_updateNotebook_result() : success(0) {
  }

  virtual ~NoteStore_updateNotebook_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_updateNotebook_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_updateNotebook_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateNotebook_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateNotebook_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateNotebook_presult__isset {
  _NoteStore_updateNotebook_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_updateNotebook_presult__isset;

class NoteStore_updateNotebook_presult {
 public:


  virtual ~NoteStore_updateNotebook_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_updateNotebook_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_expungeNotebook_args__isset {
  _NoteStore_expungeNotebook_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_expungeNotebook_args__isset;

class NoteStore_expungeNotebook_args {
 public:

  NoteStore_expungeNotebook_args(const NoteStore_expungeNotebook_args&);
  NoteStore_expungeNotebook_args& operator=(const NoteStore_expungeNotebook_args&);
  NoteStore_expungeNotebook_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_expungeNotebook_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_expungeNotebook_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_expungeNotebook_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_expungeNotebook_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_expungeNotebook_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_expungeNotebook_pargs {
 public:


  virtual ~NoteStore_expungeNotebook_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_expungeNotebook_result__isset {
  _NoteStore_expungeNotebook_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_expungeNotebook_result__isset;

class NoteStore_expungeNotebook_result {
 public:

  NoteStore_expungeNotebook_result(const NoteStore_expungeNotebook_result&);
  NoteStore_expungeNotebook_result& operator=(const NoteStore_expungeNotebook_result&);
  NoteStore_expungeNotebook_result() : success(0) {
  }

  virtual ~NoteStore_expungeNotebook_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_expungeNotebook_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_expungeNotebook_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_expungeNotebook_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_expungeNotebook_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_expungeNotebook_presult__isset {
  _NoteStore_expungeNotebook_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_expungeNotebook_presult__isset;

class NoteStore_expungeNotebook_presult {
 public:


  virtual ~NoteStore_expungeNotebook_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_expungeNotebook_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_listTags_args__isset {
  _NoteStore_listTags_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _NoteStore_listTags_args__isset;

class NoteStore_listTags_args {
 public:

  NoteStore_listTags_args(const NoteStore_listTags_args&);
  NoteStore_listTags_args& operator=(const NoteStore_listTags_args&);
  NoteStore_listTags_args() : authenticationToken() {
  }

  virtual ~NoteStore_listTags_args() throw();
  std::string authenticationToken;

  _NoteStore_listTags_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const NoteStore_listTags_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listTags_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listTags_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_listTags_pargs {
 public:


  virtual ~NoteStore_listTags_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listTags_result__isset {
  _NoteStore_listTags_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_listTags_result__isset;

class NoteStore_listTags_result {
 public:

  NoteStore_listTags_result(const NoteStore_listTags_result&);
  NoteStore_listTags_result& operator=(const NoteStore_listTags_result&);
  NoteStore_listTags_result() {
  }

  virtual ~NoteStore_listTags_result() throw();
  std::vector< ::evernote::edam::Tag>  success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_listTags_result__isset __isset;

  void __set_success(const std::vector< ::evernote::edam::Tag> & val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_listTags_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listTags_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listTags_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listTags_presult__isset {
  _NoteStore_listTags_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_listTags_presult__isset;

class NoteStore_listTags_presult {
 public:


  virtual ~NoteStore_listTags_presult() throw();
  std::vector< ::evernote::edam::Tag> * success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_listTags_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_listTagsByNotebook_args__isset {
  _NoteStore_listTagsByNotebook_args__isset() : authenticationToken(false), notebookGuid(false) {}
  bool authenticationToken :1;
  bool notebookGuid :1;
} _NoteStore_listTagsByNotebook_args__isset;

class NoteStore_listTagsByNotebook_args {
 public:

  NoteStore_listTagsByNotebook_args(const NoteStore_listTagsByNotebook_args&);
  NoteStore_listTagsByNotebook_args& operator=(const NoteStore_listTagsByNotebook_args&);
  NoteStore_listTagsByNotebook_args() : authenticationToken(), notebookGuid() {
  }

  virtual ~NoteStore_listTagsByNotebook_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid notebookGuid;

  _NoteStore_listTagsByNotebook_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_notebookGuid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_listTagsByNotebook_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(notebookGuid == rhs.notebookGuid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listTagsByNotebook_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listTagsByNotebook_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_listTagsByNotebook_pargs {
 public:


  virtual ~NoteStore_listTagsByNotebook_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* notebookGuid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listTagsByNotebook_result__isset {
  _NoteStore_listTagsByNotebook_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_listTagsByNotebook_result__isset;

class NoteStore_listTagsByNotebook_result {
 public:

  NoteStore_listTagsByNotebook_result(const NoteStore_listTagsByNotebook_result&);
  NoteStore_listTagsByNotebook_result& operator=(const NoteStore_listTagsByNotebook_result&);
  NoteStore_listTagsByNotebook_result() {
  }

  virtual ~NoteStore_listTagsByNotebook_result() throw();
  std::vector< ::evernote::edam::Tag>  success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_listTagsByNotebook_result__isset __isset;

  void __set_success(const std::vector< ::evernote::edam::Tag> & val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_listTagsByNotebook_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listTagsByNotebook_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listTagsByNotebook_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listTagsByNotebook_presult__isset {
  _NoteStore_listTagsByNotebook_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_listTagsByNotebook_presult__isset;

class NoteStore_listTagsByNotebook_presult {
 public:


  virtual ~NoteStore_listTagsByNotebook_presult() throw();
  std::vector< ::evernote::edam::Tag> * success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_listTagsByNotebook_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getTag_args__isset {
  _NoteStore_getTag_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_getTag_args__isset;

class NoteStore_getTag_args {
 public:

  NoteStore_getTag_args(const NoteStore_getTag_args&);
  NoteStore_getTag_args& operator=(const NoteStore_getTag_args&);
  NoteStore_getTag_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_getTag_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_getTag_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_getTag_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getTag_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getTag_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getTag_pargs {
 public:


  virtual ~NoteStore_getTag_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getTag_result__isset {
  _NoteStore_getTag_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getTag_result__isset;

class NoteStore_getTag_result {
 public:

  NoteStore_getTag_result(const NoteStore_getTag_result&);
  NoteStore_getTag_result& operator=(const NoteStore_getTag_result&);
  NoteStore_getTag_result() {
  }

  virtual ~NoteStore_getTag_result() throw();
   ::evernote::edam::Tag success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getTag_result__isset __isset;

  void __set_success(const  ::evernote::edam::Tag& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getTag_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getTag_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getTag_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getTag_presult__isset {
  _NoteStore_getTag_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getTag_presult__isset;

class NoteStore_getTag_presult {
 public:


  virtual ~NoteStore_getTag_presult() throw();
   ::evernote::edam::Tag* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getTag_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_createTag_args__isset {
  _NoteStore_createTag_args__isset() : authenticationToken(false), tag(false) {}
  bool authenticationToken :1;
  bool tag :1;
} _NoteStore_createTag_args__isset;

class NoteStore_createTag_args {
 public:

  NoteStore_createTag_args(const NoteStore_createTag_args&);
  NoteStore_createTag_args& operator=(const NoteStore_createTag_args&);
  NoteStore_createTag_args() : authenticationToken() {
  }

  virtual ~NoteStore_createTag_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Tag tag;

  _NoteStore_createTag_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_tag(const  ::evernote::edam::Tag& val);

  bool operator == (const NoteStore_createTag_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(tag == rhs.tag))
      return false;
    return true;
  }
  bool operator != (const NoteStore_createTag_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_createTag_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_createTag_pargs {
 public:


  virtual ~NoteStore_createTag_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Tag* tag;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_createTag_result__isset {
  _NoteStore_createTag_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_createTag_result__isset;

class NoteStore_createTag_result {
 public:

  NoteStore_createTag_result(const NoteStore_createTag_result&);
  NoteStore_createTag_result& operator=(const NoteStore_createTag_result&);
  NoteStore_createTag_result() {
  }

  virtual ~NoteStore_createTag_result() throw();
   ::evernote::edam::Tag success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_createTag_result__isset __isset;

  void __set_success(const  ::evernote::edam::Tag& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_createTag_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_createTag_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_createTag_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_createTag_presult__isset {
  _NoteStore_createTag_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_createTag_presult__isset;

class NoteStore_createTag_presult {
 public:


  virtual ~NoteStore_createTag_presult() throw();
   ::evernote::edam::Tag* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_createTag_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_updateTag_args__isset {
  _NoteStore_updateTag_args__isset() : authenticationToken(false), tag(false) {}
  bool authenticationToken :1;
  bool tag :1;
} _NoteStore_updateTag_args__isset;

class NoteStore_updateTag_args {
 public:

  NoteStore_updateTag_args(const NoteStore_updateTag_args&);
  NoteStore_updateTag_args& operator=(const NoteStore_updateTag_args&);
  NoteStore_updateTag_args() : authenticationToken() {
  }

  virtual ~NoteStore_updateTag_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Tag tag;

  _NoteStore_updateTag_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_tag(const  ::evernote::edam::Tag& val);

  bool operator == (const NoteStore_updateTag_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(tag == rhs.tag))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateTag_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateTag_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_updateTag_pargs {
 public:


  virtual ~NoteStore_updateTag_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Tag* tag;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateTag_result__isset {
  _NoteStore_updateTag_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_updateTag_result__isset;

class NoteStore_updateTag_result {
 public:

  NoteStore_updateTag_result(const NoteStore_updateTag_result&);
  NoteStore_updateTag_result& operator=(const NoteStore_updateTag_result&);
  NoteStore_updateTag_result() : success(0) {
  }

  virtual ~NoteStore_updateTag_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_updateTag_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_updateTag_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateTag_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateTag_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateTag_presult__isset {
  _NoteStore_updateTag_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_updateTag_presult__isset;

class NoteStore_updateTag_presult {
 public:


  virtual ~NoteStore_updateTag_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_updateTag_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_untagAll_args__isset {
  _NoteStore_untagAll_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_untagAll_args__isset;

class NoteStore_untagAll_args {
 public:

  NoteStore_untagAll_args(const NoteStore_untagAll_args&);
  NoteStore_untagAll_args& operator=(const NoteStore_untagAll_args&);
  NoteStore_untagAll_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_untagAll_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_untagAll_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_untagAll_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_untagAll_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_untagAll_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_untagAll_pargs {
 public:


  virtual ~NoteStore_untagAll_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_untagAll_result__isset {
  _NoteStore_untagAll_result__isset() : userException(false), systemException(false), notFoundException(false) {}
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_untagAll_result__isset;

class NoteStore_untagAll_result {
 public:

  NoteStore_untagAll_result(const NoteStore_untagAll_result&);
  NoteStore_untagAll_result& operator=(const NoteStore_untagAll_result&);
  NoteStore_untagAll_result() {
  }

  virtual ~NoteStore_untagAll_result() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_untagAll_result__isset __isset;

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_untagAll_result & rhs) const
  {
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_untagAll_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_untagAll_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_untagAll_presult__isset {
  _NoteStore_untagAll_presult__isset() : userException(false), systemException(false), notFoundException(false) {}
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_untagAll_presult__isset;

class NoteStore_untagAll_presult {
 public:


  virtual ~NoteStore_untagAll_presult() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_untagAll_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_expungeTag_args__isset {
  _NoteStore_expungeTag_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_expungeTag_args__isset;

class NoteStore_expungeTag_args {
 public:

  NoteStore_expungeTag_args(const NoteStore_expungeTag_args&);
  NoteStore_expungeTag_args& operator=(const NoteStore_expungeTag_args&);
  NoteStore_expungeTag_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_expungeTag_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_expungeTag_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_expungeTag_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_expungeTag_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_expungeTag_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_expungeTag_pargs {
 public:


  virtual ~NoteStore_expungeTag_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_expungeTag_result__isset {
  _NoteStore_expungeTag_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_expungeTag_result__isset;

class NoteStore_expungeTag_result {
 public:

  NoteStore_expungeTag_result(const NoteStore_expungeTag_result&);
  NoteStore_expungeTag_result& operator=(const NoteStore_expungeTag_result&);
  NoteStore_expungeTag_result() : success(0) {
  }

  virtual ~NoteStore_expungeTag_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_expungeTag_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_expungeTag_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_expungeTag_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_expungeTag_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_expungeTag_presult__isset {
  _NoteStore_expungeTag_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_expungeTag_presult__isset;

class NoteStore_expungeTag_presult {
 public:


  virtual ~NoteStore_expungeTag_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_expungeTag_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_listSearches_args__isset {
  _NoteStore_listSearches_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _NoteStore_listSearches_args__isset;

class NoteStore_listSearches_args {
 public:

  NoteStore_listSearches_args(const NoteStore_listSearches_args&);
  NoteStore_listSearches_args& operator=(const NoteStore_listSearches_args&);
  NoteStore_listSearches_args() : authenticationToken() {
  }

  virtual ~NoteStore_listSearches_args() throw();
  std::string authenticationToken;

  _NoteStore_listSearches_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const NoteStore_listSearches_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listSearches_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listSearches_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_listSearches_pargs {
 public:


  virtual ~NoteStore_listSearches_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listSearches_result__isset {
  _NoteStore_listSearches_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_listSearches_result__isset;

class NoteStore_listSearches_result {
 public:

  NoteStore_listSearches_result(const NoteStore_listSearches_result&);
  NoteStore_listSearches_result& operator=(const NoteStore_listSearches_result&);
  NoteStore_listSearches_result() {
  }

  virtual ~NoteStore_listSearches_result() throw();
  std::vector< ::evernote::edam::SavedSearch>  success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_listSearches_result__isset __isset;

  void __set_success(const std::vector< ::evernote::edam::SavedSearch> & val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_listSearches_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listSearches_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listSearches_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listSearches_presult__isset {
  _NoteStore_listSearches_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_listSearches_presult__isset;

class NoteStore_listSearches_presult {
 public:


  virtual ~NoteStore_listSearches_presult() throw();
  std::vector< ::evernote::edam::SavedSearch> * success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_listSearches_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getSearch_args__isset {
  _NoteStore_getSearch_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_getSearch_args__isset;

class NoteStore_getSearch_args {
 public:

  NoteStore_getSearch_args(const NoteStore_getSearch_args&);
  NoteStore_getSearch_args& operator=(const NoteStore_getSearch_args&);
  NoteStore_getSearch_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_getSearch_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_getSearch_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_getSearch_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getSearch_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getSearch_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getSearch_pargs {
 public:


  virtual ~NoteStore_getSearch_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getSearch_result__isset {
  _NoteStore_getSearch_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getSearch_result__isset;

class NoteStore_getSearch_result {
 public:

  NoteStore_getSearch_result(const NoteStore_getSearch_result&);
  NoteStore_getSearch_result& operator=(const NoteStore_getSearch_result&);
  NoteStore_getSearch_result() {
  }

  virtual ~NoteStore_getSearch_result() throw();
   ::evernote::edam::SavedSearch success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getSearch_result__isset __isset;

  void __set_success(const  ::evernote::edam::SavedSearch& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getSearch_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getSearch_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getSearch_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getSearch_presult__isset {
  _NoteStore_getSearch_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getSearch_presult__isset;

class NoteStore_getSearch_presult {
 public:


  virtual ~NoteStore_getSearch_presult() throw();
   ::evernote::edam::SavedSearch* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getSearch_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_createSearch_args__isset {
  _NoteStore_createSearch_args__isset() : authenticationToken(false), search(false) {}
  bool authenticationToken :1;
  bool search :1;
} _NoteStore_createSearch_args__isset;

class NoteStore_createSearch_args {
 public:

  NoteStore_createSearch_args(const NoteStore_createSearch_args&);
  NoteStore_createSearch_args& operator=(const NoteStore_createSearch_args&);
  NoteStore_createSearch_args() : authenticationToken() {
  }

  virtual ~NoteStore_createSearch_args() throw();
  std::string authenticationToken;
   ::evernote::edam::SavedSearch search;

  _NoteStore_createSearch_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_search(const  ::evernote::edam::SavedSearch& val);

  bool operator == (const NoteStore_createSearch_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(search == rhs.search))
      return false;
    return true;
  }
  bool operator != (const NoteStore_createSearch_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_createSearch_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_createSearch_pargs {
 public:


  virtual ~NoteStore_createSearch_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::SavedSearch* search;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_createSearch_result__isset {
  _NoteStore_createSearch_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_createSearch_result__isset;

class NoteStore_createSearch_result {
 public:

  NoteStore_createSearch_result(const NoteStore_createSearch_result&);
  NoteStore_createSearch_result& operator=(const NoteStore_createSearch_result&);
  NoteStore_createSearch_result() {
  }

  virtual ~NoteStore_createSearch_result() throw();
   ::evernote::edam::SavedSearch success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_createSearch_result__isset __isset;

  void __set_success(const  ::evernote::edam::SavedSearch& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_createSearch_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_createSearch_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_createSearch_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_createSearch_presult__isset {
  _NoteStore_createSearch_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _NoteStore_createSearch_presult__isset;

class NoteStore_createSearch_presult {
 public:


  virtual ~NoteStore_createSearch_presult() throw();
   ::evernote::edam::SavedSearch* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_createSearch_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_updateSearch_args__isset {
  _NoteStore_updateSearch_args__isset() : authenticationToken(false), search(false) {}
  bool authenticationToken :1;
  bool search :1;
} _NoteStore_updateSearch_args__isset;

class NoteStore_updateSearch_args {
 public:

  NoteStore_updateSearch_args(const NoteStore_updateSearch_args&);
  NoteStore_updateSearch_args& operator=(const NoteStore_updateSearch_args&);
  NoteStore_updateSearch_args() : authenticationToken() {
  }

  virtual ~NoteStore_updateSearch_args() throw();
  std::string authenticationToken;
   ::evernote::edam::SavedSearch search;

  _NoteStore_updateSearch_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_search(const  ::evernote::edam::SavedSearch& val);

  bool operator == (const NoteStore_updateSearch_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(search == rhs.search))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateSearch_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateSearch_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_updateSearch_pargs {
 public:


  virtual ~NoteStore_updateSearch_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::SavedSearch* search;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateSearch_result__isset {
  _NoteStore_updateSearch_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_updateSearch_result__isset;

class NoteStore_updateSearch_result {
 public:

  NoteStore_updateSearch_result(const NoteStore_updateSearch_result&);
  NoteStore_updateSearch_result& operator=(const NoteStore_updateSearch_result&);
  NoteStore_updateSearch_result() : success(0) {
  }

  virtual ~NoteStore_updateSearch_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_updateSearch_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_updateSearch_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateSearch_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateSearch_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateSearch_presult__isset {
  _NoteStore_updateSearch_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_updateSearch_presult__isset;

class NoteStore_updateSearch_presult {
 public:


  virtual ~NoteStore_updateSearch_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_updateSearch_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_expungeSearch_args__isset {
  _NoteStore_expungeSearch_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_expungeSearch_args__isset;

class NoteStore_expungeSearch_args {
 public:

  NoteStore_expungeSearch_args(const NoteStore_expungeSearch_args&);
  NoteStore_expungeSearch_args& operator=(const NoteStore_expungeSearch_args&);
  NoteStore_expungeSearch_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_expungeSearch_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_expungeSearch_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_expungeSearch_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_expungeSearch_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_expungeSearch_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_expungeSearch_pargs {
 public:


  virtual ~NoteStore_expungeSearch_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_expungeSearch_result__isset {
  _NoteStore_expungeSearch_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_expungeSearch_result__isset;

class NoteStore_expungeSearch_result {
 public:

  NoteStore_expungeSearch_result(const NoteStore_expungeSearch_result&);
  NoteStore_expungeSearch_result& operator=(const NoteStore_expungeSearch_result&);
  NoteStore_expungeSearch_result() : success(0) {
  }

  virtual ~NoteStore_expungeSearch_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_expungeSearch_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_expungeSearch_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_expungeSearch_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_expungeSearch_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_expungeSearch_presult__isset {
  _NoteStore_expungeSearch_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_expungeSearch_presult__isset;

class NoteStore_expungeSearch_presult {
 public:


  virtual ~NoteStore_expungeSearch_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_expungeSearch_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_findNoteOffset_args__isset {
  _NoteStore_findNoteOffset_args__isset() : authenticationToken(false), filter(false), guid(false) {}
  bool authenticationToken :1;
  bool filter :1;
  bool guid :1;
} _NoteStore_findNoteOffset_args__isset;

class NoteStore_findNoteOffset_args {
 public:

  NoteStore_findNoteOffset_args(const NoteStore_findNoteOffset_args&);
  NoteStore_findNoteOffset_args& operator=(const NoteStore_findNoteOffset_args&);
  NoteStore_findNoteOffset_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_findNoteOffset_args() throw();
  std::string authenticationToken;
  NoteFilter filter;
   ::evernote::edam::Guid guid;

  _NoteStore_findNoteOffset_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_filter(const NoteFilter& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_findNoteOffset_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(filter == rhs.filter))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_findNoteOffset_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_findNoteOffset_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_findNoteOffset_pargs {
 public:


  virtual ~NoteStore_findNoteOffset_pargs() throw();
  const std::string* authenticationToken;
  const NoteFilter* filter;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_findNoteOffset_result__isset {
  _NoteStore_findNoteOffset_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_findNoteOffset_result__isset;

class NoteStore_findNoteOffset_result {
 public:

  NoteStore_findNoteOffset_result(const NoteStore_findNoteOffset_result&);
  NoteStore_findNoteOffset_result& operator=(const NoteStore_findNoteOffset_result&);
  NoteStore_findNoteOffset_result() : success(0) {
  }

  virtual ~NoteStore_findNoteOffset_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_findNoteOffset_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_findNoteOffset_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_findNoteOffset_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_findNoteOffset_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_findNoteOffset_presult__isset {
  _NoteStore_findNoteOffset_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_findNoteOffset_presult__isset;

class NoteStore_findNoteOffset_presult {
 public:


  virtual ~NoteStore_findNoteOffset_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_findNoteOffset_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_findNotesMetadata_args__isset {
  _NoteStore_findNotesMetadata_args__isset() : authenticationToken(false), filter(false), offset(false), maxNotes(false), resultSpec(false) {}
  bool authenticationToken :1;
  bool filter :1;
  bool offset :1;
  bool maxNotes :1;
  bool resultSpec :1;
} _NoteStore_findNotesMetadata_args__isset;

class NoteStore_findNotesMetadata_args {
 public:

  NoteStore_findNotesMetadata_args(const NoteStore_findNotesMetadata_args&);
  NoteStore_findNotesMetadata_args& operator=(const NoteStore_findNotesMetadata_args&);
  NoteStore_findNotesMetadata_args() : authenticationToken(), offset(0), maxNotes(0) {
  }

  virtual ~NoteStore_findNotesMetadata_args() throw();
  std::string authenticationToken;
  NoteFilter filter;
  int32_t offset;
  int32_t maxNotes;
  NotesMetadataResultSpec resultSpec;

  _NoteStore_findNotesMetadata_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_filter(const NoteFilter& val);

  void __set_offset(const int32_t val);

  void __set_maxNotes(const int32_t val);

  void __set_resultSpec(const NotesMetadataResultSpec& val);

  bool operator == (const NoteStore_findNotesMetadata_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(filter == rhs.filter))
      return false;
    if (!(offset == rhs.offset))
      return false;
    if (!(maxNotes == rhs.maxNotes))
      return false;
    if (!(resultSpec == rhs.resultSpec))
      return false;
    return true;
  }
  bool operator != (const NoteStore_findNotesMetadata_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_findNotesMetadata_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_findNotesMetadata_pargs {
 public:


  virtual ~NoteStore_findNotesMetadata_pargs() throw();
  const std::string* authenticationToken;
  const NoteFilter* filter;
  const int32_t* offset;
  const int32_t* maxNotes;
  const NotesMetadataResultSpec* resultSpec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_findNotesMetadata_result__isset {
  _NoteStore_findNotesMetadata_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_findNotesMetadata_result__isset;

class NoteStore_findNotesMetadata_result {
 public:

  NoteStore_findNotesMetadata_result(const NoteStore_findNotesMetadata_result&);
  NoteStore_findNotesMetadata_result& operator=(const NoteStore_findNotesMetadata_result&);
  NoteStore_findNotesMetadata_result() {
  }

  virtual ~NoteStore_findNotesMetadata_result() throw();
  NotesMetadataList success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_findNotesMetadata_result__isset __isset;

  void __set_success(const NotesMetadataList& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_findNotesMetadata_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_findNotesMetadata_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_findNotesMetadata_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_findNotesMetadata_presult__isset {
  _NoteStore_findNotesMetadata_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_findNotesMetadata_presult__isset;

class NoteStore_findNotesMetadata_presult {
 public:


  virtual ~NoteStore_findNotesMetadata_presult() throw();
  NotesMetadataList* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_findNotesMetadata_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_findNoteCounts_args__isset {
  _NoteStore_findNoteCounts_args__isset() : authenticationToken(false), filter(false), withTrash(false) {}
  bool authenticationToken :1;
  bool filter :1;
  bool withTrash :1;
} _NoteStore_findNoteCounts_args__isset;

class NoteStore_findNoteCounts_args {
 public:

  NoteStore_findNoteCounts_args(const NoteStore_findNoteCounts_args&);
  NoteStore_findNoteCounts_args& operator=(const NoteStore_findNoteCounts_args&);
  NoteStore_findNoteCounts_args() : authenticationToken(), withTrash(0) {
  }

  virtual ~NoteStore_findNoteCounts_args() throw();
  std::string authenticationToken;
  NoteFilter filter;
  bool withTrash;

  _NoteStore_findNoteCounts_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_filter(const NoteFilter& val);

  void __set_withTrash(const bool val);

  bool operator == (const NoteStore_findNoteCounts_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(filter == rhs.filter))
      return false;
    if (!(withTrash == rhs.withTrash))
      return false;
    return true;
  }
  bool operator != (const NoteStore_findNoteCounts_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_findNoteCounts_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_findNoteCounts_pargs {
 public:


  virtual ~NoteStore_findNoteCounts_pargs() throw();
  const std::string* authenticationToken;
  const NoteFilter* filter;
  const bool* withTrash;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_findNoteCounts_result__isset {
  _NoteStore_findNoteCounts_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_findNoteCounts_result__isset;

class NoteStore_findNoteCounts_result {
 public:

  NoteStore_findNoteCounts_result(const NoteStore_findNoteCounts_result&);
  NoteStore_findNoteCounts_result& operator=(const NoteStore_findNoteCounts_result&);
  NoteStore_findNoteCounts_result() {
  }

  virtual ~NoteStore_findNoteCounts_result() throw();
  NoteCollectionCounts success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_findNoteCounts_result__isset __isset;

  void __set_success(const NoteCollectionCounts& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_findNoteCounts_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_findNoteCounts_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_findNoteCounts_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_findNoteCounts_presult__isset {
  _NoteStore_findNoteCounts_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_findNoteCounts_presult__isset;

class NoteStore_findNoteCounts_presult {
 public:


  virtual ~NoteStore_findNoteCounts_presult() throw();
  NoteCollectionCounts* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_findNoteCounts_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getNoteWithResultSpec_args__isset {
  _NoteStore_getNoteWithResultSpec_args__isset() : authenticationToken(false), guid(false), resultSpec(false) {}
  bool authenticationToken :1;
  bool guid :1;
  bool resultSpec :1;
} _NoteStore_getNoteWithResultSpec_args__isset;

class NoteStore_getNoteWithResultSpec_args {
 public:

  NoteStore_getNoteWithResultSpec_args(const NoteStore_getNoteWithResultSpec_args&);
  NoteStore_getNoteWithResultSpec_args& operator=(const NoteStore_getNoteWithResultSpec_args&);
  NoteStore_getNoteWithResultSpec_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_getNoteWithResultSpec_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;
  NoteResultSpec resultSpec;

  _NoteStore_getNoteWithResultSpec_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  void __set_resultSpec(const NoteResultSpec& val);

  bool operator == (const NoteStore_getNoteWithResultSpec_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    if (!(resultSpec == rhs.resultSpec))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteWithResultSpec_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteWithResultSpec_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getNoteWithResultSpec_pargs {
 public:


  virtual ~NoteStore_getNoteWithResultSpec_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;
  const NoteResultSpec* resultSpec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteWithResultSpec_result__isset {
  _NoteStore_getNoteWithResultSpec_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteWithResultSpec_result__isset;

class NoteStore_getNoteWithResultSpec_result {
 public:

  NoteStore_getNoteWithResultSpec_result(const NoteStore_getNoteWithResultSpec_result&);
  NoteStore_getNoteWithResultSpec_result& operator=(const NoteStore_getNoteWithResultSpec_result&);
  NoteStore_getNoteWithResultSpec_result() {
  }

  virtual ~NoteStore_getNoteWithResultSpec_result() throw();
   ::evernote::edam::Note success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteWithResultSpec_result__isset __isset;

  void __set_success(const  ::evernote::edam::Note& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getNoteWithResultSpec_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteWithResultSpec_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteWithResultSpec_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteWithResultSpec_presult__isset {
  _NoteStore_getNoteWithResultSpec_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteWithResultSpec_presult__isset;

class NoteStore_getNoteWithResultSpec_presult {
 public:


  virtual ~NoteStore_getNoteWithResultSpec_presult() throw();
   ::evernote::edam::Note* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteWithResultSpec_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getNote_args__isset {
  _NoteStore_getNote_args__isset() : authenticationToken(false), guid(false), withContent(false), withResourcesData(false), withResourcesRecognition(false), withResourcesAlternateData(false) {}
  bool authenticationToken :1;
  bool guid :1;
  bool withContent :1;
  bool withResourcesData :1;
  bool withResourcesRecognition :1;
  bool withResourcesAlternateData :1;
} _NoteStore_getNote_args__isset;

class NoteStore_getNote_args {
 public:

  NoteStore_getNote_args(const NoteStore_getNote_args&);
  NoteStore_getNote_args& operator=(const NoteStore_getNote_args&);
  NoteStore_getNote_args() : authenticationToken(), guid(), withContent(0), withResourcesData(0), withResourcesRecognition(0), withResourcesAlternateData(0) {
  }

  virtual ~NoteStore_getNote_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;
  bool withContent;
  bool withResourcesData;
  bool withResourcesRecognition;
  bool withResourcesAlternateData;

  _NoteStore_getNote_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  void __set_withContent(const bool val);

  void __set_withResourcesData(const bool val);

  void __set_withResourcesRecognition(const bool val);

  void __set_withResourcesAlternateData(const bool val);

  bool operator == (const NoteStore_getNote_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    if (!(withContent == rhs.withContent))
      return false;
    if (!(withResourcesData == rhs.withResourcesData))
      return false;
    if (!(withResourcesRecognition == rhs.withResourcesRecognition))
      return false;
    if (!(withResourcesAlternateData == rhs.withResourcesAlternateData))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNote_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNote_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getNote_pargs {
 public:


  virtual ~NoteStore_getNote_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;
  const bool* withContent;
  const bool* withResourcesData;
  const bool* withResourcesRecognition;
  const bool* withResourcesAlternateData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNote_result__isset {
  _NoteStore_getNote_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNote_result__isset;

class NoteStore_getNote_result {
 public:

  NoteStore_getNote_result(const NoteStore_getNote_result&);
  NoteStore_getNote_result& operator=(const NoteStore_getNote_result&);
  NoteStore_getNote_result() {
  }

  virtual ~NoteStore_getNote_result() throw();
   ::evernote::edam::Note success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNote_result__isset __isset;

  void __set_success(const  ::evernote::edam::Note& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getNote_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNote_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNote_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNote_presult__isset {
  _NoteStore_getNote_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNote_presult__isset;

class NoteStore_getNote_presult {
 public:


  virtual ~NoteStore_getNote_presult() throw();
   ::evernote::edam::Note* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNote_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getNoteApplicationData_args__isset {
  _NoteStore_getNoteApplicationData_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_getNoteApplicationData_args__isset;

class NoteStore_getNoteApplicationData_args {
 public:

  NoteStore_getNoteApplicationData_args(const NoteStore_getNoteApplicationData_args&);
  NoteStore_getNoteApplicationData_args& operator=(const NoteStore_getNoteApplicationData_args&);
  NoteStore_getNoteApplicationData_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_getNoteApplicationData_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_getNoteApplicationData_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_getNoteApplicationData_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteApplicationData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteApplicationData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getNoteApplicationData_pargs {
 public:


  virtual ~NoteStore_getNoteApplicationData_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteApplicationData_result__isset {
  _NoteStore_getNoteApplicationData_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteApplicationData_result__isset;

class NoteStore_getNoteApplicationData_result {
 public:

  NoteStore_getNoteApplicationData_result(const NoteStore_getNoteApplicationData_result&);
  NoteStore_getNoteApplicationData_result& operator=(const NoteStore_getNoteApplicationData_result&);
  NoteStore_getNoteApplicationData_result() {
  }

  virtual ~NoteStore_getNoteApplicationData_result() throw();
   ::evernote::edam::LazyMap success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteApplicationData_result__isset __isset;

  void __set_success(const  ::evernote::edam::LazyMap& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getNoteApplicationData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteApplicationData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteApplicationData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteApplicationData_presult__isset {
  _NoteStore_getNoteApplicationData_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteApplicationData_presult__isset;

class NoteStore_getNoteApplicationData_presult {
 public:


  virtual ~NoteStore_getNoteApplicationData_presult() throw();
   ::evernote::edam::LazyMap* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteApplicationData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getNoteApplicationDataEntry_args__isset {
  _NoteStore_getNoteApplicationDataEntry_args__isset() : authenticationToken(false), guid(false), key(false) {}
  bool authenticationToken :1;
  bool guid :1;
  bool key :1;
} _NoteStore_getNoteApplicationDataEntry_args__isset;

class NoteStore_getNoteApplicationDataEntry_args {
 public:

  NoteStore_getNoteApplicationDataEntry_args(const NoteStore_getNoteApplicationDataEntry_args&);
  NoteStore_getNoteApplicationDataEntry_args& operator=(const NoteStore_getNoteApplicationDataEntry_args&);
  NoteStore_getNoteApplicationDataEntry_args() : authenticationToken(), guid(), key() {
  }

  virtual ~NoteStore_getNoteApplicationDataEntry_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;
  std::string key;

  _NoteStore_getNoteApplicationDataEntry_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  void __set_key(const std::string& val);

  bool operator == (const NoteStore_getNoteApplicationDataEntry_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    if (!(key == rhs.key))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteApplicationDataEntry_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteApplicationDataEntry_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getNoteApplicationDataEntry_pargs {
 public:


  virtual ~NoteStore_getNoteApplicationDataEntry_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;
  const std::string* key;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteApplicationDataEntry_result__isset {
  _NoteStore_getNoteApplicationDataEntry_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteApplicationDataEntry_result__isset;

class NoteStore_getNoteApplicationDataEntry_result {
 public:

  NoteStore_getNoteApplicationDataEntry_result(const NoteStore_getNoteApplicationDataEntry_result&);
  NoteStore_getNoteApplicationDataEntry_result& operator=(const NoteStore_getNoteApplicationDataEntry_result&);
  NoteStore_getNoteApplicationDataEntry_result() : success() {
  }

  virtual ~NoteStore_getNoteApplicationDataEntry_result() throw();
  std::string success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteApplicationDataEntry_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getNoteApplicationDataEntry_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteApplicationDataEntry_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteApplicationDataEntry_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteApplicationDataEntry_presult__isset {
  _NoteStore_getNoteApplicationDataEntry_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteApplicationDataEntry_presult__isset;

class NoteStore_getNoteApplicationDataEntry_presult {
 public:


  virtual ~NoteStore_getNoteApplicationDataEntry_presult() throw();
  std::string* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteApplicationDataEntry_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_setNoteApplicationDataEntry_args__isset {
  _NoteStore_setNoteApplicationDataEntry_args__isset() : authenticationToken(false), guid(false), key(false), value(false) {}
  bool authenticationToken :1;
  bool guid :1;
  bool key :1;
  bool value :1;
} _NoteStore_setNoteApplicationDataEntry_args__isset;

class NoteStore_setNoteApplicationDataEntry_args {
 public:

  NoteStore_setNoteApplicationDataEntry_args(const NoteStore_setNoteApplicationDataEntry_args&);
  NoteStore_setNoteApplicationDataEntry_args& operator=(const NoteStore_setNoteApplicationDataEntry_args&);
  NoteStore_setNoteApplicationDataEntry_args() : authenticationToken(), guid(), key(), value() {
  }

  virtual ~NoteStore_setNoteApplicationDataEntry_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;
  std::string key;
  std::string value;

  _NoteStore_setNoteApplicationDataEntry_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  void __set_key(const std::string& val);

  void __set_value(const std::string& val);

  bool operator == (const NoteStore_setNoteApplicationDataEntry_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const NoteStore_setNoteApplicationDataEntry_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_setNoteApplicationDataEntry_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_setNoteApplicationDataEntry_pargs {
 public:


  virtual ~NoteStore_setNoteApplicationDataEntry_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;
  const std::string* key;
  const std::string* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_setNoteApplicationDataEntry_result__isset {
  _NoteStore_setNoteApplicationDataEntry_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_setNoteApplicationDataEntry_result__isset;

class NoteStore_setNoteApplicationDataEntry_result {
 public:

  NoteStore_setNoteApplicationDataEntry_result(const NoteStore_setNoteApplicationDataEntry_result&);
  NoteStore_setNoteApplicationDataEntry_result& operator=(const NoteStore_setNoteApplicationDataEntry_result&);
  NoteStore_setNoteApplicationDataEntry_result() : success(0) {
  }

  virtual ~NoteStore_setNoteApplicationDataEntry_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_setNoteApplicationDataEntry_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_setNoteApplicationDataEntry_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_setNoteApplicationDataEntry_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_setNoteApplicationDataEntry_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_setNoteApplicationDataEntry_presult__isset {
  _NoteStore_setNoteApplicationDataEntry_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_setNoteApplicationDataEntry_presult__isset;

class NoteStore_setNoteApplicationDataEntry_presult {
 public:


  virtual ~NoteStore_setNoteApplicationDataEntry_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_setNoteApplicationDataEntry_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_unsetNoteApplicationDataEntry_args__isset {
  _NoteStore_unsetNoteApplicationDataEntry_args__isset() : authenticationToken(false), guid(false), key(false) {}
  bool authenticationToken :1;
  bool guid :1;
  bool key :1;
} _NoteStore_unsetNoteApplicationDataEntry_args__isset;

class NoteStore_unsetNoteApplicationDataEntry_args {
 public:

  NoteStore_unsetNoteApplicationDataEntry_args(const NoteStore_unsetNoteApplicationDataEntry_args&);
  NoteStore_unsetNoteApplicationDataEntry_args& operator=(const NoteStore_unsetNoteApplicationDataEntry_args&);
  NoteStore_unsetNoteApplicationDataEntry_args() : authenticationToken(), guid(), key() {
  }

  virtual ~NoteStore_unsetNoteApplicationDataEntry_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;
  std::string key;

  _NoteStore_unsetNoteApplicationDataEntry_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  void __set_key(const std::string& val);

  bool operator == (const NoteStore_unsetNoteApplicationDataEntry_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    if (!(key == rhs.key))
      return false;
    return true;
  }
  bool operator != (const NoteStore_unsetNoteApplicationDataEntry_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_unsetNoteApplicationDataEntry_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_unsetNoteApplicationDataEntry_pargs {
 public:


  virtual ~NoteStore_unsetNoteApplicationDataEntry_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;
  const std::string* key;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_unsetNoteApplicationDataEntry_result__isset {
  _NoteStore_unsetNoteApplicationDataEntry_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_unsetNoteApplicationDataEntry_result__isset;

class NoteStore_unsetNoteApplicationDataEntry_result {
 public:

  NoteStore_unsetNoteApplicationDataEntry_result(const NoteStore_unsetNoteApplicationDataEntry_result&);
  NoteStore_unsetNoteApplicationDataEntry_result& operator=(const NoteStore_unsetNoteApplicationDataEntry_result&);
  NoteStore_unsetNoteApplicationDataEntry_result() : success(0) {
  }

  virtual ~NoteStore_unsetNoteApplicationDataEntry_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_unsetNoteApplicationDataEntry_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_unsetNoteApplicationDataEntry_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_unsetNoteApplicationDataEntry_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_unsetNoteApplicationDataEntry_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_unsetNoteApplicationDataEntry_presult__isset {
  _NoteStore_unsetNoteApplicationDataEntry_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_unsetNoteApplicationDataEntry_presult__isset;

class NoteStore_unsetNoteApplicationDataEntry_presult {
 public:


  virtual ~NoteStore_unsetNoteApplicationDataEntry_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_unsetNoteApplicationDataEntry_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getNoteContent_args__isset {
  _NoteStore_getNoteContent_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_getNoteContent_args__isset;

class NoteStore_getNoteContent_args {
 public:

  NoteStore_getNoteContent_args(const NoteStore_getNoteContent_args&);
  NoteStore_getNoteContent_args& operator=(const NoteStore_getNoteContent_args&);
  NoteStore_getNoteContent_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_getNoteContent_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_getNoteContent_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_getNoteContent_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteContent_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteContent_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getNoteContent_pargs {
 public:


  virtual ~NoteStore_getNoteContent_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteContent_result__isset {
  _NoteStore_getNoteContent_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteContent_result__isset;

class NoteStore_getNoteContent_result {
 public:

  NoteStore_getNoteContent_result(const NoteStore_getNoteContent_result&);
  NoteStore_getNoteContent_result& operator=(const NoteStore_getNoteContent_result&);
  NoteStore_getNoteContent_result() : success() {
  }

  virtual ~NoteStore_getNoteContent_result() throw();
  std::string success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteContent_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getNoteContent_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteContent_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteContent_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteContent_presult__isset {
  _NoteStore_getNoteContent_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteContent_presult__isset;

class NoteStore_getNoteContent_presult {
 public:


  virtual ~NoteStore_getNoteContent_presult() throw();
  std::string* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteContent_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getNoteSearchText_args__isset {
  _NoteStore_getNoteSearchText_args__isset() : authenticationToken(false), guid(false), noteOnly(false), tokenizeForIndexing(false) {}
  bool authenticationToken :1;
  bool guid :1;
  bool noteOnly :1;
  bool tokenizeForIndexing :1;
} _NoteStore_getNoteSearchText_args__isset;

class NoteStore_getNoteSearchText_args {
 public:

  NoteStore_getNoteSearchText_args(const NoteStore_getNoteSearchText_args&);
  NoteStore_getNoteSearchText_args& operator=(const NoteStore_getNoteSearchText_args&);
  NoteStore_getNoteSearchText_args() : authenticationToken(), guid(), noteOnly(0), tokenizeForIndexing(0) {
  }

  virtual ~NoteStore_getNoteSearchText_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;
  bool noteOnly;
  bool tokenizeForIndexing;

  _NoteStore_getNoteSearchText_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  void __set_noteOnly(const bool val);

  void __set_tokenizeForIndexing(const bool val);

  bool operator == (const NoteStore_getNoteSearchText_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    if (!(noteOnly == rhs.noteOnly))
      return false;
    if (!(tokenizeForIndexing == rhs.tokenizeForIndexing))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteSearchText_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteSearchText_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getNoteSearchText_pargs {
 public:


  virtual ~NoteStore_getNoteSearchText_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;
  const bool* noteOnly;
  const bool* tokenizeForIndexing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteSearchText_result__isset {
  _NoteStore_getNoteSearchText_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteSearchText_result__isset;

class NoteStore_getNoteSearchText_result {
 public:

  NoteStore_getNoteSearchText_result(const NoteStore_getNoteSearchText_result&);
  NoteStore_getNoteSearchText_result& operator=(const NoteStore_getNoteSearchText_result&);
  NoteStore_getNoteSearchText_result() : success() {
  }

  virtual ~NoteStore_getNoteSearchText_result() throw();
  std::string success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteSearchText_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getNoteSearchText_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteSearchText_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteSearchText_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteSearchText_presult__isset {
  _NoteStore_getNoteSearchText_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteSearchText_presult__isset;

class NoteStore_getNoteSearchText_presult {
 public:


  virtual ~NoteStore_getNoteSearchText_presult() throw();
  std::string* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteSearchText_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getResourceSearchText_args__isset {
  _NoteStore_getResourceSearchText_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_getResourceSearchText_args__isset;

class NoteStore_getResourceSearchText_args {
 public:

  NoteStore_getResourceSearchText_args(const NoteStore_getResourceSearchText_args&);
  NoteStore_getResourceSearchText_args& operator=(const NoteStore_getResourceSearchText_args&);
  NoteStore_getResourceSearchText_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_getResourceSearchText_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_getResourceSearchText_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_getResourceSearchText_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceSearchText_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceSearchText_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getResourceSearchText_pargs {
 public:


  virtual ~NoteStore_getResourceSearchText_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceSearchText_result__isset {
  _NoteStore_getResourceSearchText_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceSearchText_result__isset;

class NoteStore_getResourceSearchText_result {
 public:

  NoteStore_getResourceSearchText_result(const NoteStore_getResourceSearchText_result&);
  NoteStore_getResourceSearchText_result& operator=(const NoteStore_getResourceSearchText_result&);
  NoteStore_getResourceSearchText_result() : success() {
  }

  virtual ~NoteStore_getResourceSearchText_result() throw();
  std::string success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceSearchText_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getResourceSearchText_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceSearchText_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceSearchText_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceSearchText_presult__isset {
  _NoteStore_getResourceSearchText_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceSearchText_presult__isset;

class NoteStore_getResourceSearchText_presult {
 public:


  virtual ~NoteStore_getResourceSearchText_presult() throw();
  std::string* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceSearchText_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getNoteTagNames_args__isset {
  _NoteStore_getNoteTagNames_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_getNoteTagNames_args__isset;

class NoteStore_getNoteTagNames_args {
 public:

  NoteStore_getNoteTagNames_args(const NoteStore_getNoteTagNames_args&);
  NoteStore_getNoteTagNames_args& operator=(const NoteStore_getNoteTagNames_args&);
  NoteStore_getNoteTagNames_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_getNoteTagNames_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_getNoteTagNames_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_getNoteTagNames_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteTagNames_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteTagNames_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getNoteTagNames_pargs {
 public:


  virtual ~NoteStore_getNoteTagNames_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteTagNames_result__isset {
  _NoteStore_getNoteTagNames_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteTagNames_result__isset;

class NoteStore_getNoteTagNames_result {
 public:

  NoteStore_getNoteTagNames_result(const NoteStore_getNoteTagNames_result&);
  NoteStore_getNoteTagNames_result& operator=(const NoteStore_getNoteTagNames_result&);
  NoteStore_getNoteTagNames_result() {
  }

  virtual ~NoteStore_getNoteTagNames_result() throw();
  std::vector<std::string>  success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteTagNames_result__isset __isset;

  void __set_success(const std::vector<std::string> & val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getNoteTagNames_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteTagNames_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteTagNames_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteTagNames_presult__isset {
  _NoteStore_getNoteTagNames_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteTagNames_presult__isset;

class NoteStore_getNoteTagNames_presult {
 public:


  virtual ~NoteStore_getNoteTagNames_presult() throw();
  std::vector<std::string> * success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteTagNames_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_createNote_args__isset {
  _NoteStore_createNote_args__isset() : authenticationToken(false), note(false) {}
  bool authenticationToken :1;
  bool note :1;
} _NoteStore_createNote_args__isset;

class NoteStore_createNote_args {
 public:

  NoteStore_createNote_args(const NoteStore_createNote_args&);
  NoteStore_createNote_args& operator=(const NoteStore_createNote_args&);
  NoteStore_createNote_args() : authenticationToken() {
  }

  virtual ~NoteStore_createNote_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Note note;

  _NoteStore_createNote_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_note(const  ::evernote::edam::Note& val);

  bool operator == (const NoteStore_createNote_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(note == rhs.note))
      return false;
    return true;
  }
  bool operator != (const NoteStore_createNote_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_createNote_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_createNote_pargs {
 public:


  virtual ~NoteStore_createNote_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Note* note;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_createNote_result__isset {
  _NoteStore_createNote_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_createNote_result__isset;

class NoteStore_createNote_result {
 public:

  NoteStore_createNote_result(const NoteStore_createNote_result&);
  NoteStore_createNote_result& operator=(const NoteStore_createNote_result&);
  NoteStore_createNote_result() {
  }

  virtual ~NoteStore_createNote_result() throw();
   ::evernote::edam::Note success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_createNote_result__isset __isset;

  void __set_success(const  ::evernote::edam::Note& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_createNote_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_createNote_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_createNote_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_createNote_presult__isset {
  _NoteStore_createNote_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_createNote_presult__isset;

class NoteStore_createNote_presult {
 public:


  virtual ~NoteStore_createNote_presult() throw();
   ::evernote::edam::Note* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_createNote_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_updateNote_args__isset {
  _NoteStore_updateNote_args__isset() : authenticationToken(false), note(false) {}
  bool authenticationToken :1;
  bool note :1;
} _NoteStore_updateNote_args__isset;

class NoteStore_updateNote_args {
 public:

  NoteStore_updateNote_args(const NoteStore_updateNote_args&);
  NoteStore_updateNote_args& operator=(const NoteStore_updateNote_args&);
  NoteStore_updateNote_args() : authenticationToken() {
  }

  virtual ~NoteStore_updateNote_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Note note;

  _NoteStore_updateNote_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_note(const  ::evernote::edam::Note& val);

  bool operator == (const NoteStore_updateNote_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(note == rhs.note))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateNote_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateNote_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_updateNote_pargs {
 public:


  virtual ~NoteStore_updateNote_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Note* note;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateNote_result__isset {
  _NoteStore_updateNote_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_updateNote_result__isset;

class NoteStore_updateNote_result {
 public:

  NoteStore_updateNote_result(const NoteStore_updateNote_result&);
  NoteStore_updateNote_result& operator=(const NoteStore_updateNote_result&);
  NoteStore_updateNote_result() {
  }

  virtual ~NoteStore_updateNote_result() throw();
   ::evernote::edam::Note success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_updateNote_result__isset __isset;

  void __set_success(const  ::evernote::edam::Note& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_updateNote_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateNote_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateNote_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateNote_presult__isset {
  _NoteStore_updateNote_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_updateNote_presult__isset;

class NoteStore_updateNote_presult {
 public:


  virtual ~NoteStore_updateNote_presult() throw();
   ::evernote::edam::Note* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_updateNote_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_deleteNote_args__isset {
  _NoteStore_deleteNote_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_deleteNote_args__isset;

class NoteStore_deleteNote_args {
 public:

  NoteStore_deleteNote_args(const NoteStore_deleteNote_args&);
  NoteStore_deleteNote_args& operator=(const NoteStore_deleteNote_args&);
  NoteStore_deleteNote_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_deleteNote_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_deleteNote_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_deleteNote_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_deleteNote_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_deleteNote_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_deleteNote_pargs {
 public:


  virtual ~NoteStore_deleteNote_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_deleteNote_result__isset {
  _NoteStore_deleteNote_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_deleteNote_result__isset;

class NoteStore_deleteNote_result {
 public:

  NoteStore_deleteNote_result(const NoteStore_deleteNote_result&);
  NoteStore_deleteNote_result& operator=(const NoteStore_deleteNote_result&);
  NoteStore_deleteNote_result() : success(0) {
  }

  virtual ~NoteStore_deleteNote_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_deleteNote_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_deleteNote_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_deleteNote_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_deleteNote_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_deleteNote_presult__isset {
  _NoteStore_deleteNote_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_deleteNote_presult__isset;

class NoteStore_deleteNote_presult {
 public:


  virtual ~NoteStore_deleteNote_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_deleteNote_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_expungeNote_args__isset {
  _NoteStore_expungeNote_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_expungeNote_args__isset;

class NoteStore_expungeNote_args {
 public:

  NoteStore_expungeNote_args(const NoteStore_expungeNote_args&);
  NoteStore_expungeNote_args& operator=(const NoteStore_expungeNote_args&);
  NoteStore_expungeNote_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_expungeNote_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_expungeNote_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_expungeNote_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_expungeNote_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_expungeNote_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_expungeNote_pargs {
 public:


  virtual ~NoteStore_expungeNote_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_expungeNote_result__isset {
  _NoteStore_expungeNote_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_expungeNote_result__isset;

class NoteStore_expungeNote_result {
 public:

  NoteStore_expungeNote_result(const NoteStore_expungeNote_result&);
  NoteStore_expungeNote_result& operator=(const NoteStore_expungeNote_result&);
  NoteStore_expungeNote_result() : success(0) {
  }

  virtual ~NoteStore_expungeNote_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_expungeNote_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_expungeNote_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_expungeNote_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_expungeNote_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_expungeNote_presult__isset {
  _NoteStore_expungeNote_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_expungeNote_presult__isset;

class NoteStore_expungeNote_presult {
 public:


  virtual ~NoteStore_expungeNote_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_expungeNote_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_copyNote_args__isset {
  _NoteStore_copyNote_args__isset() : authenticationToken(false), noteGuid(false), toNotebookGuid(false) {}
  bool authenticationToken :1;
  bool noteGuid :1;
  bool toNotebookGuid :1;
} _NoteStore_copyNote_args__isset;

class NoteStore_copyNote_args {
 public:

  NoteStore_copyNote_args(const NoteStore_copyNote_args&);
  NoteStore_copyNote_args& operator=(const NoteStore_copyNote_args&);
  NoteStore_copyNote_args() : authenticationToken(), noteGuid(), toNotebookGuid() {
  }

  virtual ~NoteStore_copyNote_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid noteGuid;
   ::evernote::edam::Guid toNotebookGuid;

  _NoteStore_copyNote_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_noteGuid(const  ::evernote::edam::Guid& val);

  void __set_toNotebookGuid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_copyNote_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(noteGuid == rhs.noteGuid))
      return false;
    if (!(toNotebookGuid == rhs.toNotebookGuid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_copyNote_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_copyNote_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_copyNote_pargs {
 public:


  virtual ~NoteStore_copyNote_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* noteGuid;
  const  ::evernote::edam::Guid* toNotebookGuid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_copyNote_result__isset {
  _NoteStore_copyNote_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_copyNote_result__isset;

class NoteStore_copyNote_result {
 public:

  NoteStore_copyNote_result(const NoteStore_copyNote_result&);
  NoteStore_copyNote_result& operator=(const NoteStore_copyNote_result&);
  NoteStore_copyNote_result() {
  }

  virtual ~NoteStore_copyNote_result() throw();
   ::evernote::edam::Note success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_copyNote_result__isset __isset;

  void __set_success(const  ::evernote::edam::Note& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_copyNote_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_copyNote_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_copyNote_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_copyNote_presult__isset {
  _NoteStore_copyNote_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_copyNote_presult__isset;

class NoteStore_copyNote_presult {
 public:


  virtual ~NoteStore_copyNote_presult() throw();
   ::evernote::edam::Note* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_copyNote_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_listNoteVersions_args__isset {
  _NoteStore_listNoteVersions_args__isset() : authenticationToken(false), noteGuid(false) {}
  bool authenticationToken :1;
  bool noteGuid :1;
} _NoteStore_listNoteVersions_args__isset;

class NoteStore_listNoteVersions_args {
 public:

  NoteStore_listNoteVersions_args(const NoteStore_listNoteVersions_args&);
  NoteStore_listNoteVersions_args& operator=(const NoteStore_listNoteVersions_args&);
  NoteStore_listNoteVersions_args() : authenticationToken(), noteGuid() {
  }

  virtual ~NoteStore_listNoteVersions_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid noteGuid;

  _NoteStore_listNoteVersions_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_noteGuid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_listNoteVersions_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(noteGuid == rhs.noteGuid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listNoteVersions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listNoteVersions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_listNoteVersions_pargs {
 public:


  virtual ~NoteStore_listNoteVersions_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* noteGuid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listNoteVersions_result__isset {
  _NoteStore_listNoteVersions_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_listNoteVersions_result__isset;

class NoteStore_listNoteVersions_result {
 public:

  NoteStore_listNoteVersions_result(const NoteStore_listNoteVersions_result&);
  NoteStore_listNoteVersions_result& operator=(const NoteStore_listNoteVersions_result&);
  NoteStore_listNoteVersions_result() {
  }

  virtual ~NoteStore_listNoteVersions_result() throw();
  std::vector<NoteVersionId>  success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_listNoteVersions_result__isset __isset;

  void __set_success(const std::vector<NoteVersionId> & val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_listNoteVersions_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listNoteVersions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listNoteVersions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listNoteVersions_presult__isset {
  _NoteStore_listNoteVersions_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_listNoteVersions_presult__isset;

class NoteStore_listNoteVersions_presult {
 public:


  virtual ~NoteStore_listNoteVersions_presult() throw();
  std::vector<NoteVersionId> * success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_listNoteVersions_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getNoteVersion_args__isset {
  _NoteStore_getNoteVersion_args__isset() : authenticationToken(false), noteGuid(false), updateSequenceNum(false), withResourcesData(false), withResourcesRecognition(false), withResourcesAlternateData(false) {}
  bool authenticationToken :1;
  bool noteGuid :1;
  bool updateSequenceNum :1;
  bool withResourcesData :1;
  bool withResourcesRecognition :1;
  bool withResourcesAlternateData :1;
} _NoteStore_getNoteVersion_args__isset;

class NoteStore_getNoteVersion_args {
 public:

  NoteStore_getNoteVersion_args(const NoteStore_getNoteVersion_args&);
  NoteStore_getNoteVersion_args& operator=(const NoteStore_getNoteVersion_args&);
  NoteStore_getNoteVersion_args() : authenticationToken(), noteGuid(), updateSequenceNum(0), withResourcesData(0), withResourcesRecognition(0), withResourcesAlternateData(0) {
  }

  virtual ~NoteStore_getNoteVersion_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid noteGuid;
  int32_t updateSequenceNum;
  bool withResourcesData;
  bool withResourcesRecognition;
  bool withResourcesAlternateData;

  _NoteStore_getNoteVersion_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_noteGuid(const  ::evernote::edam::Guid& val);

  void __set_updateSequenceNum(const int32_t val);

  void __set_withResourcesData(const bool val);

  void __set_withResourcesRecognition(const bool val);

  void __set_withResourcesAlternateData(const bool val);

  bool operator == (const NoteStore_getNoteVersion_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(noteGuid == rhs.noteGuid))
      return false;
    if (!(updateSequenceNum == rhs.updateSequenceNum))
      return false;
    if (!(withResourcesData == rhs.withResourcesData))
      return false;
    if (!(withResourcesRecognition == rhs.withResourcesRecognition))
      return false;
    if (!(withResourcesAlternateData == rhs.withResourcesAlternateData))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteVersion_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteVersion_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getNoteVersion_pargs {
 public:


  virtual ~NoteStore_getNoteVersion_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* noteGuid;
  const int32_t* updateSequenceNum;
  const bool* withResourcesData;
  const bool* withResourcesRecognition;
  const bool* withResourcesAlternateData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteVersion_result__isset {
  _NoteStore_getNoteVersion_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteVersion_result__isset;

class NoteStore_getNoteVersion_result {
 public:

  NoteStore_getNoteVersion_result(const NoteStore_getNoteVersion_result&);
  NoteStore_getNoteVersion_result& operator=(const NoteStore_getNoteVersion_result&);
  NoteStore_getNoteVersion_result() {
  }

  virtual ~NoteStore_getNoteVersion_result() throw();
   ::evernote::edam::Note success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteVersion_result__isset __isset;

  void __set_success(const  ::evernote::edam::Note& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getNoteVersion_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNoteVersion_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNoteVersion_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNoteVersion_presult__isset {
  _NoteStore_getNoteVersion_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getNoteVersion_presult__isset;

class NoteStore_getNoteVersion_presult {
 public:


  virtual ~NoteStore_getNoteVersion_presult() throw();
   ::evernote::edam::Note* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getNoteVersion_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getResource_args__isset {
  _NoteStore_getResource_args__isset() : authenticationToken(false), guid(false), withData(false), withRecognition(false), withAttributes(false), withAlternateData(false) {}
  bool authenticationToken :1;
  bool guid :1;
  bool withData :1;
  bool withRecognition :1;
  bool withAttributes :1;
  bool withAlternateData :1;
} _NoteStore_getResource_args__isset;

class NoteStore_getResource_args {
 public:

  NoteStore_getResource_args(const NoteStore_getResource_args&);
  NoteStore_getResource_args& operator=(const NoteStore_getResource_args&);
  NoteStore_getResource_args() : authenticationToken(), guid(), withData(0), withRecognition(0), withAttributes(0), withAlternateData(0) {
  }

  virtual ~NoteStore_getResource_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;
  bool withData;
  bool withRecognition;
  bool withAttributes;
  bool withAlternateData;

  _NoteStore_getResource_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  void __set_withData(const bool val);

  void __set_withRecognition(const bool val);

  void __set_withAttributes(const bool val);

  void __set_withAlternateData(const bool val);

  bool operator == (const NoteStore_getResource_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    if (!(withData == rhs.withData))
      return false;
    if (!(withRecognition == rhs.withRecognition))
      return false;
    if (!(withAttributes == rhs.withAttributes))
      return false;
    if (!(withAlternateData == rhs.withAlternateData))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResource_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResource_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getResource_pargs {
 public:


  virtual ~NoteStore_getResource_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;
  const bool* withData;
  const bool* withRecognition;
  const bool* withAttributes;
  const bool* withAlternateData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResource_result__isset {
  _NoteStore_getResource_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResource_result__isset;

class NoteStore_getResource_result {
 public:

  NoteStore_getResource_result(const NoteStore_getResource_result&);
  NoteStore_getResource_result& operator=(const NoteStore_getResource_result&);
  NoteStore_getResource_result() {
  }

  virtual ~NoteStore_getResource_result() throw();
   ::evernote::edam::Resource success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResource_result__isset __isset;

  void __set_success(const  ::evernote::edam::Resource& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getResource_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResource_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResource_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResource_presult__isset {
  _NoteStore_getResource_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResource_presult__isset;

class NoteStore_getResource_presult {
 public:


  virtual ~NoteStore_getResource_presult() throw();
   ::evernote::edam::Resource* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResource_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getResourceApplicationData_args__isset {
  _NoteStore_getResourceApplicationData_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_getResourceApplicationData_args__isset;

class NoteStore_getResourceApplicationData_args {
 public:

  NoteStore_getResourceApplicationData_args(const NoteStore_getResourceApplicationData_args&);
  NoteStore_getResourceApplicationData_args& operator=(const NoteStore_getResourceApplicationData_args&);
  NoteStore_getResourceApplicationData_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_getResourceApplicationData_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_getResourceApplicationData_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_getResourceApplicationData_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceApplicationData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceApplicationData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getResourceApplicationData_pargs {
 public:


  virtual ~NoteStore_getResourceApplicationData_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceApplicationData_result__isset {
  _NoteStore_getResourceApplicationData_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceApplicationData_result__isset;

class NoteStore_getResourceApplicationData_result {
 public:

  NoteStore_getResourceApplicationData_result(const NoteStore_getResourceApplicationData_result&);
  NoteStore_getResourceApplicationData_result& operator=(const NoteStore_getResourceApplicationData_result&);
  NoteStore_getResourceApplicationData_result() {
  }

  virtual ~NoteStore_getResourceApplicationData_result() throw();
   ::evernote::edam::LazyMap success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceApplicationData_result__isset __isset;

  void __set_success(const  ::evernote::edam::LazyMap& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getResourceApplicationData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceApplicationData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceApplicationData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceApplicationData_presult__isset {
  _NoteStore_getResourceApplicationData_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceApplicationData_presult__isset;

class NoteStore_getResourceApplicationData_presult {
 public:


  virtual ~NoteStore_getResourceApplicationData_presult() throw();
   ::evernote::edam::LazyMap* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceApplicationData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getResourceApplicationDataEntry_args__isset {
  _NoteStore_getResourceApplicationDataEntry_args__isset() : authenticationToken(false), guid(false), key(false) {}
  bool authenticationToken :1;
  bool guid :1;
  bool key :1;
} _NoteStore_getResourceApplicationDataEntry_args__isset;

class NoteStore_getResourceApplicationDataEntry_args {
 public:

  NoteStore_getResourceApplicationDataEntry_args(const NoteStore_getResourceApplicationDataEntry_args&);
  NoteStore_getResourceApplicationDataEntry_args& operator=(const NoteStore_getResourceApplicationDataEntry_args&);
  NoteStore_getResourceApplicationDataEntry_args() : authenticationToken(), guid(), key() {
  }

  virtual ~NoteStore_getResourceApplicationDataEntry_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;
  std::string key;

  _NoteStore_getResourceApplicationDataEntry_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  void __set_key(const std::string& val);

  bool operator == (const NoteStore_getResourceApplicationDataEntry_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    if (!(key == rhs.key))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceApplicationDataEntry_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceApplicationDataEntry_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getResourceApplicationDataEntry_pargs {
 public:


  virtual ~NoteStore_getResourceApplicationDataEntry_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;
  const std::string* key;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceApplicationDataEntry_result__isset {
  _NoteStore_getResourceApplicationDataEntry_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceApplicationDataEntry_result__isset;

class NoteStore_getResourceApplicationDataEntry_result {
 public:

  NoteStore_getResourceApplicationDataEntry_result(const NoteStore_getResourceApplicationDataEntry_result&);
  NoteStore_getResourceApplicationDataEntry_result& operator=(const NoteStore_getResourceApplicationDataEntry_result&);
  NoteStore_getResourceApplicationDataEntry_result() : success() {
  }

  virtual ~NoteStore_getResourceApplicationDataEntry_result() throw();
  std::string success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceApplicationDataEntry_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getResourceApplicationDataEntry_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceApplicationDataEntry_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceApplicationDataEntry_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceApplicationDataEntry_presult__isset {
  _NoteStore_getResourceApplicationDataEntry_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceApplicationDataEntry_presult__isset;

class NoteStore_getResourceApplicationDataEntry_presult {
 public:


  virtual ~NoteStore_getResourceApplicationDataEntry_presult() throw();
  std::string* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceApplicationDataEntry_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_setResourceApplicationDataEntry_args__isset {
  _NoteStore_setResourceApplicationDataEntry_args__isset() : authenticationToken(false), guid(false), key(false), value(false) {}
  bool authenticationToken :1;
  bool guid :1;
  bool key :1;
  bool value :1;
} _NoteStore_setResourceApplicationDataEntry_args__isset;

class NoteStore_setResourceApplicationDataEntry_args {
 public:

  NoteStore_setResourceApplicationDataEntry_args(const NoteStore_setResourceApplicationDataEntry_args&);
  NoteStore_setResourceApplicationDataEntry_args& operator=(const NoteStore_setResourceApplicationDataEntry_args&);
  NoteStore_setResourceApplicationDataEntry_args() : authenticationToken(), guid(), key(), value() {
  }

  virtual ~NoteStore_setResourceApplicationDataEntry_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;
  std::string key;
  std::string value;

  _NoteStore_setResourceApplicationDataEntry_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  void __set_key(const std::string& val);

  void __set_value(const std::string& val);

  bool operator == (const NoteStore_setResourceApplicationDataEntry_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const NoteStore_setResourceApplicationDataEntry_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_setResourceApplicationDataEntry_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_setResourceApplicationDataEntry_pargs {
 public:


  virtual ~NoteStore_setResourceApplicationDataEntry_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;
  const std::string* key;
  const std::string* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_setResourceApplicationDataEntry_result__isset {
  _NoteStore_setResourceApplicationDataEntry_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_setResourceApplicationDataEntry_result__isset;

class NoteStore_setResourceApplicationDataEntry_result {
 public:

  NoteStore_setResourceApplicationDataEntry_result(const NoteStore_setResourceApplicationDataEntry_result&);
  NoteStore_setResourceApplicationDataEntry_result& operator=(const NoteStore_setResourceApplicationDataEntry_result&);
  NoteStore_setResourceApplicationDataEntry_result() : success(0) {
  }

  virtual ~NoteStore_setResourceApplicationDataEntry_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_setResourceApplicationDataEntry_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_setResourceApplicationDataEntry_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_setResourceApplicationDataEntry_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_setResourceApplicationDataEntry_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_setResourceApplicationDataEntry_presult__isset {
  _NoteStore_setResourceApplicationDataEntry_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_setResourceApplicationDataEntry_presult__isset;

class NoteStore_setResourceApplicationDataEntry_presult {
 public:


  virtual ~NoteStore_setResourceApplicationDataEntry_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_setResourceApplicationDataEntry_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_unsetResourceApplicationDataEntry_args__isset {
  _NoteStore_unsetResourceApplicationDataEntry_args__isset() : authenticationToken(false), guid(false), key(false) {}
  bool authenticationToken :1;
  bool guid :1;
  bool key :1;
} _NoteStore_unsetResourceApplicationDataEntry_args__isset;

class NoteStore_unsetResourceApplicationDataEntry_args {
 public:

  NoteStore_unsetResourceApplicationDataEntry_args(const NoteStore_unsetResourceApplicationDataEntry_args&);
  NoteStore_unsetResourceApplicationDataEntry_args& operator=(const NoteStore_unsetResourceApplicationDataEntry_args&);
  NoteStore_unsetResourceApplicationDataEntry_args() : authenticationToken(), guid(), key() {
  }

  virtual ~NoteStore_unsetResourceApplicationDataEntry_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;
  std::string key;

  _NoteStore_unsetResourceApplicationDataEntry_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  void __set_key(const std::string& val);

  bool operator == (const NoteStore_unsetResourceApplicationDataEntry_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    if (!(key == rhs.key))
      return false;
    return true;
  }
  bool operator != (const NoteStore_unsetResourceApplicationDataEntry_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_unsetResourceApplicationDataEntry_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_unsetResourceApplicationDataEntry_pargs {
 public:


  virtual ~NoteStore_unsetResourceApplicationDataEntry_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;
  const std::string* key;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_unsetResourceApplicationDataEntry_result__isset {
  _NoteStore_unsetResourceApplicationDataEntry_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_unsetResourceApplicationDataEntry_result__isset;

class NoteStore_unsetResourceApplicationDataEntry_result {
 public:

  NoteStore_unsetResourceApplicationDataEntry_result(const NoteStore_unsetResourceApplicationDataEntry_result&);
  NoteStore_unsetResourceApplicationDataEntry_result& operator=(const NoteStore_unsetResourceApplicationDataEntry_result&);
  NoteStore_unsetResourceApplicationDataEntry_result() : success(0) {
  }

  virtual ~NoteStore_unsetResourceApplicationDataEntry_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_unsetResourceApplicationDataEntry_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_unsetResourceApplicationDataEntry_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_unsetResourceApplicationDataEntry_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_unsetResourceApplicationDataEntry_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_unsetResourceApplicationDataEntry_presult__isset {
  _NoteStore_unsetResourceApplicationDataEntry_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_unsetResourceApplicationDataEntry_presult__isset;

class NoteStore_unsetResourceApplicationDataEntry_presult {
 public:


  virtual ~NoteStore_unsetResourceApplicationDataEntry_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_unsetResourceApplicationDataEntry_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_updateResource_args__isset {
  _NoteStore_updateResource_args__isset() : authenticationToken(false), resource(false) {}
  bool authenticationToken :1;
  bool resource :1;
} _NoteStore_updateResource_args__isset;

class NoteStore_updateResource_args {
 public:

  NoteStore_updateResource_args(const NoteStore_updateResource_args&);
  NoteStore_updateResource_args& operator=(const NoteStore_updateResource_args&);
  NoteStore_updateResource_args() : authenticationToken() {
  }

  virtual ~NoteStore_updateResource_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Resource resource;

  _NoteStore_updateResource_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_resource(const  ::evernote::edam::Resource& val);

  bool operator == (const NoteStore_updateResource_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(resource == rhs.resource))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateResource_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateResource_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_updateResource_pargs {
 public:


  virtual ~NoteStore_updateResource_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Resource* resource;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateResource_result__isset {
  _NoteStore_updateResource_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_updateResource_result__isset;

class NoteStore_updateResource_result {
 public:

  NoteStore_updateResource_result(const NoteStore_updateResource_result&);
  NoteStore_updateResource_result& operator=(const NoteStore_updateResource_result&);
  NoteStore_updateResource_result() : success(0) {
  }

  virtual ~NoteStore_updateResource_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_updateResource_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_updateResource_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateResource_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateResource_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateResource_presult__isset {
  _NoteStore_updateResource_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_updateResource_presult__isset;

class NoteStore_updateResource_presult {
 public:


  virtual ~NoteStore_updateResource_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_updateResource_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getResourceData_args__isset {
  _NoteStore_getResourceData_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_getResourceData_args__isset;

class NoteStore_getResourceData_args {
 public:

  NoteStore_getResourceData_args(const NoteStore_getResourceData_args&);
  NoteStore_getResourceData_args& operator=(const NoteStore_getResourceData_args&);
  NoteStore_getResourceData_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_getResourceData_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_getResourceData_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_getResourceData_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getResourceData_pargs {
 public:


  virtual ~NoteStore_getResourceData_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceData_result__isset {
  _NoteStore_getResourceData_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceData_result__isset;

class NoteStore_getResourceData_result {
 public:

  NoteStore_getResourceData_result(const NoteStore_getResourceData_result&);
  NoteStore_getResourceData_result& operator=(const NoteStore_getResourceData_result&);
  NoteStore_getResourceData_result() : success() {
  }

  virtual ~NoteStore_getResourceData_result() throw();
  std::string success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceData_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getResourceData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceData_presult__isset {
  _NoteStore_getResourceData_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceData_presult__isset;

class NoteStore_getResourceData_presult {
 public:


  virtual ~NoteStore_getResourceData_presult() throw();
  std::string* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getResourceByHash_args__isset {
  _NoteStore_getResourceByHash_args__isset() : authenticationToken(false), noteGuid(false), contentHash(false), withData(false), withRecognition(false), withAlternateData(false) {}
  bool authenticationToken :1;
  bool noteGuid :1;
  bool contentHash :1;
  bool withData :1;
  bool withRecognition :1;
  bool withAlternateData :1;
} _NoteStore_getResourceByHash_args__isset;

class NoteStore_getResourceByHash_args {
 public:

  NoteStore_getResourceByHash_args(const NoteStore_getResourceByHash_args&);
  NoteStore_getResourceByHash_args& operator=(const NoteStore_getResourceByHash_args&);
  NoteStore_getResourceByHash_args() : authenticationToken(), noteGuid(), contentHash(), withData(0), withRecognition(0), withAlternateData(0) {
  }

  virtual ~NoteStore_getResourceByHash_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid noteGuid;
  std::string contentHash;
  bool withData;
  bool withRecognition;
  bool withAlternateData;

  _NoteStore_getResourceByHash_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_noteGuid(const  ::evernote::edam::Guid& val);

  void __set_contentHash(const std::string& val);

  void __set_withData(const bool val);

  void __set_withRecognition(const bool val);

  void __set_withAlternateData(const bool val);

  bool operator == (const NoteStore_getResourceByHash_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(noteGuid == rhs.noteGuid))
      return false;
    if (!(contentHash == rhs.contentHash))
      return false;
    if (!(withData == rhs.withData))
      return false;
    if (!(withRecognition == rhs.withRecognition))
      return false;
    if (!(withAlternateData == rhs.withAlternateData))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceByHash_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceByHash_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getResourceByHash_pargs {
 public:


  virtual ~NoteStore_getResourceByHash_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* noteGuid;
  const std::string* contentHash;
  const bool* withData;
  const bool* withRecognition;
  const bool* withAlternateData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceByHash_result__isset {
  _NoteStore_getResourceByHash_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceByHash_result__isset;

class NoteStore_getResourceByHash_result {
 public:

  NoteStore_getResourceByHash_result(const NoteStore_getResourceByHash_result&);
  NoteStore_getResourceByHash_result& operator=(const NoteStore_getResourceByHash_result&);
  NoteStore_getResourceByHash_result() {
  }

  virtual ~NoteStore_getResourceByHash_result() throw();
   ::evernote::edam::Resource success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceByHash_result__isset __isset;

  void __set_success(const  ::evernote::edam::Resource& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getResourceByHash_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceByHash_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceByHash_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceByHash_presult__isset {
  _NoteStore_getResourceByHash_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceByHash_presult__isset;

class NoteStore_getResourceByHash_presult {
 public:


  virtual ~NoteStore_getResourceByHash_presult() throw();
   ::evernote::edam::Resource* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceByHash_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getResourceRecognition_args__isset {
  _NoteStore_getResourceRecognition_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_getResourceRecognition_args__isset;

class NoteStore_getResourceRecognition_args {
 public:

  NoteStore_getResourceRecognition_args(const NoteStore_getResourceRecognition_args&);
  NoteStore_getResourceRecognition_args& operator=(const NoteStore_getResourceRecognition_args&);
  NoteStore_getResourceRecognition_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_getResourceRecognition_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_getResourceRecognition_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_getResourceRecognition_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceRecognition_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceRecognition_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getResourceRecognition_pargs {
 public:


  virtual ~NoteStore_getResourceRecognition_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceRecognition_result__isset {
  _NoteStore_getResourceRecognition_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceRecognition_result__isset;

class NoteStore_getResourceRecognition_result {
 public:

  NoteStore_getResourceRecognition_result(const NoteStore_getResourceRecognition_result&);
  NoteStore_getResourceRecognition_result& operator=(const NoteStore_getResourceRecognition_result&);
  NoteStore_getResourceRecognition_result() : success() {
  }

  virtual ~NoteStore_getResourceRecognition_result() throw();
  std::string success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceRecognition_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getResourceRecognition_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceRecognition_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceRecognition_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceRecognition_presult__isset {
  _NoteStore_getResourceRecognition_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceRecognition_presult__isset;

class NoteStore_getResourceRecognition_presult {
 public:


  virtual ~NoteStore_getResourceRecognition_presult() throw();
  std::string* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceRecognition_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getResourceAlternateData_args__isset {
  _NoteStore_getResourceAlternateData_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_getResourceAlternateData_args__isset;

class NoteStore_getResourceAlternateData_args {
 public:

  NoteStore_getResourceAlternateData_args(const NoteStore_getResourceAlternateData_args&);
  NoteStore_getResourceAlternateData_args& operator=(const NoteStore_getResourceAlternateData_args&);
  NoteStore_getResourceAlternateData_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_getResourceAlternateData_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_getResourceAlternateData_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_getResourceAlternateData_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceAlternateData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceAlternateData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getResourceAlternateData_pargs {
 public:


  virtual ~NoteStore_getResourceAlternateData_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceAlternateData_result__isset {
  _NoteStore_getResourceAlternateData_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceAlternateData_result__isset;

class NoteStore_getResourceAlternateData_result {
 public:

  NoteStore_getResourceAlternateData_result(const NoteStore_getResourceAlternateData_result&);
  NoteStore_getResourceAlternateData_result& operator=(const NoteStore_getResourceAlternateData_result&);
  NoteStore_getResourceAlternateData_result() : success() {
  }

  virtual ~NoteStore_getResourceAlternateData_result() throw();
  std::string success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceAlternateData_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getResourceAlternateData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceAlternateData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceAlternateData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceAlternateData_presult__isset {
  _NoteStore_getResourceAlternateData_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceAlternateData_presult__isset;

class NoteStore_getResourceAlternateData_presult {
 public:


  virtual ~NoteStore_getResourceAlternateData_presult() throw();
  std::string* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceAlternateData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getResourceAttributes_args__isset {
  _NoteStore_getResourceAttributes_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_getResourceAttributes_args__isset;

class NoteStore_getResourceAttributes_args {
 public:

  NoteStore_getResourceAttributes_args(const NoteStore_getResourceAttributes_args&);
  NoteStore_getResourceAttributes_args& operator=(const NoteStore_getResourceAttributes_args&);
  NoteStore_getResourceAttributes_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_getResourceAttributes_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_getResourceAttributes_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_getResourceAttributes_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceAttributes_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceAttributes_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getResourceAttributes_pargs {
 public:


  virtual ~NoteStore_getResourceAttributes_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceAttributes_result__isset {
  _NoteStore_getResourceAttributes_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceAttributes_result__isset;

class NoteStore_getResourceAttributes_result {
 public:

  NoteStore_getResourceAttributes_result(const NoteStore_getResourceAttributes_result&);
  NoteStore_getResourceAttributes_result& operator=(const NoteStore_getResourceAttributes_result&);
  NoteStore_getResourceAttributes_result() {
  }

  virtual ~NoteStore_getResourceAttributes_result() throw();
   ::evernote::edam::ResourceAttributes success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceAttributes_result__isset __isset;

  void __set_success(const  ::evernote::edam::ResourceAttributes& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getResourceAttributes_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getResourceAttributes_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getResourceAttributes_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getResourceAttributes_presult__isset {
  _NoteStore_getResourceAttributes_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getResourceAttributes_presult__isset;

class NoteStore_getResourceAttributes_presult {
 public:


  virtual ~NoteStore_getResourceAttributes_presult() throw();
   ::evernote::edam::ResourceAttributes* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getResourceAttributes_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getPublicNotebook_args__isset {
  _NoteStore_getPublicNotebook_args__isset() : userId(false), publicUri(false) {}
  bool userId :1;
  bool publicUri :1;
} _NoteStore_getPublicNotebook_args__isset;

class NoteStore_getPublicNotebook_args {
 public:

  NoteStore_getPublicNotebook_args(const NoteStore_getPublicNotebook_args&);
  NoteStore_getPublicNotebook_args& operator=(const NoteStore_getPublicNotebook_args&);
  NoteStore_getPublicNotebook_args() : userId(0), publicUri() {
  }

  virtual ~NoteStore_getPublicNotebook_args() throw();
   ::evernote::edam::UserID userId;
  std::string publicUri;

  _NoteStore_getPublicNotebook_args__isset __isset;

  void __set_userId(const  ::evernote::edam::UserID val);

  void __set_publicUri(const std::string& val);

  bool operator == (const NoteStore_getPublicNotebook_args & rhs) const
  {
    if (!(userId == rhs.userId))
      return false;
    if (!(publicUri == rhs.publicUri))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getPublicNotebook_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getPublicNotebook_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getPublicNotebook_pargs {
 public:


  virtual ~NoteStore_getPublicNotebook_pargs() throw();
  const  ::evernote::edam::UserID* userId;
  const std::string* publicUri;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getPublicNotebook_result__isset {
  _NoteStore_getPublicNotebook_result__isset() : success(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getPublicNotebook_result__isset;

class NoteStore_getPublicNotebook_result {
 public:

  NoteStore_getPublicNotebook_result(const NoteStore_getPublicNotebook_result&);
  NoteStore_getPublicNotebook_result& operator=(const NoteStore_getPublicNotebook_result&);
  NoteStore_getPublicNotebook_result() {
  }

  virtual ~NoteStore_getPublicNotebook_result() throw();
   ::evernote::edam::Notebook success;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getPublicNotebook_result__isset __isset;

  void __set_success(const  ::evernote::edam::Notebook& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_getPublicNotebook_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getPublicNotebook_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getPublicNotebook_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getPublicNotebook_presult__isset {
  _NoteStore_getPublicNotebook_presult__isset() : success(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_getPublicNotebook_presult__isset;

class NoteStore_getPublicNotebook_presult {
 public:


  virtual ~NoteStore_getPublicNotebook_presult() throw();
   ::evernote::edam::Notebook* success;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_getPublicNotebook_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_shareNotebook_args__isset {
  _NoteStore_shareNotebook_args__isset() : authenticationToken(false), sharedNotebook(false), message(false) {}
  bool authenticationToken :1;
  bool sharedNotebook :1;
  bool message :1;
} _NoteStore_shareNotebook_args__isset;

class NoteStore_shareNotebook_args {
 public:

  NoteStore_shareNotebook_args(const NoteStore_shareNotebook_args&);
  NoteStore_shareNotebook_args& operator=(const NoteStore_shareNotebook_args&);
  NoteStore_shareNotebook_args() : authenticationToken(), message() {
  }

  virtual ~NoteStore_shareNotebook_args() throw();
  std::string authenticationToken;
   ::evernote::edam::SharedNotebook sharedNotebook;
  std::string message;

  _NoteStore_shareNotebook_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_sharedNotebook(const  ::evernote::edam::SharedNotebook& val);

  void __set_message(const std::string& val);

  bool operator == (const NoteStore_shareNotebook_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(sharedNotebook == rhs.sharedNotebook))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoteStore_shareNotebook_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_shareNotebook_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_shareNotebook_pargs {
 public:


  virtual ~NoteStore_shareNotebook_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::SharedNotebook* sharedNotebook;
  const std::string* message;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_shareNotebook_result__isset {
  _NoteStore_shareNotebook_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_shareNotebook_result__isset;

class NoteStore_shareNotebook_result {
 public:

  NoteStore_shareNotebook_result(const NoteStore_shareNotebook_result&);
  NoteStore_shareNotebook_result& operator=(const NoteStore_shareNotebook_result&);
  NoteStore_shareNotebook_result() {
  }

  virtual ~NoteStore_shareNotebook_result() throw();
   ::evernote::edam::SharedNotebook success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_shareNotebook_result__isset __isset;

  void __set_success(const  ::evernote::edam::SharedNotebook& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_shareNotebook_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_shareNotebook_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_shareNotebook_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_shareNotebook_presult__isset {
  _NoteStore_shareNotebook_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_shareNotebook_presult__isset;

class NoteStore_shareNotebook_presult {
 public:


  virtual ~NoteStore_shareNotebook_presult() throw();
   ::evernote::edam::SharedNotebook* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_shareNotebook_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_createOrUpdateNotebookShares_args__isset {
  _NoteStore_createOrUpdateNotebookShares_args__isset() : authenticationToken(false), shareTemplate(false) {}
  bool authenticationToken :1;
  bool shareTemplate :1;
} _NoteStore_createOrUpdateNotebookShares_args__isset;

class NoteStore_createOrUpdateNotebookShares_args {
 public:

  NoteStore_createOrUpdateNotebookShares_args(const NoteStore_createOrUpdateNotebookShares_args&);
  NoteStore_createOrUpdateNotebookShares_args& operator=(const NoteStore_createOrUpdateNotebookShares_args&);
  NoteStore_createOrUpdateNotebookShares_args() : authenticationToken() {
  }

  virtual ~NoteStore_createOrUpdateNotebookShares_args() throw();
  std::string authenticationToken;
  NotebookShareTemplate shareTemplate;

  _NoteStore_createOrUpdateNotebookShares_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_shareTemplate(const NotebookShareTemplate& val);

  bool operator == (const NoteStore_createOrUpdateNotebookShares_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(shareTemplate == rhs.shareTemplate))
      return false;
    return true;
  }
  bool operator != (const NoteStore_createOrUpdateNotebookShares_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_createOrUpdateNotebookShares_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_createOrUpdateNotebookShares_pargs {
 public:


  virtual ~NoteStore_createOrUpdateNotebookShares_pargs() throw();
  const std::string* authenticationToken;
  const NotebookShareTemplate* shareTemplate;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_createOrUpdateNotebookShares_result__isset {
  _NoteStore_createOrUpdateNotebookShares_result__isset() : success(false), userException(false), notFoundException(false), systemException(false), invalidContactsException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
  bool invalidContactsException :1;
} _NoteStore_createOrUpdateNotebookShares_result__isset;

class NoteStore_createOrUpdateNotebookShares_result {
 public:

  NoteStore_createOrUpdateNotebookShares_result(const NoteStore_createOrUpdateNotebookShares_result&);
  NoteStore_createOrUpdateNotebookShares_result& operator=(const NoteStore_createOrUpdateNotebookShares_result&);
  NoteStore_createOrUpdateNotebookShares_result() {
  }

  virtual ~NoteStore_createOrUpdateNotebookShares_result() throw();
  CreateOrUpdateNotebookSharesResult success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMInvalidContactsException invalidContactsException;

  _NoteStore_createOrUpdateNotebookShares_result__isset __isset;

  void __set_success(const CreateOrUpdateNotebookSharesResult& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_invalidContactsException(const  ::evernote::edam::EDAMInvalidContactsException& val);

  bool operator == (const NoteStore_createOrUpdateNotebookShares_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(invalidContactsException == rhs.invalidContactsException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_createOrUpdateNotebookShares_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_createOrUpdateNotebookShares_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_createOrUpdateNotebookShares_presult__isset {
  _NoteStore_createOrUpdateNotebookShares_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false), invalidContactsException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
  bool invalidContactsException :1;
} _NoteStore_createOrUpdateNotebookShares_presult__isset;

class NoteStore_createOrUpdateNotebookShares_presult {
 public:


  virtual ~NoteStore_createOrUpdateNotebookShares_presult() throw();
  CreateOrUpdateNotebookSharesResult* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMInvalidContactsException invalidContactsException;

  _NoteStore_createOrUpdateNotebookShares_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_updateSharedNotebook_args__isset {
  _NoteStore_updateSharedNotebook_args__isset() : authenticationToken(false), sharedNotebook(false) {}
  bool authenticationToken :1;
  bool sharedNotebook :1;
} _NoteStore_updateSharedNotebook_args__isset;

class NoteStore_updateSharedNotebook_args {
 public:

  NoteStore_updateSharedNotebook_args(const NoteStore_updateSharedNotebook_args&);
  NoteStore_updateSharedNotebook_args& operator=(const NoteStore_updateSharedNotebook_args&);
  NoteStore_updateSharedNotebook_args() : authenticationToken() {
  }

  virtual ~NoteStore_updateSharedNotebook_args() throw();
  std::string authenticationToken;
   ::evernote::edam::SharedNotebook sharedNotebook;

  _NoteStore_updateSharedNotebook_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_sharedNotebook(const  ::evernote::edam::SharedNotebook& val);

  bool operator == (const NoteStore_updateSharedNotebook_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(sharedNotebook == rhs.sharedNotebook))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateSharedNotebook_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateSharedNotebook_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_updateSharedNotebook_pargs {
 public:


  virtual ~NoteStore_updateSharedNotebook_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::SharedNotebook* sharedNotebook;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateSharedNotebook_result__isset {
  _NoteStore_updateSharedNotebook_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_updateSharedNotebook_result__isset;

class NoteStore_updateSharedNotebook_result {
 public:

  NoteStore_updateSharedNotebook_result(const NoteStore_updateSharedNotebook_result&);
  NoteStore_updateSharedNotebook_result& operator=(const NoteStore_updateSharedNotebook_result&);
  NoteStore_updateSharedNotebook_result() : success(0) {
  }

  virtual ~NoteStore_updateSharedNotebook_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_updateSharedNotebook_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_updateSharedNotebook_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateSharedNotebook_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateSharedNotebook_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateSharedNotebook_presult__isset {
  _NoteStore_updateSharedNotebook_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_updateSharedNotebook_presult__isset;

class NoteStore_updateSharedNotebook_presult {
 public:


  virtual ~NoteStore_updateSharedNotebook_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_updateSharedNotebook_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_setNotebookRecipientSettings_args__isset {
  _NoteStore_setNotebookRecipientSettings_args__isset() : authenticationToken(false), notebookGuid(false), recipientSettings(false) {}
  bool authenticationToken :1;
  bool notebookGuid :1;
  bool recipientSettings :1;
} _NoteStore_setNotebookRecipientSettings_args__isset;

class NoteStore_setNotebookRecipientSettings_args {
 public:

  NoteStore_setNotebookRecipientSettings_args(const NoteStore_setNotebookRecipientSettings_args&);
  NoteStore_setNotebookRecipientSettings_args& operator=(const NoteStore_setNotebookRecipientSettings_args&);
  NoteStore_setNotebookRecipientSettings_args() : authenticationToken(), notebookGuid() {
  }

  virtual ~NoteStore_setNotebookRecipientSettings_args() throw();
  std::string authenticationToken;
  std::string notebookGuid;
   ::evernote::edam::NotebookRecipientSettings recipientSettings;

  _NoteStore_setNotebookRecipientSettings_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_notebookGuid(const std::string& val);

  void __set_recipientSettings(const  ::evernote::edam::NotebookRecipientSettings& val);

  bool operator == (const NoteStore_setNotebookRecipientSettings_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(notebookGuid == rhs.notebookGuid))
      return false;
    if (!(recipientSettings == rhs.recipientSettings))
      return false;
    return true;
  }
  bool operator != (const NoteStore_setNotebookRecipientSettings_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_setNotebookRecipientSettings_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_setNotebookRecipientSettings_pargs {
 public:


  virtual ~NoteStore_setNotebookRecipientSettings_pargs() throw();
  const std::string* authenticationToken;
  const std::string* notebookGuid;
  const  ::evernote::edam::NotebookRecipientSettings* recipientSettings;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_setNotebookRecipientSettings_result__isset {
  _NoteStore_setNotebookRecipientSettings_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_setNotebookRecipientSettings_result__isset;

class NoteStore_setNotebookRecipientSettings_result {
 public:

  NoteStore_setNotebookRecipientSettings_result(const NoteStore_setNotebookRecipientSettings_result&);
  NoteStore_setNotebookRecipientSettings_result& operator=(const NoteStore_setNotebookRecipientSettings_result&);
  NoteStore_setNotebookRecipientSettings_result() {
  }

  virtual ~NoteStore_setNotebookRecipientSettings_result() throw();
   ::evernote::edam::Notebook success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_setNotebookRecipientSettings_result__isset __isset;

  void __set_success(const  ::evernote::edam::Notebook& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_setNotebookRecipientSettings_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_setNotebookRecipientSettings_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_setNotebookRecipientSettings_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_setNotebookRecipientSettings_presult__isset {
  _NoteStore_setNotebookRecipientSettings_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_setNotebookRecipientSettings_presult__isset;

class NoteStore_setNotebookRecipientSettings_presult {
 public:


  virtual ~NoteStore_setNotebookRecipientSettings_presult() throw();
   ::evernote::edam::Notebook* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_setNotebookRecipientSettings_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_listSharedNotebooks_args__isset {
  _NoteStore_listSharedNotebooks_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _NoteStore_listSharedNotebooks_args__isset;

class NoteStore_listSharedNotebooks_args {
 public:

  NoteStore_listSharedNotebooks_args(const NoteStore_listSharedNotebooks_args&);
  NoteStore_listSharedNotebooks_args& operator=(const NoteStore_listSharedNotebooks_args&);
  NoteStore_listSharedNotebooks_args() : authenticationToken() {
  }

  virtual ~NoteStore_listSharedNotebooks_args() throw();
  std::string authenticationToken;

  _NoteStore_listSharedNotebooks_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const NoteStore_listSharedNotebooks_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listSharedNotebooks_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listSharedNotebooks_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_listSharedNotebooks_pargs {
 public:


  virtual ~NoteStore_listSharedNotebooks_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listSharedNotebooks_result__isset {
  _NoteStore_listSharedNotebooks_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_listSharedNotebooks_result__isset;

class NoteStore_listSharedNotebooks_result {
 public:

  NoteStore_listSharedNotebooks_result(const NoteStore_listSharedNotebooks_result&);
  NoteStore_listSharedNotebooks_result& operator=(const NoteStore_listSharedNotebooks_result&);
  NoteStore_listSharedNotebooks_result() {
  }

  virtual ~NoteStore_listSharedNotebooks_result() throw();
  std::vector< ::evernote::edam::SharedNotebook>  success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_listSharedNotebooks_result__isset __isset;

  void __set_success(const std::vector< ::evernote::edam::SharedNotebook> & val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_listSharedNotebooks_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listSharedNotebooks_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listSharedNotebooks_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listSharedNotebooks_presult__isset {
  _NoteStore_listSharedNotebooks_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_listSharedNotebooks_presult__isset;

class NoteStore_listSharedNotebooks_presult {
 public:


  virtual ~NoteStore_listSharedNotebooks_presult() throw();
  std::vector< ::evernote::edam::SharedNotebook> * success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_listSharedNotebooks_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_createLinkedNotebook_args__isset {
  _NoteStore_createLinkedNotebook_args__isset() : authenticationToken(false), linkedNotebook(false) {}
  bool authenticationToken :1;
  bool linkedNotebook :1;
} _NoteStore_createLinkedNotebook_args__isset;

class NoteStore_createLinkedNotebook_args {
 public:

  NoteStore_createLinkedNotebook_args(const NoteStore_createLinkedNotebook_args&);
  NoteStore_createLinkedNotebook_args& operator=(const NoteStore_createLinkedNotebook_args&);
  NoteStore_createLinkedNotebook_args() : authenticationToken() {
  }

  virtual ~NoteStore_createLinkedNotebook_args() throw();
  std::string authenticationToken;
   ::evernote::edam::LinkedNotebook linkedNotebook;

  _NoteStore_createLinkedNotebook_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_linkedNotebook(const  ::evernote::edam::LinkedNotebook& val);

  bool operator == (const NoteStore_createLinkedNotebook_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(linkedNotebook == rhs.linkedNotebook))
      return false;
    return true;
  }
  bool operator != (const NoteStore_createLinkedNotebook_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_createLinkedNotebook_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_createLinkedNotebook_pargs {
 public:


  virtual ~NoteStore_createLinkedNotebook_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::LinkedNotebook* linkedNotebook;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_createLinkedNotebook_result__isset {
  _NoteStore_createLinkedNotebook_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_createLinkedNotebook_result__isset;

class NoteStore_createLinkedNotebook_result {
 public:

  NoteStore_createLinkedNotebook_result(const NoteStore_createLinkedNotebook_result&);
  NoteStore_createLinkedNotebook_result& operator=(const NoteStore_createLinkedNotebook_result&);
  NoteStore_createLinkedNotebook_result() {
  }

  virtual ~NoteStore_createLinkedNotebook_result() throw();
   ::evernote::edam::LinkedNotebook success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_createLinkedNotebook_result__isset __isset;

  void __set_success(const  ::evernote::edam::LinkedNotebook& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_createLinkedNotebook_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_createLinkedNotebook_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_createLinkedNotebook_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_createLinkedNotebook_presult__isset {
  _NoteStore_createLinkedNotebook_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_createLinkedNotebook_presult__isset;

class NoteStore_createLinkedNotebook_presult {
 public:


  virtual ~NoteStore_createLinkedNotebook_presult() throw();
   ::evernote::edam::LinkedNotebook* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_createLinkedNotebook_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_updateLinkedNotebook_args__isset {
  _NoteStore_updateLinkedNotebook_args__isset() : authenticationToken(false), linkedNotebook(false) {}
  bool authenticationToken :1;
  bool linkedNotebook :1;
} _NoteStore_updateLinkedNotebook_args__isset;

class NoteStore_updateLinkedNotebook_args {
 public:

  NoteStore_updateLinkedNotebook_args(const NoteStore_updateLinkedNotebook_args&);
  NoteStore_updateLinkedNotebook_args& operator=(const NoteStore_updateLinkedNotebook_args&);
  NoteStore_updateLinkedNotebook_args() : authenticationToken() {
  }

  virtual ~NoteStore_updateLinkedNotebook_args() throw();
  std::string authenticationToken;
   ::evernote::edam::LinkedNotebook linkedNotebook;

  _NoteStore_updateLinkedNotebook_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_linkedNotebook(const  ::evernote::edam::LinkedNotebook& val);

  bool operator == (const NoteStore_updateLinkedNotebook_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(linkedNotebook == rhs.linkedNotebook))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateLinkedNotebook_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateLinkedNotebook_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_updateLinkedNotebook_pargs {
 public:


  virtual ~NoteStore_updateLinkedNotebook_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::LinkedNotebook* linkedNotebook;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateLinkedNotebook_result__isset {
  _NoteStore_updateLinkedNotebook_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_updateLinkedNotebook_result__isset;

class NoteStore_updateLinkedNotebook_result {
 public:

  NoteStore_updateLinkedNotebook_result(const NoteStore_updateLinkedNotebook_result&);
  NoteStore_updateLinkedNotebook_result& operator=(const NoteStore_updateLinkedNotebook_result&);
  NoteStore_updateLinkedNotebook_result() : success(0) {
  }

  virtual ~NoteStore_updateLinkedNotebook_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_updateLinkedNotebook_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_updateLinkedNotebook_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateLinkedNotebook_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateLinkedNotebook_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateLinkedNotebook_presult__isset {
  _NoteStore_updateLinkedNotebook_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_updateLinkedNotebook_presult__isset;

class NoteStore_updateLinkedNotebook_presult {
 public:


  virtual ~NoteStore_updateLinkedNotebook_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_updateLinkedNotebook_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_listLinkedNotebooks_args__isset {
  _NoteStore_listLinkedNotebooks_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _NoteStore_listLinkedNotebooks_args__isset;

class NoteStore_listLinkedNotebooks_args {
 public:

  NoteStore_listLinkedNotebooks_args(const NoteStore_listLinkedNotebooks_args&);
  NoteStore_listLinkedNotebooks_args& operator=(const NoteStore_listLinkedNotebooks_args&);
  NoteStore_listLinkedNotebooks_args() : authenticationToken() {
  }

  virtual ~NoteStore_listLinkedNotebooks_args() throw();
  std::string authenticationToken;

  _NoteStore_listLinkedNotebooks_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const NoteStore_listLinkedNotebooks_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listLinkedNotebooks_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listLinkedNotebooks_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_listLinkedNotebooks_pargs {
 public:


  virtual ~NoteStore_listLinkedNotebooks_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listLinkedNotebooks_result__isset {
  _NoteStore_listLinkedNotebooks_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_listLinkedNotebooks_result__isset;

class NoteStore_listLinkedNotebooks_result {
 public:

  NoteStore_listLinkedNotebooks_result(const NoteStore_listLinkedNotebooks_result&);
  NoteStore_listLinkedNotebooks_result& operator=(const NoteStore_listLinkedNotebooks_result&);
  NoteStore_listLinkedNotebooks_result() {
  }

  virtual ~NoteStore_listLinkedNotebooks_result() throw();
  std::vector< ::evernote::edam::LinkedNotebook>  success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_listLinkedNotebooks_result__isset __isset;

  void __set_success(const std::vector< ::evernote::edam::LinkedNotebook> & val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_listLinkedNotebooks_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_listLinkedNotebooks_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_listLinkedNotebooks_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_listLinkedNotebooks_presult__isset {
  _NoteStore_listLinkedNotebooks_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_listLinkedNotebooks_presult__isset;

class NoteStore_listLinkedNotebooks_presult {
 public:


  virtual ~NoteStore_listLinkedNotebooks_presult() throw();
  std::vector< ::evernote::edam::LinkedNotebook> * success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_listLinkedNotebooks_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_expungeLinkedNotebook_args__isset {
  _NoteStore_expungeLinkedNotebook_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_expungeLinkedNotebook_args__isset;

class NoteStore_expungeLinkedNotebook_args {
 public:

  NoteStore_expungeLinkedNotebook_args(const NoteStore_expungeLinkedNotebook_args&);
  NoteStore_expungeLinkedNotebook_args& operator=(const NoteStore_expungeLinkedNotebook_args&);
  NoteStore_expungeLinkedNotebook_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_expungeLinkedNotebook_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_expungeLinkedNotebook_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_expungeLinkedNotebook_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_expungeLinkedNotebook_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_expungeLinkedNotebook_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_expungeLinkedNotebook_pargs {
 public:


  virtual ~NoteStore_expungeLinkedNotebook_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_expungeLinkedNotebook_result__isset {
  _NoteStore_expungeLinkedNotebook_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_expungeLinkedNotebook_result__isset;

class NoteStore_expungeLinkedNotebook_result {
 public:

  NoteStore_expungeLinkedNotebook_result(const NoteStore_expungeLinkedNotebook_result&);
  NoteStore_expungeLinkedNotebook_result& operator=(const NoteStore_expungeLinkedNotebook_result&);
  NoteStore_expungeLinkedNotebook_result() : success(0) {
  }

  virtual ~NoteStore_expungeLinkedNotebook_result() throw();
  int32_t success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_expungeLinkedNotebook_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_expungeLinkedNotebook_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_expungeLinkedNotebook_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_expungeLinkedNotebook_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_expungeLinkedNotebook_presult__isset {
  _NoteStore_expungeLinkedNotebook_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_expungeLinkedNotebook_presult__isset;

class NoteStore_expungeLinkedNotebook_presult {
 public:


  virtual ~NoteStore_expungeLinkedNotebook_presult() throw();
  int32_t* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_expungeLinkedNotebook_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_authenticateToSharedNotebook_args__isset {
  _NoteStore_authenticateToSharedNotebook_args__isset() : shareKeyOrGlobalId(false), authenticationToken(false) {}
  bool shareKeyOrGlobalId :1;
  bool authenticationToken :1;
} _NoteStore_authenticateToSharedNotebook_args__isset;

class NoteStore_authenticateToSharedNotebook_args {
 public:

  NoteStore_authenticateToSharedNotebook_args(const NoteStore_authenticateToSharedNotebook_args&);
  NoteStore_authenticateToSharedNotebook_args& operator=(const NoteStore_authenticateToSharedNotebook_args&);
  NoteStore_authenticateToSharedNotebook_args() : shareKeyOrGlobalId(), authenticationToken() {
  }

  virtual ~NoteStore_authenticateToSharedNotebook_args() throw();
  std::string shareKeyOrGlobalId;
  std::string authenticationToken;

  _NoteStore_authenticateToSharedNotebook_args__isset __isset;

  void __set_shareKeyOrGlobalId(const std::string& val);

  void __set_authenticationToken(const std::string& val);

  bool operator == (const NoteStore_authenticateToSharedNotebook_args & rhs) const
  {
    if (!(shareKeyOrGlobalId == rhs.shareKeyOrGlobalId))
      return false;
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const NoteStore_authenticateToSharedNotebook_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_authenticateToSharedNotebook_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_authenticateToSharedNotebook_pargs {
 public:


  virtual ~NoteStore_authenticateToSharedNotebook_pargs() throw();
  const std::string* shareKeyOrGlobalId;
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_authenticateToSharedNotebook_result__isset {
  _NoteStore_authenticateToSharedNotebook_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_authenticateToSharedNotebook_result__isset;

class NoteStore_authenticateToSharedNotebook_result {
 public:

  NoteStore_authenticateToSharedNotebook_result(const NoteStore_authenticateToSharedNotebook_result&);
  NoteStore_authenticateToSharedNotebook_result& operator=(const NoteStore_authenticateToSharedNotebook_result&);
  NoteStore_authenticateToSharedNotebook_result() {
  }

  virtual ~NoteStore_authenticateToSharedNotebook_result() throw();
   ::evernote::edam::AuthenticationResult success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_authenticateToSharedNotebook_result__isset __isset;

  void __set_success(const  ::evernote::edam::AuthenticationResult& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_authenticateToSharedNotebook_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_authenticateToSharedNotebook_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_authenticateToSharedNotebook_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_authenticateToSharedNotebook_presult__isset {
  _NoteStore_authenticateToSharedNotebook_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_authenticateToSharedNotebook_presult__isset;

class NoteStore_authenticateToSharedNotebook_presult {
 public:


  virtual ~NoteStore_authenticateToSharedNotebook_presult() throw();
   ::evernote::edam::AuthenticationResult* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_authenticateToSharedNotebook_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getSharedNotebookByAuth_args__isset {
  _NoteStore_getSharedNotebookByAuth_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _NoteStore_getSharedNotebookByAuth_args__isset;

class NoteStore_getSharedNotebookByAuth_args {
 public:

  NoteStore_getSharedNotebookByAuth_args(const NoteStore_getSharedNotebookByAuth_args&);
  NoteStore_getSharedNotebookByAuth_args& operator=(const NoteStore_getSharedNotebookByAuth_args&);
  NoteStore_getSharedNotebookByAuth_args() : authenticationToken() {
  }

  virtual ~NoteStore_getSharedNotebookByAuth_args() throw();
  std::string authenticationToken;

  _NoteStore_getSharedNotebookByAuth_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const NoteStore_getSharedNotebookByAuth_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getSharedNotebookByAuth_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getSharedNotebookByAuth_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getSharedNotebookByAuth_pargs {
 public:


  virtual ~NoteStore_getSharedNotebookByAuth_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getSharedNotebookByAuth_result__isset {
  _NoteStore_getSharedNotebookByAuth_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_getSharedNotebookByAuth_result__isset;

class NoteStore_getSharedNotebookByAuth_result {
 public:

  NoteStore_getSharedNotebookByAuth_result(const NoteStore_getSharedNotebookByAuth_result&);
  NoteStore_getSharedNotebookByAuth_result& operator=(const NoteStore_getSharedNotebookByAuth_result&);
  NoteStore_getSharedNotebookByAuth_result() {
  }

  virtual ~NoteStore_getSharedNotebookByAuth_result() throw();
   ::evernote::edam::SharedNotebook success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_getSharedNotebookByAuth_result__isset __isset;

  void __set_success(const  ::evernote::edam::SharedNotebook& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_getSharedNotebookByAuth_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getSharedNotebookByAuth_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getSharedNotebookByAuth_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getSharedNotebookByAuth_presult__isset {
  _NoteStore_getSharedNotebookByAuth_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_getSharedNotebookByAuth_presult__isset;

class NoteStore_getSharedNotebookByAuth_presult {
 public:


  virtual ~NoteStore_getSharedNotebookByAuth_presult() throw();
   ::evernote::edam::SharedNotebook* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_getSharedNotebookByAuth_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_emailNote_args__isset {
  _NoteStore_emailNote_args__isset() : authenticationToken(false), parameters(false) {}
  bool authenticationToken :1;
  bool parameters :1;
} _NoteStore_emailNote_args__isset;

class NoteStore_emailNote_args {
 public:

  NoteStore_emailNote_args(const NoteStore_emailNote_args&);
  NoteStore_emailNote_args& operator=(const NoteStore_emailNote_args&);
  NoteStore_emailNote_args() : authenticationToken() {
  }

  virtual ~NoteStore_emailNote_args() throw();
  std::string authenticationToken;
  NoteEmailParameters parameters;

  _NoteStore_emailNote_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_parameters(const NoteEmailParameters& val);

  bool operator == (const NoteStore_emailNote_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    return true;
  }
  bool operator != (const NoteStore_emailNote_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_emailNote_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_emailNote_pargs {
 public:


  virtual ~NoteStore_emailNote_pargs() throw();
  const std::string* authenticationToken;
  const NoteEmailParameters* parameters;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_emailNote_result__isset {
  _NoteStore_emailNote_result__isset() : userException(false), notFoundException(false), systemException(false) {}
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_emailNote_result__isset;

class NoteStore_emailNote_result {
 public:

  NoteStore_emailNote_result(const NoteStore_emailNote_result&);
  NoteStore_emailNote_result& operator=(const NoteStore_emailNote_result&);
  NoteStore_emailNote_result() {
  }

  virtual ~NoteStore_emailNote_result() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_emailNote_result__isset __isset;

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_emailNote_result & rhs) const
  {
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_emailNote_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_emailNote_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_emailNote_presult__isset {
  _NoteStore_emailNote_presult__isset() : userException(false), notFoundException(false), systemException(false) {}
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_emailNote_presult__isset;

class NoteStore_emailNote_presult {
 public:


  virtual ~NoteStore_emailNote_presult() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_emailNote_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_shareNote_args__isset {
  _NoteStore_shareNote_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_shareNote_args__isset;

class NoteStore_shareNote_args {
 public:

  NoteStore_shareNote_args(const NoteStore_shareNote_args&);
  NoteStore_shareNote_args& operator=(const NoteStore_shareNote_args&);
  NoteStore_shareNote_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_shareNote_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_shareNote_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_shareNote_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_shareNote_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_shareNote_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_shareNote_pargs {
 public:


  virtual ~NoteStore_shareNote_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_shareNote_result__isset {
  _NoteStore_shareNote_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_shareNote_result__isset;

class NoteStore_shareNote_result {
 public:

  NoteStore_shareNote_result(const NoteStore_shareNote_result&);
  NoteStore_shareNote_result& operator=(const NoteStore_shareNote_result&);
  NoteStore_shareNote_result() : success() {
  }

  virtual ~NoteStore_shareNote_result() throw();
  std::string success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_shareNote_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_shareNote_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_shareNote_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_shareNote_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_shareNote_presult__isset {
  _NoteStore_shareNote_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_shareNote_presult__isset;

class NoteStore_shareNote_presult {
 public:


  virtual ~NoteStore_shareNote_presult() throw();
  std::string* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_shareNote_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_stopSharingNote_args__isset {
  _NoteStore_stopSharingNote_args__isset() : authenticationToken(false), guid(false) {}
  bool authenticationToken :1;
  bool guid :1;
} _NoteStore_stopSharingNote_args__isset;

class NoteStore_stopSharingNote_args {
 public:

  NoteStore_stopSharingNote_args(const NoteStore_stopSharingNote_args&);
  NoteStore_stopSharingNote_args& operator=(const NoteStore_stopSharingNote_args&);
  NoteStore_stopSharingNote_args() : authenticationToken(), guid() {
  }

  virtual ~NoteStore_stopSharingNote_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Guid guid;

  _NoteStore_stopSharingNote_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_guid(const  ::evernote::edam::Guid& val);

  bool operator == (const NoteStore_stopSharingNote_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(guid == rhs.guid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_stopSharingNote_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_stopSharingNote_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_stopSharingNote_pargs {
 public:


  virtual ~NoteStore_stopSharingNote_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Guid* guid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_stopSharingNote_result__isset {
  _NoteStore_stopSharingNote_result__isset() : userException(false), notFoundException(false), systemException(false) {}
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_stopSharingNote_result__isset;

class NoteStore_stopSharingNote_result {
 public:

  NoteStore_stopSharingNote_result(const NoteStore_stopSharingNote_result&);
  NoteStore_stopSharingNote_result& operator=(const NoteStore_stopSharingNote_result&);
  NoteStore_stopSharingNote_result() {
  }

  virtual ~NoteStore_stopSharingNote_result() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_stopSharingNote_result__isset __isset;

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_stopSharingNote_result & rhs) const
  {
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_stopSharingNote_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_stopSharingNote_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_stopSharingNote_presult__isset {
  _NoteStore_stopSharingNote_presult__isset() : userException(false), notFoundException(false), systemException(false) {}
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_stopSharingNote_presult__isset;

class NoteStore_stopSharingNote_presult {
 public:


  virtual ~NoteStore_stopSharingNote_presult() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_stopSharingNote_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_authenticateToSharedNote_args__isset {
  _NoteStore_authenticateToSharedNote_args__isset() : guid(false), noteKey(false), authenticationToken(false) {}
  bool guid :1;
  bool noteKey :1;
  bool authenticationToken :1;
} _NoteStore_authenticateToSharedNote_args__isset;

class NoteStore_authenticateToSharedNote_args {
 public:

  NoteStore_authenticateToSharedNote_args(const NoteStore_authenticateToSharedNote_args&);
  NoteStore_authenticateToSharedNote_args& operator=(const NoteStore_authenticateToSharedNote_args&);
  NoteStore_authenticateToSharedNote_args() : guid(), noteKey(), authenticationToken() {
  }

  virtual ~NoteStore_authenticateToSharedNote_args() throw();
  std::string guid;
  std::string noteKey;
  std::string authenticationToken;

  _NoteStore_authenticateToSharedNote_args__isset __isset;

  void __set_guid(const std::string& val);

  void __set_noteKey(const std::string& val);

  void __set_authenticationToken(const std::string& val);

  bool operator == (const NoteStore_authenticateToSharedNote_args & rhs) const
  {
    if (!(guid == rhs.guid))
      return false;
    if (!(noteKey == rhs.noteKey))
      return false;
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const NoteStore_authenticateToSharedNote_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_authenticateToSharedNote_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_authenticateToSharedNote_pargs {
 public:


  virtual ~NoteStore_authenticateToSharedNote_pargs() throw();
  const std::string* guid;
  const std::string* noteKey;
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_authenticateToSharedNote_result__isset {
  _NoteStore_authenticateToSharedNote_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_authenticateToSharedNote_result__isset;

class NoteStore_authenticateToSharedNote_result {
 public:

  NoteStore_authenticateToSharedNote_result(const NoteStore_authenticateToSharedNote_result&);
  NoteStore_authenticateToSharedNote_result& operator=(const NoteStore_authenticateToSharedNote_result&);
  NoteStore_authenticateToSharedNote_result() {
  }

  virtual ~NoteStore_authenticateToSharedNote_result() throw();
   ::evernote::edam::AuthenticationResult success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_authenticateToSharedNote_result__isset __isset;

  void __set_success(const  ::evernote::edam::AuthenticationResult& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_authenticateToSharedNote_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_authenticateToSharedNote_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_authenticateToSharedNote_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_authenticateToSharedNote_presult__isset {
  _NoteStore_authenticateToSharedNote_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_authenticateToSharedNote_presult__isset;

class NoteStore_authenticateToSharedNote_presult {
 public:


  virtual ~NoteStore_authenticateToSharedNote_presult() throw();
   ::evernote::edam::AuthenticationResult* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_authenticateToSharedNote_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_findRelated_args__isset {
  _NoteStore_findRelated_args__isset() : authenticationToken(false), query(false), resultSpec(false) {}
  bool authenticationToken :1;
  bool query :1;
  bool resultSpec :1;
} _NoteStore_findRelated_args__isset;

class NoteStore_findRelated_args {
 public:

  NoteStore_findRelated_args(const NoteStore_findRelated_args&);
  NoteStore_findRelated_args& operator=(const NoteStore_findRelated_args&);
  NoteStore_findRelated_args() : authenticationToken() {
  }

  virtual ~NoteStore_findRelated_args() throw();
  std::string authenticationToken;
  RelatedQuery query;
  RelatedResultSpec resultSpec;

  _NoteStore_findRelated_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_query(const RelatedQuery& val);

  void __set_resultSpec(const RelatedResultSpec& val);

  bool operator == (const NoteStore_findRelated_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(query == rhs.query))
      return false;
    if (!(resultSpec == rhs.resultSpec))
      return false;
    return true;
  }
  bool operator != (const NoteStore_findRelated_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_findRelated_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_findRelated_pargs {
 public:


  virtual ~NoteStore_findRelated_pargs() throw();
  const std::string* authenticationToken;
  const RelatedQuery* query;
  const RelatedResultSpec* resultSpec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_findRelated_result__isset {
  _NoteStore_findRelated_result__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_findRelated_result__isset;

class NoteStore_findRelated_result {
 public:

  NoteStore_findRelated_result(const NoteStore_findRelated_result&);
  NoteStore_findRelated_result& operator=(const NoteStore_findRelated_result&);
  NoteStore_findRelated_result() {
  }

  virtual ~NoteStore_findRelated_result() throw();
  RelatedResult success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_findRelated_result__isset __isset;

  void __set_success(const RelatedResult& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const NoteStore_findRelated_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_findRelated_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_findRelated_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_findRelated_presult__isset {
  _NoteStore_findRelated_presult__isset() : success(false), userException(false), systemException(false), notFoundException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _NoteStore_findRelated_presult__isset;

class NoteStore_findRelated_presult {
 public:


  virtual ~NoteStore_findRelated_presult() throw();
  RelatedResult* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _NoteStore_findRelated_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_updateNoteIfUsnMatches_args__isset {
  _NoteStore_updateNoteIfUsnMatches_args__isset() : authenticationToken(false), note(false) {}
  bool authenticationToken :1;
  bool note :1;
} _NoteStore_updateNoteIfUsnMatches_args__isset;

class NoteStore_updateNoteIfUsnMatches_args {
 public:

  NoteStore_updateNoteIfUsnMatches_args(const NoteStore_updateNoteIfUsnMatches_args&);
  NoteStore_updateNoteIfUsnMatches_args& operator=(const NoteStore_updateNoteIfUsnMatches_args&);
  NoteStore_updateNoteIfUsnMatches_args() : authenticationToken() {
  }

  virtual ~NoteStore_updateNoteIfUsnMatches_args() throw();
  std::string authenticationToken;
   ::evernote::edam::Note note;

  _NoteStore_updateNoteIfUsnMatches_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_note(const  ::evernote::edam::Note& val);

  bool operator == (const NoteStore_updateNoteIfUsnMatches_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(note == rhs.note))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateNoteIfUsnMatches_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateNoteIfUsnMatches_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_updateNoteIfUsnMatches_pargs {
 public:


  virtual ~NoteStore_updateNoteIfUsnMatches_pargs() throw();
  const std::string* authenticationToken;
  const  ::evernote::edam::Note* note;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateNoteIfUsnMatches_result__isset {
  _NoteStore_updateNoteIfUsnMatches_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_updateNoteIfUsnMatches_result__isset;

class NoteStore_updateNoteIfUsnMatches_result {
 public:

  NoteStore_updateNoteIfUsnMatches_result(const NoteStore_updateNoteIfUsnMatches_result&);
  NoteStore_updateNoteIfUsnMatches_result& operator=(const NoteStore_updateNoteIfUsnMatches_result&);
  NoteStore_updateNoteIfUsnMatches_result() {
  }

  virtual ~NoteStore_updateNoteIfUsnMatches_result() throw();
  UpdateNoteIfUsnMatchesResult success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_updateNoteIfUsnMatches_result__isset __isset;

  void __set_success(const UpdateNoteIfUsnMatchesResult& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_updateNoteIfUsnMatches_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_updateNoteIfUsnMatches_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_updateNoteIfUsnMatches_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_updateNoteIfUsnMatches_presult__isset {
  _NoteStore_updateNoteIfUsnMatches_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_updateNoteIfUsnMatches_presult__isset;

class NoteStore_updateNoteIfUsnMatches_presult {
 public:


  virtual ~NoteStore_updateNoteIfUsnMatches_presult() throw();
  UpdateNoteIfUsnMatchesResult* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_updateNoteIfUsnMatches_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_manageNotebookShares_args__isset {
  _NoteStore_manageNotebookShares_args__isset() : authenticationToken(false), parameters(false) {}
  bool authenticationToken :1;
  bool parameters :1;
} _NoteStore_manageNotebookShares_args__isset;

class NoteStore_manageNotebookShares_args {
 public:

  NoteStore_manageNotebookShares_args(const NoteStore_manageNotebookShares_args&);
  NoteStore_manageNotebookShares_args& operator=(const NoteStore_manageNotebookShares_args&);
  NoteStore_manageNotebookShares_args() : authenticationToken() {
  }

  virtual ~NoteStore_manageNotebookShares_args() throw();
  std::string authenticationToken;
  ManageNotebookSharesParameters parameters;

  _NoteStore_manageNotebookShares_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_parameters(const ManageNotebookSharesParameters& val);

  bool operator == (const NoteStore_manageNotebookShares_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    return true;
  }
  bool operator != (const NoteStore_manageNotebookShares_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_manageNotebookShares_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_manageNotebookShares_pargs {
 public:


  virtual ~NoteStore_manageNotebookShares_pargs() throw();
  const std::string* authenticationToken;
  const ManageNotebookSharesParameters* parameters;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_manageNotebookShares_result__isset {
  _NoteStore_manageNotebookShares_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_manageNotebookShares_result__isset;

class NoteStore_manageNotebookShares_result {
 public:

  NoteStore_manageNotebookShares_result(const NoteStore_manageNotebookShares_result&);
  NoteStore_manageNotebookShares_result& operator=(const NoteStore_manageNotebookShares_result&);
  NoteStore_manageNotebookShares_result() {
  }

  virtual ~NoteStore_manageNotebookShares_result() throw();
  ManageNotebookSharesResult success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_manageNotebookShares_result__isset __isset;

  void __set_success(const ManageNotebookSharesResult& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_manageNotebookShares_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_manageNotebookShares_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_manageNotebookShares_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_manageNotebookShares_presult__isset {
  _NoteStore_manageNotebookShares_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_manageNotebookShares_presult__isset;

class NoteStore_manageNotebookShares_presult {
 public:


  virtual ~NoteStore_manageNotebookShares_presult() throw();
  ManageNotebookSharesResult* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_manageNotebookShares_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _NoteStore_getNotebookShares_args__isset {
  _NoteStore_getNotebookShares_args__isset() : authenticationToken(false), notebookGuid(false) {}
  bool authenticationToken :1;
  bool notebookGuid :1;
} _NoteStore_getNotebookShares_args__isset;

class NoteStore_getNotebookShares_args {
 public:

  NoteStore_getNotebookShares_args(const NoteStore_getNotebookShares_args&);
  NoteStore_getNotebookShares_args& operator=(const NoteStore_getNotebookShares_args&);
  NoteStore_getNotebookShares_args() : authenticationToken(), notebookGuid() {
  }

  virtual ~NoteStore_getNotebookShares_args() throw();
  std::string authenticationToken;
  std::string notebookGuid;

  _NoteStore_getNotebookShares_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_notebookGuid(const std::string& val);

  bool operator == (const NoteStore_getNotebookShares_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(notebookGuid == rhs.notebookGuid))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNotebookShares_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNotebookShares_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NoteStore_getNotebookShares_pargs {
 public:


  virtual ~NoteStore_getNotebookShares_pargs() throw();
  const std::string* authenticationToken;
  const std::string* notebookGuid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNotebookShares_result__isset {
  _NoteStore_getNotebookShares_result__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_getNotebookShares_result__isset;

class NoteStore_getNotebookShares_result {
 public:

  NoteStore_getNotebookShares_result(const NoteStore_getNotebookShares_result&);
  NoteStore_getNotebookShares_result& operator=(const NoteStore_getNotebookShares_result&);
  NoteStore_getNotebookShares_result() {
  }

  virtual ~NoteStore_getNotebookShares_result() throw();
  ShareRelationships success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_getNotebookShares_result__isset __isset;

  void __set_success(const ShareRelationships& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const NoteStore_getNotebookShares_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const NoteStore_getNotebookShares_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteStore_getNotebookShares_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NoteStore_getNotebookShares_presult__isset {
  _NoteStore_getNotebookShares_presult__isset() : success(false), userException(false), notFoundException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool notFoundException :1;
  bool systemException :1;
} _NoteStore_getNotebookShares_presult__isset;

class NoteStore_getNotebookShares_presult {
 public:


  virtual ~NoteStore_getNotebookShares_presult() throw();
  ShareRelationships* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;

  _NoteStore_getNotebookShares_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class NoteStoreClient : virtual public NoteStoreIf {
 public:
  NoteStoreClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  NoteStoreClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void getSyncState(SyncState& _return, const std::string& authenticationToken);
  void send_getSyncState(const std::string& authenticationToken);
  void recv_getSyncState(SyncState& _return);
  void getFilteredSyncChunk(SyncChunk& _return, const std::string& authenticationToken, const int32_t afterUSN, const int32_t maxEntries, const SyncChunkFilter& filter);
  void send_getFilteredSyncChunk(const std::string& authenticationToken, const int32_t afterUSN, const int32_t maxEntries, const SyncChunkFilter& filter);
  void recv_getFilteredSyncChunk(SyncChunk& _return);
  void getLinkedNotebookSyncState(SyncState& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook);
  void send_getLinkedNotebookSyncState(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook);
  void recv_getLinkedNotebookSyncState(SyncState& _return);
  void getLinkedNotebookSyncChunk(SyncChunk& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook, const int32_t afterUSN, const int32_t maxEntries, const bool fullSyncOnly);
  void send_getLinkedNotebookSyncChunk(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook, const int32_t afterUSN, const int32_t maxEntries, const bool fullSyncOnly);
  void recv_getLinkedNotebookSyncChunk(SyncChunk& _return);
  void listNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const std::string& authenticationToken);
  void send_listNotebooks(const std::string& authenticationToken);
  void recv_listNotebooks(std::vector< ::evernote::edam::Notebook> & _return);
  void listAccessibleBusinessNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const std::string& authenticationToken);
  void send_listAccessibleBusinessNotebooks(const std::string& authenticationToken);
  void recv_listAccessibleBusinessNotebooks(std::vector< ::evernote::edam::Notebook> & _return);
  void getNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_getNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getNotebook( ::evernote::edam::Notebook& _return);
  void getDefaultNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken);
  void send_getDefaultNotebook(const std::string& authenticationToken);
  void recv_getDefaultNotebook( ::evernote::edam::Notebook& _return);
  void createNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook);
  void send_createNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook);
  void recv_createNotebook( ::evernote::edam::Notebook& _return);
  int32_t updateNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook);
  void send_updateNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook);
  int32_t recv_updateNotebook();
  int32_t expungeNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_expungeNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t recv_expungeNotebook();
  void listTags(std::vector< ::evernote::edam::Tag> & _return, const std::string& authenticationToken);
  void send_listTags(const std::string& authenticationToken);
  void recv_listTags(std::vector< ::evernote::edam::Tag> & _return);
  void listTagsByNotebook(std::vector< ::evernote::edam::Tag> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& notebookGuid);
  void send_listTagsByNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& notebookGuid);
  void recv_listTagsByNotebook(std::vector< ::evernote::edam::Tag> & _return);
  void getTag( ::evernote::edam::Tag& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_getTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getTag( ::evernote::edam::Tag& _return);
  void createTag( ::evernote::edam::Tag& _return, const std::string& authenticationToken, const  ::evernote::edam::Tag& tag);
  void send_createTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag);
  void recv_createTag( ::evernote::edam::Tag& _return);
  int32_t updateTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag);
  void send_updateTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag);
  int32_t recv_updateTag();
  void untagAll(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_untagAll(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_untagAll();
  int32_t expungeTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_expungeTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t recv_expungeTag();
  void listSearches(std::vector< ::evernote::edam::SavedSearch> & _return, const std::string& authenticationToken);
  void send_listSearches(const std::string& authenticationToken);
  void recv_listSearches(std::vector< ::evernote::edam::SavedSearch> & _return);
  void getSearch( ::evernote::edam::SavedSearch& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_getSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getSearch( ::evernote::edam::SavedSearch& _return);
  void createSearch( ::evernote::edam::SavedSearch& _return, const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search);
  void send_createSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search);
  void recv_createSearch( ::evernote::edam::SavedSearch& _return);
  int32_t updateSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search);
  void send_updateSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search);
  int32_t recv_updateSearch();
  int32_t expungeSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_expungeSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t recv_expungeSearch();
  int32_t findNoteOffset(const std::string& authenticationToken, const NoteFilter& filter, const  ::evernote::edam::Guid& guid);
  void send_findNoteOffset(const std::string& authenticationToken, const NoteFilter& filter, const  ::evernote::edam::Guid& guid);
  int32_t recv_findNoteOffset();
  void findNotesMetadata(NotesMetadataList& _return, const std::string& authenticationToken, const NoteFilter& filter, const int32_t offset, const int32_t maxNotes, const NotesMetadataResultSpec& resultSpec);
  void send_findNotesMetadata(const std::string& authenticationToken, const NoteFilter& filter, const int32_t offset, const int32_t maxNotes, const NotesMetadataResultSpec& resultSpec);
  void recv_findNotesMetadata(NotesMetadataList& _return);
  void findNoteCounts(NoteCollectionCounts& _return, const std::string& authenticationToken, const NoteFilter& filter, const bool withTrash);
  void send_findNoteCounts(const std::string& authenticationToken, const NoteFilter& filter, const bool withTrash);
  void recv_findNoteCounts(NoteCollectionCounts& _return);
  void getNoteWithResultSpec( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const NoteResultSpec& resultSpec);
  void send_getNoteWithResultSpec(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const NoteResultSpec& resultSpec);
  void recv_getNoteWithResultSpec( ::evernote::edam::Note& _return);
  void getNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withContent, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData);
  void send_getNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withContent, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData);
  void recv_getNote( ::evernote::edam::Note& _return);
  void getNoteApplicationData( ::evernote::edam::LazyMap& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_getNoteApplicationData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getNoteApplicationData( ::evernote::edam::LazyMap& _return);
  void getNoteApplicationDataEntry(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  void send_getNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  void recv_getNoteApplicationDataEntry(std::string& _return);
  int32_t setNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value);
  void send_setNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value);
  int32_t recv_setNoteApplicationDataEntry();
  int32_t unsetNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  void send_unsetNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  int32_t recv_unsetNoteApplicationDataEntry();
  void getNoteContent(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_getNoteContent(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getNoteContent(std::string& _return);
  void getNoteSearchText(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool noteOnly, const bool tokenizeForIndexing);
  void send_getNoteSearchText(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool noteOnly, const bool tokenizeForIndexing);
  void recv_getNoteSearchText(std::string& _return);
  void getResourceSearchText(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_getResourceSearchText(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getResourceSearchText(std::string& _return);
  void getNoteTagNames(std::vector<std::string> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_getNoteTagNames(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getNoteTagNames(std::vector<std::string> & _return);
  void createNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note);
  void send_createNote(const std::string& authenticationToken, const  ::evernote::edam::Note& note);
  void recv_createNote( ::evernote::edam::Note& _return);
  void updateNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note);
  void send_updateNote(const std::string& authenticationToken, const  ::evernote::edam::Note& note);
  void recv_updateNote( ::evernote::edam::Note& _return);
  int32_t deleteNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_deleteNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t recv_deleteNote();
  int32_t expungeNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_expungeNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t recv_expungeNote();
  void copyNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const  ::evernote::edam::Guid& toNotebookGuid);
  void send_copyNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const  ::evernote::edam::Guid& toNotebookGuid);
  void recv_copyNote( ::evernote::edam::Note& _return);
  void listNoteVersions(std::vector<NoteVersionId> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid);
  void send_listNoteVersions(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid);
  void recv_listNoteVersions(std::vector<NoteVersionId> & _return);
  void getNoteVersion( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const int32_t updateSequenceNum, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData);
  void send_getNoteVersion(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const int32_t updateSequenceNum, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData);
  void recv_getNoteVersion( ::evernote::edam::Note& _return);
  void getResource( ::evernote::edam::Resource& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withData, const bool withRecognition, const bool withAttributes, const bool withAlternateData);
  void send_getResource(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withData, const bool withRecognition, const bool withAttributes, const bool withAlternateData);
  void recv_getResource( ::evernote::edam::Resource& _return);
  void getResourceApplicationData( ::evernote::edam::LazyMap& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_getResourceApplicationData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getResourceApplicationData( ::evernote::edam::LazyMap& _return);
  void getResourceApplicationDataEntry(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  void send_getResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  void recv_getResourceApplicationDataEntry(std::string& _return);
  int32_t setResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value);
  void send_setResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value);
  int32_t recv_setResourceApplicationDataEntry();
  int32_t unsetResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  void send_unsetResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  int32_t recv_unsetResourceApplicationDataEntry();
  int32_t updateResource(const std::string& authenticationToken, const  ::evernote::edam::Resource& resource);
  void send_updateResource(const std::string& authenticationToken, const  ::evernote::edam::Resource& resource);
  int32_t recv_updateResource();
  void getResourceData(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_getResourceData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getResourceData(std::string& _return);
  void getResourceByHash( ::evernote::edam::Resource& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const std::string& contentHash, const bool withData, const bool withRecognition, const bool withAlternateData);
  void send_getResourceByHash(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const std::string& contentHash, const bool withData, const bool withRecognition, const bool withAlternateData);
  void recv_getResourceByHash( ::evernote::edam::Resource& _return);
  void getResourceRecognition(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_getResourceRecognition(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getResourceRecognition(std::string& _return);
  void getResourceAlternateData(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_getResourceAlternateData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getResourceAlternateData(std::string& _return);
  void getResourceAttributes( ::evernote::edam::ResourceAttributes& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_getResourceAttributes(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getResourceAttributes( ::evernote::edam::ResourceAttributes& _return);
  void getPublicNotebook( ::evernote::edam::Notebook& _return, const  ::evernote::edam::UserID userId, const std::string& publicUri);
  void send_getPublicNotebook(const  ::evernote::edam::UserID userId, const std::string& publicUri);
  void recv_getPublicNotebook( ::evernote::edam::Notebook& _return);
  void shareNotebook( ::evernote::edam::SharedNotebook& _return, const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook, const std::string& message);
  void send_shareNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook, const std::string& message);
  void recv_shareNotebook( ::evernote::edam::SharedNotebook& _return);
  void createOrUpdateNotebookShares(CreateOrUpdateNotebookSharesResult& _return, const std::string& authenticationToken, const NotebookShareTemplate& shareTemplate);
  void send_createOrUpdateNotebookShares(const std::string& authenticationToken, const NotebookShareTemplate& shareTemplate);
  void recv_createOrUpdateNotebookShares(CreateOrUpdateNotebookSharesResult& _return);
  int32_t updateSharedNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook);
  void send_updateSharedNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook);
  int32_t recv_updateSharedNotebook();
  void setNotebookRecipientSettings( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const std::string& notebookGuid, const  ::evernote::edam::NotebookRecipientSettings& recipientSettings);
  void send_setNotebookRecipientSettings(const std::string& authenticationToken, const std::string& notebookGuid, const  ::evernote::edam::NotebookRecipientSettings& recipientSettings);
  void recv_setNotebookRecipientSettings( ::evernote::edam::Notebook& _return);
  void listSharedNotebooks(std::vector< ::evernote::edam::SharedNotebook> & _return, const std::string& authenticationToken);
  void send_listSharedNotebooks(const std::string& authenticationToken);
  void recv_listSharedNotebooks(std::vector< ::evernote::edam::SharedNotebook> & _return);
  void createLinkedNotebook( ::evernote::edam::LinkedNotebook& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook);
  void send_createLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook);
  void recv_createLinkedNotebook( ::evernote::edam::LinkedNotebook& _return);
  int32_t updateLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook);
  void send_updateLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook);
  int32_t recv_updateLinkedNotebook();
  void listLinkedNotebooks(std::vector< ::evernote::edam::LinkedNotebook> & _return, const std::string& authenticationToken);
  void send_listLinkedNotebooks(const std::string& authenticationToken);
  void recv_listLinkedNotebooks(std::vector< ::evernote::edam::LinkedNotebook> & _return);
  int32_t expungeLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_expungeLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t recv_expungeLinkedNotebook();
  void authenticateToSharedNotebook( ::evernote::edam::AuthenticationResult& _return, const std::string& shareKeyOrGlobalId, const std::string& authenticationToken);
  void send_authenticateToSharedNotebook(const std::string& shareKeyOrGlobalId, const std::string& authenticationToken);
  void recv_authenticateToSharedNotebook( ::evernote::edam::AuthenticationResult& _return);
  void getSharedNotebookByAuth( ::evernote::edam::SharedNotebook& _return, const std::string& authenticationToken);
  void send_getSharedNotebookByAuth(const std::string& authenticationToken);
  void recv_getSharedNotebookByAuth( ::evernote::edam::SharedNotebook& _return);
  void emailNote(const std::string& authenticationToken, const NoteEmailParameters& parameters);
  void send_emailNote(const std::string& authenticationToken, const NoteEmailParameters& parameters);
  void recv_emailNote();
  void shareNote(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_shareNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_shareNote(std::string& _return);
  void stopSharingNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void send_stopSharingNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_stopSharingNote();
  void authenticateToSharedNote( ::evernote::edam::AuthenticationResult& _return, const std::string& guid, const std::string& noteKey, const std::string& authenticationToken);
  void send_authenticateToSharedNote(const std::string& guid, const std::string& noteKey, const std::string& authenticationToken);
  void recv_authenticateToSharedNote( ::evernote::edam::AuthenticationResult& _return);
  void findRelated(RelatedResult& _return, const std::string& authenticationToken, const RelatedQuery& query, const RelatedResultSpec& resultSpec);
  void send_findRelated(const std::string& authenticationToken, const RelatedQuery& query, const RelatedResultSpec& resultSpec);
  void recv_findRelated(RelatedResult& _return);
  void updateNoteIfUsnMatches(UpdateNoteIfUsnMatchesResult& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note);
  void send_updateNoteIfUsnMatches(const std::string& authenticationToken, const  ::evernote::edam::Note& note);
  void recv_updateNoteIfUsnMatches(UpdateNoteIfUsnMatchesResult& _return);
  void manageNotebookShares(ManageNotebookSharesResult& _return, const std::string& authenticationToken, const ManageNotebookSharesParameters& parameters);
  void send_manageNotebookShares(const std::string& authenticationToken, const ManageNotebookSharesParameters& parameters);
  void recv_manageNotebookShares(ManageNotebookSharesResult& _return);
  void getNotebookShares(ShareRelationships& _return, const std::string& authenticationToken, const std::string& notebookGuid);
  void send_getNotebookShares(const std::string& authenticationToken, const std::string& notebookGuid);
  void recv_getNotebookShares(ShareRelationships& _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class NoteStoreProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<NoteStoreIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (NoteStoreProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_getSyncState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getFilteredSyncChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getLinkedNotebookSyncState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getLinkedNotebookSyncChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listNotebooks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listAccessibleBusinessNotebooks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDefaultNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_expungeNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listTags(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listTagsByNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTag(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createTag(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateTag(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_untagAll(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_expungeTag(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listSearches(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getSearch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createSearch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateSearch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_expungeSearch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_findNoteOffset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_findNotesMetadata(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_findNoteCounts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNoteWithResultSpec(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNoteApplicationData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNoteApplicationDataEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setNoteApplicationDataEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unsetNoteApplicationDataEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNoteContent(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNoteSearchText(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getResourceSearchText(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNoteTagNames(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_expungeNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_copyNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listNoteVersions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNoteVersion(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getResource(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getResourceApplicationData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getResourceApplicationDataEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setResourceApplicationDataEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unsetResourceApplicationDataEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateResource(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getResourceData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getResourceByHash(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getResourceRecognition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getResourceAlternateData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getResourceAttributes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getPublicNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_shareNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createOrUpdateNotebookShares(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateSharedNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setNotebookRecipientSettings(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listSharedNotebooks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createLinkedNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateLinkedNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listLinkedNotebooks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_expungeLinkedNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_authenticateToSharedNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getSharedNotebookByAuth(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_emailNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_shareNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_stopSharingNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_authenticateToSharedNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_findRelated(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateNoteIfUsnMatches(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_manageNotebookShares(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNotebookShares(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  NoteStoreProcessor(boost::shared_ptr<NoteStoreIf> iface) :
    iface_(iface) {
    processMap_["getSyncState"] = &NoteStoreProcessor::process_getSyncState;
    processMap_["getFilteredSyncChunk"] = &NoteStoreProcessor::process_getFilteredSyncChunk;
    processMap_["getLinkedNotebookSyncState"] = &NoteStoreProcessor::process_getLinkedNotebookSyncState;
    processMap_["getLinkedNotebookSyncChunk"] = &NoteStoreProcessor::process_getLinkedNotebookSyncChunk;
    processMap_["listNotebooks"] = &NoteStoreProcessor::process_listNotebooks;
    processMap_["listAccessibleBusinessNotebooks"] = &NoteStoreProcessor::process_listAccessibleBusinessNotebooks;
    processMap_["getNotebook"] = &NoteStoreProcessor::process_getNotebook;
    processMap_["getDefaultNotebook"] = &NoteStoreProcessor::process_getDefaultNotebook;
    processMap_["createNotebook"] = &NoteStoreProcessor::process_createNotebook;
    processMap_["updateNotebook"] = &NoteStoreProcessor::process_updateNotebook;
    processMap_["expungeNotebook"] = &NoteStoreProcessor::process_expungeNotebook;
    processMap_["listTags"] = &NoteStoreProcessor::process_listTags;
    processMap_["listTagsByNotebook"] = &NoteStoreProcessor::process_listTagsByNotebook;
    processMap_["getTag"] = &NoteStoreProcessor::process_getTag;
    processMap_["createTag"] = &NoteStoreProcessor::process_createTag;
    processMap_["updateTag"] = &NoteStoreProcessor::process_updateTag;
    processMap_["untagAll"] = &NoteStoreProcessor::process_untagAll;
    processMap_["expungeTag"] = &NoteStoreProcessor::process_expungeTag;
    processMap_["listSearches"] = &NoteStoreProcessor::process_listSearches;
    processMap_["getSearch"] = &NoteStoreProcessor::process_getSearch;
    processMap_["createSearch"] = &NoteStoreProcessor::process_createSearch;
    processMap_["updateSearch"] = &NoteStoreProcessor::process_updateSearch;
    processMap_["expungeSearch"] = &NoteStoreProcessor::process_expungeSearch;
    processMap_["findNoteOffset"] = &NoteStoreProcessor::process_findNoteOffset;
    processMap_["findNotesMetadata"] = &NoteStoreProcessor::process_findNotesMetadata;
    processMap_["findNoteCounts"] = &NoteStoreProcessor::process_findNoteCounts;
    processMap_["getNoteWithResultSpec"] = &NoteStoreProcessor::process_getNoteWithResultSpec;
    processMap_["getNote"] = &NoteStoreProcessor::process_getNote;
    processMap_["getNoteApplicationData"] = &NoteStoreProcessor::process_getNoteApplicationData;
    processMap_["getNoteApplicationDataEntry"] = &NoteStoreProcessor::process_getNoteApplicationDataEntry;
    processMap_["setNoteApplicationDataEntry"] = &NoteStoreProcessor::process_setNoteApplicationDataEntry;
    processMap_["unsetNoteApplicationDataEntry"] = &NoteStoreProcessor::process_unsetNoteApplicationDataEntry;
    processMap_["getNoteContent"] = &NoteStoreProcessor::process_getNoteContent;
    processMap_["getNoteSearchText"] = &NoteStoreProcessor::process_getNoteSearchText;
    processMap_["getResourceSearchText"] = &NoteStoreProcessor::process_getResourceSearchText;
    processMap_["getNoteTagNames"] = &NoteStoreProcessor::process_getNoteTagNames;
    processMap_["createNote"] = &NoteStoreProcessor::process_createNote;
    processMap_["updateNote"] = &NoteStoreProcessor::process_updateNote;
    processMap_["deleteNote"] = &NoteStoreProcessor::process_deleteNote;
    processMap_["expungeNote"] = &NoteStoreProcessor::process_expungeNote;
    processMap_["copyNote"] = &NoteStoreProcessor::process_copyNote;
    processMap_["listNoteVersions"] = &NoteStoreProcessor::process_listNoteVersions;
    processMap_["getNoteVersion"] = &NoteStoreProcessor::process_getNoteVersion;
    processMap_["getResource"] = &NoteStoreProcessor::process_getResource;
    processMap_["getResourceApplicationData"] = &NoteStoreProcessor::process_getResourceApplicationData;
    processMap_["getResourceApplicationDataEntry"] = &NoteStoreProcessor::process_getResourceApplicationDataEntry;
    processMap_["setResourceApplicationDataEntry"] = &NoteStoreProcessor::process_setResourceApplicationDataEntry;
    processMap_["unsetResourceApplicationDataEntry"] = &NoteStoreProcessor::process_unsetResourceApplicationDataEntry;
    processMap_["updateResource"] = &NoteStoreProcessor::process_updateResource;
    processMap_["getResourceData"] = &NoteStoreProcessor::process_getResourceData;
    processMap_["getResourceByHash"] = &NoteStoreProcessor::process_getResourceByHash;
    processMap_["getResourceRecognition"] = &NoteStoreProcessor::process_getResourceRecognition;
    processMap_["getResourceAlternateData"] = &NoteStoreProcessor::process_getResourceAlternateData;
    processMap_["getResourceAttributes"] = &NoteStoreProcessor::process_getResourceAttributes;
    processMap_["getPublicNotebook"] = &NoteStoreProcessor::process_getPublicNotebook;
    processMap_["shareNotebook"] = &NoteStoreProcessor::process_shareNotebook;
    processMap_["createOrUpdateNotebookShares"] = &NoteStoreProcessor::process_createOrUpdateNotebookShares;
    processMap_["updateSharedNotebook"] = &NoteStoreProcessor::process_updateSharedNotebook;
    processMap_["setNotebookRecipientSettings"] = &NoteStoreProcessor::process_setNotebookRecipientSettings;
    processMap_["listSharedNotebooks"] = &NoteStoreProcessor::process_listSharedNotebooks;
    processMap_["createLinkedNotebook"] = &NoteStoreProcessor::process_createLinkedNotebook;
    processMap_["updateLinkedNotebook"] = &NoteStoreProcessor::process_updateLinkedNotebook;
    processMap_["listLinkedNotebooks"] = &NoteStoreProcessor::process_listLinkedNotebooks;
    processMap_["expungeLinkedNotebook"] = &NoteStoreProcessor::process_expungeLinkedNotebook;
    processMap_["authenticateToSharedNotebook"] = &NoteStoreProcessor::process_authenticateToSharedNotebook;
    processMap_["getSharedNotebookByAuth"] = &NoteStoreProcessor::process_getSharedNotebookByAuth;
    processMap_["emailNote"] = &NoteStoreProcessor::process_emailNote;
    processMap_["shareNote"] = &NoteStoreProcessor::process_shareNote;
    processMap_["stopSharingNote"] = &NoteStoreProcessor::process_stopSharingNote;
    processMap_["authenticateToSharedNote"] = &NoteStoreProcessor::process_authenticateToSharedNote;
    processMap_["findRelated"] = &NoteStoreProcessor::process_findRelated;
    processMap_["updateNoteIfUsnMatches"] = &NoteStoreProcessor::process_updateNoteIfUsnMatches;
    processMap_["manageNotebookShares"] = &NoteStoreProcessor::process_manageNotebookShares;
    processMap_["getNotebookShares"] = &NoteStoreProcessor::process_getNotebookShares;
  }

  virtual ~NoteStoreProcessor() {}
};

class NoteStoreProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  NoteStoreProcessorFactory(const ::boost::shared_ptr< NoteStoreIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< NoteStoreIfFactory > handlerFactory_;
};

class NoteStoreMultiface : virtual public NoteStoreIf {
 public:
  NoteStoreMultiface(std::vector<boost::shared_ptr<NoteStoreIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~NoteStoreMultiface() {}
 protected:
  std::vector<boost::shared_ptr<NoteStoreIf> > ifaces_;
  NoteStoreMultiface() {}
  void add(boost::shared_ptr<NoteStoreIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void getSyncState(SyncState& _return, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getSyncState(_return, authenticationToken);
    }
    ifaces_[i]->getSyncState(_return, authenticationToken);
    return;
  }

  void getFilteredSyncChunk(SyncChunk& _return, const std::string& authenticationToken, const int32_t afterUSN, const int32_t maxEntries, const SyncChunkFilter& filter) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getFilteredSyncChunk(_return, authenticationToken, afterUSN, maxEntries, filter);
    }
    ifaces_[i]->getFilteredSyncChunk(_return, authenticationToken, afterUSN, maxEntries, filter);
    return;
  }

  void getLinkedNotebookSyncState(SyncState& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getLinkedNotebookSyncState(_return, authenticationToken, linkedNotebook);
    }
    ifaces_[i]->getLinkedNotebookSyncState(_return, authenticationToken, linkedNotebook);
    return;
  }

  void getLinkedNotebookSyncChunk(SyncChunk& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook, const int32_t afterUSN, const int32_t maxEntries, const bool fullSyncOnly) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getLinkedNotebookSyncChunk(_return, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly);
    }
    ifaces_[i]->getLinkedNotebookSyncChunk(_return, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly);
    return;
  }

  void listNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listNotebooks(_return, authenticationToken);
    }
    ifaces_[i]->listNotebooks(_return, authenticationToken);
    return;
  }

  void listAccessibleBusinessNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listAccessibleBusinessNotebooks(_return, authenticationToken);
    }
    ifaces_[i]->listAccessibleBusinessNotebooks(_return, authenticationToken);
    return;
  }

  void getNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNotebook(_return, authenticationToken, guid);
    }
    ifaces_[i]->getNotebook(_return, authenticationToken, guid);
    return;
  }

  void getDefaultNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDefaultNotebook(_return, authenticationToken);
    }
    ifaces_[i]->getDefaultNotebook(_return, authenticationToken);
    return;
  }

  void createNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createNotebook(_return, authenticationToken, notebook);
    }
    ifaces_[i]->createNotebook(_return, authenticationToken, notebook);
    return;
  }

  int32_t updateNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateNotebook(authenticationToken, notebook);
    }
    return ifaces_[i]->updateNotebook(authenticationToken, notebook);
  }

  int32_t expungeNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->expungeNotebook(authenticationToken, guid);
    }
    return ifaces_[i]->expungeNotebook(authenticationToken, guid);
  }

  void listTags(std::vector< ::evernote::edam::Tag> & _return, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listTags(_return, authenticationToken);
    }
    ifaces_[i]->listTags(_return, authenticationToken);
    return;
  }

  void listTagsByNotebook(std::vector< ::evernote::edam::Tag> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& notebookGuid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listTagsByNotebook(_return, authenticationToken, notebookGuid);
    }
    ifaces_[i]->listTagsByNotebook(_return, authenticationToken, notebookGuid);
    return;
  }

  void getTag( ::evernote::edam::Tag& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTag(_return, authenticationToken, guid);
    }
    ifaces_[i]->getTag(_return, authenticationToken, guid);
    return;
  }

  void createTag( ::evernote::edam::Tag& _return, const std::string& authenticationToken, const  ::evernote::edam::Tag& tag) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createTag(_return, authenticationToken, tag);
    }
    ifaces_[i]->createTag(_return, authenticationToken, tag);
    return;
  }

  int32_t updateTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateTag(authenticationToken, tag);
    }
    return ifaces_[i]->updateTag(authenticationToken, tag);
  }

  void untagAll(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->untagAll(authenticationToken, guid);
    }
    ifaces_[i]->untagAll(authenticationToken, guid);
  }

  int32_t expungeTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->expungeTag(authenticationToken, guid);
    }
    return ifaces_[i]->expungeTag(authenticationToken, guid);
  }

  void listSearches(std::vector< ::evernote::edam::SavedSearch> & _return, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listSearches(_return, authenticationToken);
    }
    ifaces_[i]->listSearches(_return, authenticationToken);
    return;
  }

  void getSearch( ::evernote::edam::SavedSearch& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getSearch(_return, authenticationToken, guid);
    }
    ifaces_[i]->getSearch(_return, authenticationToken, guid);
    return;
  }

  void createSearch( ::evernote::edam::SavedSearch& _return, const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createSearch(_return, authenticationToken, search);
    }
    ifaces_[i]->createSearch(_return, authenticationToken, search);
    return;
  }

  int32_t updateSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateSearch(authenticationToken, search);
    }
    return ifaces_[i]->updateSearch(authenticationToken, search);
  }

  int32_t expungeSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->expungeSearch(authenticationToken, guid);
    }
    return ifaces_[i]->expungeSearch(authenticationToken, guid);
  }

  int32_t findNoteOffset(const std::string& authenticationToken, const NoteFilter& filter, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->findNoteOffset(authenticationToken, filter, guid);
    }
    return ifaces_[i]->findNoteOffset(authenticationToken, filter, guid);
  }

  void findNotesMetadata(NotesMetadataList& _return, const std::string& authenticationToken, const NoteFilter& filter, const int32_t offset, const int32_t maxNotes, const NotesMetadataResultSpec& resultSpec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->findNotesMetadata(_return, authenticationToken, filter, offset, maxNotes, resultSpec);
    }
    ifaces_[i]->findNotesMetadata(_return, authenticationToken, filter, offset, maxNotes, resultSpec);
    return;
  }

  void findNoteCounts(NoteCollectionCounts& _return, const std::string& authenticationToken, const NoteFilter& filter, const bool withTrash) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->findNoteCounts(_return, authenticationToken, filter, withTrash);
    }
    ifaces_[i]->findNoteCounts(_return, authenticationToken, filter, withTrash);
    return;
  }

  void getNoteWithResultSpec( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const NoteResultSpec& resultSpec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNoteWithResultSpec(_return, authenticationToken, guid, resultSpec);
    }
    ifaces_[i]->getNoteWithResultSpec(_return, authenticationToken, guid, resultSpec);
    return;
  }

  void getNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withContent, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNote(_return, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
    }
    ifaces_[i]->getNote(_return, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
    return;
  }

  void getNoteApplicationData( ::evernote::edam::LazyMap& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNoteApplicationData(_return, authenticationToken, guid);
    }
    ifaces_[i]->getNoteApplicationData(_return, authenticationToken, guid);
    return;
  }

  void getNoteApplicationDataEntry(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNoteApplicationDataEntry(_return, authenticationToken, guid, key);
    }
    ifaces_[i]->getNoteApplicationDataEntry(_return, authenticationToken, guid, key);
    return;
  }

  int32_t setNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setNoteApplicationDataEntry(authenticationToken, guid, key, value);
    }
    return ifaces_[i]->setNoteApplicationDataEntry(authenticationToken, guid, key, value);
  }

  int32_t unsetNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unsetNoteApplicationDataEntry(authenticationToken, guid, key);
    }
    return ifaces_[i]->unsetNoteApplicationDataEntry(authenticationToken, guid, key);
  }

  void getNoteContent(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNoteContent(_return, authenticationToken, guid);
    }
    ifaces_[i]->getNoteContent(_return, authenticationToken, guid);
    return;
  }

  void getNoteSearchText(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool noteOnly, const bool tokenizeForIndexing) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNoteSearchText(_return, authenticationToken, guid, noteOnly, tokenizeForIndexing);
    }
    ifaces_[i]->getNoteSearchText(_return, authenticationToken, guid, noteOnly, tokenizeForIndexing);
    return;
  }

  void getResourceSearchText(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getResourceSearchText(_return, authenticationToken, guid);
    }
    ifaces_[i]->getResourceSearchText(_return, authenticationToken, guid);
    return;
  }

  void getNoteTagNames(std::vector<std::string> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNoteTagNames(_return, authenticationToken, guid);
    }
    ifaces_[i]->getNoteTagNames(_return, authenticationToken, guid);
    return;
  }

  void createNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createNote(_return, authenticationToken, note);
    }
    ifaces_[i]->createNote(_return, authenticationToken, note);
    return;
  }

  void updateNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateNote(_return, authenticationToken, note);
    }
    ifaces_[i]->updateNote(_return, authenticationToken, note);
    return;
  }

  int32_t deleteNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteNote(authenticationToken, guid);
    }
    return ifaces_[i]->deleteNote(authenticationToken, guid);
  }

  int32_t expungeNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->expungeNote(authenticationToken, guid);
    }
    return ifaces_[i]->expungeNote(authenticationToken, guid);
  }

  void copyNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const  ::evernote::edam::Guid& toNotebookGuid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->copyNote(_return, authenticationToken, noteGuid, toNotebookGuid);
    }
    ifaces_[i]->copyNote(_return, authenticationToken, noteGuid, toNotebookGuid);
    return;
  }

  void listNoteVersions(std::vector<NoteVersionId> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listNoteVersions(_return, authenticationToken, noteGuid);
    }
    ifaces_[i]->listNoteVersions(_return, authenticationToken, noteGuid);
    return;
  }

  void getNoteVersion( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const int32_t updateSequenceNum, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNoteVersion(_return, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
    }
    ifaces_[i]->getNoteVersion(_return, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
    return;
  }

  void getResource( ::evernote::edam::Resource& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withData, const bool withRecognition, const bool withAttributes, const bool withAlternateData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getResource(_return, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData);
    }
    ifaces_[i]->getResource(_return, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData);
    return;
  }

  void getResourceApplicationData( ::evernote::edam::LazyMap& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getResourceApplicationData(_return, authenticationToken, guid);
    }
    ifaces_[i]->getResourceApplicationData(_return, authenticationToken, guid);
    return;
  }

  void getResourceApplicationDataEntry(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getResourceApplicationDataEntry(_return, authenticationToken, guid, key);
    }
    ifaces_[i]->getResourceApplicationDataEntry(_return, authenticationToken, guid, key);
    return;
  }

  int32_t setResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setResourceApplicationDataEntry(authenticationToken, guid, key, value);
    }
    return ifaces_[i]->setResourceApplicationDataEntry(authenticationToken, guid, key, value);
  }

  int32_t unsetResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unsetResourceApplicationDataEntry(authenticationToken, guid, key);
    }
    return ifaces_[i]->unsetResourceApplicationDataEntry(authenticationToken, guid, key);
  }

  int32_t updateResource(const std::string& authenticationToken, const  ::evernote::edam::Resource& resource) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateResource(authenticationToken, resource);
    }
    return ifaces_[i]->updateResource(authenticationToken, resource);
  }

  void getResourceData(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getResourceData(_return, authenticationToken, guid);
    }
    ifaces_[i]->getResourceData(_return, authenticationToken, guid);
    return;
  }

  void getResourceByHash( ::evernote::edam::Resource& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const std::string& contentHash, const bool withData, const bool withRecognition, const bool withAlternateData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getResourceByHash(_return, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData);
    }
    ifaces_[i]->getResourceByHash(_return, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData);
    return;
  }

  void getResourceRecognition(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getResourceRecognition(_return, authenticationToken, guid);
    }
    ifaces_[i]->getResourceRecognition(_return, authenticationToken, guid);
    return;
  }

  void getResourceAlternateData(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getResourceAlternateData(_return, authenticationToken, guid);
    }
    ifaces_[i]->getResourceAlternateData(_return, authenticationToken, guid);
    return;
  }

  void getResourceAttributes( ::evernote::edam::ResourceAttributes& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getResourceAttributes(_return, authenticationToken, guid);
    }
    ifaces_[i]->getResourceAttributes(_return, authenticationToken, guid);
    return;
  }

  void getPublicNotebook( ::evernote::edam::Notebook& _return, const  ::evernote::edam::UserID userId, const std::string& publicUri) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getPublicNotebook(_return, userId, publicUri);
    }
    ifaces_[i]->getPublicNotebook(_return, userId, publicUri);
    return;
  }

  void shareNotebook( ::evernote::edam::SharedNotebook& _return, const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook, const std::string& message) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->shareNotebook(_return, authenticationToken, sharedNotebook, message);
    }
    ifaces_[i]->shareNotebook(_return, authenticationToken, sharedNotebook, message);
    return;
  }

  void createOrUpdateNotebookShares(CreateOrUpdateNotebookSharesResult& _return, const std::string& authenticationToken, const NotebookShareTemplate& shareTemplate) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createOrUpdateNotebookShares(_return, authenticationToken, shareTemplate);
    }
    ifaces_[i]->createOrUpdateNotebookShares(_return, authenticationToken, shareTemplate);
    return;
  }

  int32_t updateSharedNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateSharedNotebook(authenticationToken, sharedNotebook);
    }
    return ifaces_[i]->updateSharedNotebook(authenticationToken, sharedNotebook);
  }

  void setNotebookRecipientSettings( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const std::string& notebookGuid, const  ::evernote::edam::NotebookRecipientSettings& recipientSettings) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setNotebookRecipientSettings(_return, authenticationToken, notebookGuid, recipientSettings);
    }
    ifaces_[i]->setNotebookRecipientSettings(_return, authenticationToken, notebookGuid, recipientSettings);
    return;
  }

  void listSharedNotebooks(std::vector< ::evernote::edam::SharedNotebook> & _return, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listSharedNotebooks(_return, authenticationToken);
    }
    ifaces_[i]->listSharedNotebooks(_return, authenticationToken);
    return;
  }

  void createLinkedNotebook( ::evernote::edam::LinkedNotebook& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createLinkedNotebook(_return, authenticationToken, linkedNotebook);
    }
    ifaces_[i]->createLinkedNotebook(_return, authenticationToken, linkedNotebook);
    return;
  }

  int32_t updateLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateLinkedNotebook(authenticationToken, linkedNotebook);
    }
    return ifaces_[i]->updateLinkedNotebook(authenticationToken, linkedNotebook);
  }

  void listLinkedNotebooks(std::vector< ::evernote::edam::LinkedNotebook> & _return, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listLinkedNotebooks(_return, authenticationToken);
    }
    ifaces_[i]->listLinkedNotebooks(_return, authenticationToken);
    return;
  }

  int32_t expungeLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->expungeLinkedNotebook(authenticationToken, guid);
    }
    return ifaces_[i]->expungeLinkedNotebook(authenticationToken, guid);
  }

  void authenticateToSharedNotebook( ::evernote::edam::AuthenticationResult& _return, const std::string& shareKeyOrGlobalId, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->authenticateToSharedNotebook(_return, shareKeyOrGlobalId, authenticationToken);
    }
    ifaces_[i]->authenticateToSharedNotebook(_return, shareKeyOrGlobalId, authenticationToken);
    return;
  }

  void getSharedNotebookByAuth( ::evernote::edam::SharedNotebook& _return, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getSharedNotebookByAuth(_return, authenticationToken);
    }
    ifaces_[i]->getSharedNotebookByAuth(_return, authenticationToken);
    return;
  }

  void emailNote(const std::string& authenticationToken, const NoteEmailParameters& parameters) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->emailNote(authenticationToken, parameters);
    }
    ifaces_[i]->emailNote(authenticationToken, parameters);
  }

  void shareNote(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->shareNote(_return, authenticationToken, guid);
    }
    ifaces_[i]->shareNote(_return, authenticationToken, guid);
    return;
  }

  void stopSharingNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->stopSharingNote(authenticationToken, guid);
    }
    ifaces_[i]->stopSharingNote(authenticationToken, guid);
  }

  void authenticateToSharedNote( ::evernote::edam::AuthenticationResult& _return, const std::string& guid, const std::string& noteKey, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->authenticateToSharedNote(_return, guid, noteKey, authenticationToken);
    }
    ifaces_[i]->authenticateToSharedNote(_return, guid, noteKey, authenticationToken);
    return;
  }

  void findRelated(RelatedResult& _return, const std::string& authenticationToken, const RelatedQuery& query, const RelatedResultSpec& resultSpec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->findRelated(_return, authenticationToken, query, resultSpec);
    }
    ifaces_[i]->findRelated(_return, authenticationToken, query, resultSpec);
    return;
  }

  void updateNoteIfUsnMatches(UpdateNoteIfUsnMatchesResult& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateNoteIfUsnMatches(_return, authenticationToken, note);
    }
    ifaces_[i]->updateNoteIfUsnMatches(_return, authenticationToken, note);
    return;
  }

  void manageNotebookShares(ManageNotebookSharesResult& _return, const std::string& authenticationToken, const ManageNotebookSharesParameters& parameters) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->manageNotebookShares(_return, authenticationToken, parameters);
    }
    ifaces_[i]->manageNotebookShares(_return, authenticationToken, parameters);
    return;
  }

  void getNotebookShares(ShareRelationships& _return, const std::string& authenticationToken, const std::string& notebookGuid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNotebookShares(_return, authenticationToken, notebookGuid);
    }
    ifaces_[i]->getNotebookShares(_return, authenticationToken, notebookGuid);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class NoteStoreConcurrentClient : virtual public NoteStoreIf {
 public:
  NoteStoreConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  NoteStoreConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void getSyncState(SyncState& _return, const std::string& authenticationToken);
  int32_t send_getSyncState(const std::string& authenticationToken);
  void recv_getSyncState(SyncState& _return, const int32_t seqid);
  void getFilteredSyncChunk(SyncChunk& _return, const std::string& authenticationToken, const int32_t afterUSN, const int32_t maxEntries, const SyncChunkFilter& filter);
  int32_t send_getFilteredSyncChunk(const std::string& authenticationToken, const int32_t afterUSN, const int32_t maxEntries, const SyncChunkFilter& filter);
  void recv_getFilteredSyncChunk(SyncChunk& _return, const int32_t seqid);
  void getLinkedNotebookSyncState(SyncState& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook);
  int32_t send_getLinkedNotebookSyncState(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook);
  void recv_getLinkedNotebookSyncState(SyncState& _return, const int32_t seqid);
  void getLinkedNotebookSyncChunk(SyncChunk& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook, const int32_t afterUSN, const int32_t maxEntries, const bool fullSyncOnly);
  int32_t send_getLinkedNotebookSyncChunk(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook, const int32_t afterUSN, const int32_t maxEntries, const bool fullSyncOnly);
  void recv_getLinkedNotebookSyncChunk(SyncChunk& _return, const int32_t seqid);
  void listNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const std::string& authenticationToken);
  int32_t send_listNotebooks(const std::string& authenticationToken);
  void recv_listNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const int32_t seqid);
  void listAccessibleBusinessNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const std::string& authenticationToken);
  int32_t send_listAccessibleBusinessNotebooks(const std::string& authenticationToken);
  void recv_listAccessibleBusinessNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const int32_t seqid);
  void getNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_getNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getNotebook( ::evernote::edam::Notebook& _return, const int32_t seqid);
  void getDefaultNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken);
  int32_t send_getDefaultNotebook(const std::string& authenticationToken);
  void recv_getDefaultNotebook( ::evernote::edam::Notebook& _return, const int32_t seqid);
  void createNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook);
  int32_t send_createNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook);
  void recv_createNotebook( ::evernote::edam::Notebook& _return, const int32_t seqid);
  int32_t updateNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook);
  int32_t send_updateNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook);
  int32_t recv_updateNotebook(const int32_t seqid);
  int32_t expungeNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_expungeNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t recv_expungeNotebook(const int32_t seqid);
  void listTags(std::vector< ::evernote::edam::Tag> & _return, const std::string& authenticationToken);
  int32_t send_listTags(const std::string& authenticationToken);
  void recv_listTags(std::vector< ::evernote::edam::Tag> & _return, const int32_t seqid);
  void listTagsByNotebook(std::vector< ::evernote::edam::Tag> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& notebookGuid);
  int32_t send_listTagsByNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& notebookGuid);
  void recv_listTagsByNotebook(std::vector< ::evernote::edam::Tag> & _return, const int32_t seqid);
  void getTag( ::evernote::edam::Tag& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_getTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getTag( ::evernote::edam::Tag& _return, const int32_t seqid);
  void createTag( ::evernote::edam::Tag& _return, const std::string& authenticationToken, const  ::evernote::edam::Tag& tag);
  int32_t send_createTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag);
  void recv_createTag( ::evernote::edam::Tag& _return, const int32_t seqid);
  int32_t updateTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag);
  int32_t send_updateTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag);
  int32_t recv_updateTag(const int32_t seqid);
  void untagAll(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_untagAll(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_untagAll(const int32_t seqid);
  int32_t expungeTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_expungeTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t recv_expungeTag(const int32_t seqid);
  void listSearches(std::vector< ::evernote::edam::SavedSearch> & _return, const std::string& authenticationToken);
  int32_t send_listSearches(const std::string& authenticationToken);
  void recv_listSearches(std::vector< ::evernote::edam::SavedSearch> & _return, const int32_t seqid);
  void getSearch( ::evernote::edam::SavedSearch& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_getSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getSearch( ::evernote::edam::SavedSearch& _return, const int32_t seqid);
  void createSearch( ::evernote::edam::SavedSearch& _return, const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search);
  int32_t send_createSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search);
  void recv_createSearch( ::evernote::edam::SavedSearch& _return, const int32_t seqid);
  int32_t updateSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search);
  int32_t send_updateSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search);
  int32_t recv_updateSearch(const int32_t seqid);
  int32_t expungeSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_expungeSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t recv_expungeSearch(const int32_t seqid);
  int32_t findNoteOffset(const std::string& authenticationToken, const NoteFilter& filter, const  ::evernote::edam::Guid& guid);
  int32_t send_findNoteOffset(const std::string& authenticationToken, const NoteFilter& filter, const  ::evernote::edam::Guid& guid);
  int32_t recv_findNoteOffset(const int32_t seqid);
  void findNotesMetadata(NotesMetadataList& _return, const std::string& authenticationToken, const NoteFilter& filter, const int32_t offset, const int32_t maxNotes, const NotesMetadataResultSpec& resultSpec);
  int32_t send_findNotesMetadata(const std::string& authenticationToken, const NoteFilter& filter, const int32_t offset, const int32_t maxNotes, const NotesMetadataResultSpec& resultSpec);
  void recv_findNotesMetadata(NotesMetadataList& _return, const int32_t seqid);
  void findNoteCounts(NoteCollectionCounts& _return, const std::string& authenticationToken, const NoteFilter& filter, const bool withTrash);
  int32_t send_findNoteCounts(const std::string& authenticationToken, const NoteFilter& filter, const bool withTrash);
  void recv_findNoteCounts(NoteCollectionCounts& _return, const int32_t seqid);
  void getNoteWithResultSpec( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const NoteResultSpec& resultSpec);
  int32_t send_getNoteWithResultSpec(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const NoteResultSpec& resultSpec);
  void recv_getNoteWithResultSpec( ::evernote::edam::Note& _return, const int32_t seqid);
  void getNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withContent, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData);
  int32_t send_getNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withContent, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData);
  void recv_getNote( ::evernote::edam::Note& _return, const int32_t seqid);
  void getNoteApplicationData( ::evernote::edam::LazyMap& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_getNoteApplicationData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getNoteApplicationData( ::evernote::edam::LazyMap& _return, const int32_t seqid);
  void getNoteApplicationDataEntry(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  int32_t send_getNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  void recv_getNoteApplicationDataEntry(std::string& _return, const int32_t seqid);
  int32_t setNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value);
  int32_t send_setNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value);
  int32_t recv_setNoteApplicationDataEntry(const int32_t seqid);
  int32_t unsetNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  int32_t send_unsetNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  int32_t recv_unsetNoteApplicationDataEntry(const int32_t seqid);
  void getNoteContent(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_getNoteContent(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getNoteContent(std::string& _return, const int32_t seqid);
  void getNoteSearchText(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool noteOnly, const bool tokenizeForIndexing);
  int32_t send_getNoteSearchText(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool noteOnly, const bool tokenizeForIndexing);
  void recv_getNoteSearchText(std::string& _return, const int32_t seqid);
  void getResourceSearchText(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_getResourceSearchText(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getResourceSearchText(std::string& _return, const int32_t seqid);
  void getNoteTagNames(std::vector<std::string> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_getNoteTagNames(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getNoteTagNames(std::vector<std::string> & _return, const int32_t seqid);
  void createNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note);
  int32_t send_createNote(const std::string& authenticationToken, const  ::evernote::edam::Note& note);
  void recv_createNote( ::evernote::edam::Note& _return, const int32_t seqid);
  void updateNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note);
  int32_t send_updateNote(const std::string& authenticationToken, const  ::evernote::edam::Note& note);
  void recv_updateNote( ::evernote::edam::Note& _return, const int32_t seqid);
  int32_t deleteNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_deleteNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t recv_deleteNote(const int32_t seqid);
  int32_t expungeNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_expungeNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t recv_expungeNote(const int32_t seqid);
  void copyNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const  ::evernote::edam::Guid& toNotebookGuid);
  int32_t send_copyNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const  ::evernote::edam::Guid& toNotebookGuid);
  void recv_copyNote( ::evernote::edam::Note& _return, const int32_t seqid);
  void listNoteVersions(std::vector<NoteVersionId> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid);
  int32_t send_listNoteVersions(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid);
  void recv_listNoteVersions(std::vector<NoteVersionId> & _return, const int32_t seqid);
  void getNoteVersion( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const int32_t updateSequenceNum, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData);
  int32_t send_getNoteVersion(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const int32_t updateSequenceNum, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData);
  void recv_getNoteVersion( ::evernote::edam::Note& _return, const int32_t seqid);
  void getResource( ::evernote::edam::Resource& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withData, const bool withRecognition, const bool withAttributes, const bool withAlternateData);
  int32_t send_getResource(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withData, const bool withRecognition, const bool withAttributes, const bool withAlternateData);
  void recv_getResource( ::evernote::edam::Resource& _return, const int32_t seqid);
  void getResourceApplicationData( ::evernote::edam::LazyMap& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_getResourceApplicationData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getResourceApplicationData( ::evernote::edam::LazyMap& _return, const int32_t seqid);
  void getResourceApplicationDataEntry(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  int32_t send_getResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  void recv_getResourceApplicationDataEntry(std::string& _return, const int32_t seqid);
  int32_t setResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value);
  int32_t send_setResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value);
  int32_t recv_setResourceApplicationDataEntry(const int32_t seqid);
  int32_t unsetResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  int32_t send_unsetResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key);
  int32_t recv_unsetResourceApplicationDataEntry(const int32_t seqid);
  int32_t updateResource(const std::string& authenticationToken, const  ::evernote::edam::Resource& resource);
  int32_t send_updateResource(const std::string& authenticationToken, const  ::evernote::edam::Resource& resource);
  int32_t recv_updateResource(const int32_t seqid);
  void getResourceData(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_getResourceData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getResourceData(std::string& _return, const int32_t seqid);
  void getResourceByHash( ::evernote::edam::Resource& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const std::string& contentHash, const bool withData, const bool withRecognition, const bool withAlternateData);
  int32_t send_getResourceByHash(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const std::string& contentHash, const bool withData, const bool withRecognition, const bool withAlternateData);
  void recv_getResourceByHash( ::evernote::edam::Resource& _return, const int32_t seqid);
  void getResourceRecognition(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_getResourceRecognition(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getResourceRecognition(std::string& _return, const int32_t seqid);
  void getResourceAlternateData(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_getResourceAlternateData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getResourceAlternateData(std::string& _return, const int32_t seqid);
  void getResourceAttributes( ::evernote::edam::ResourceAttributes& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_getResourceAttributes(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_getResourceAttributes( ::evernote::edam::ResourceAttributes& _return, const int32_t seqid);
  void getPublicNotebook( ::evernote::edam::Notebook& _return, const  ::evernote::edam::UserID userId, const std::string& publicUri);
  int32_t send_getPublicNotebook(const  ::evernote::edam::UserID userId, const std::string& publicUri);
  void recv_getPublicNotebook( ::evernote::edam::Notebook& _return, const int32_t seqid);
  void shareNotebook( ::evernote::edam::SharedNotebook& _return, const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook, const std::string& message);
  int32_t send_shareNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook, const std::string& message);
  void recv_shareNotebook( ::evernote::edam::SharedNotebook& _return, const int32_t seqid);
  void createOrUpdateNotebookShares(CreateOrUpdateNotebookSharesResult& _return, const std::string& authenticationToken, const NotebookShareTemplate& shareTemplate);
  int32_t send_createOrUpdateNotebookShares(const std::string& authenticationToken, const NotebookShareTemplate& shareTemplate);
  void recv_createOrUpdateNotebookShares(CreateOrUpdateNotebookSharesResult& _return, const int32_t seqid);
  int32_t updateSharedNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook);
  int32_t send_updateSharedNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook);
  int32_t recv_updateSharedNotebook(const int32_t seqid);
  void setNotebookRecipientSettings( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const std::string& notebookGuid, const  ::evernote::edam::NotebookRecipientSettings& recipientSettings);
  int32_t send_setNotebookRecipientSettings(const std::string& authenticationToken, const std::string& notebookGuid, const  ::evernote::edam::NotebookRecipientSettings& recipientSettings);
  void recv_setNotebookRecipientSettings( ::evernote::edam::Notebook& _return, const int32_t seqid);
  void listSharedNotebooks(std::vector< ::evernote::edam::SharedNotebook> & _return, const std::string& authenticationToken);
  int32_t send_listSharedNotebooks(const std::string& authenticationToken);
  void recv_listSharedNotebooks(std::vector< ::evernote::edam::SharedNotebook> & _return, const int32_t seqid);
  void createLinkedNotebook( ::evernote::edam::LinkedNotebook& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook);
  int32_t send_createLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook);
  void recv_createLinkedNotebook( ::evernote::edam::LinkedNotebook& _return, const int32_t seqid);
  int32_t updateLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook);
  int32_t send_updateLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook);
  int32_t recv_updateLinkedNotebook(const int32_t seqid);
  void listLinkedNotebooks(std::vector< ::evernote::edam::LinkedNotebook> & _return, const std::string& authenticationToken);
  int32_t send_listLinkedNotebooks(const std::string& authenticationToken);
  void recv_listLinkedNotebooks(std::vector< ::evernote::edam::LinkedNotebook> & _return, const int32_t seqid);
  int32_t expungeLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_expungeLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t recv_expungeLinkedNotebook(const int32_t seqid);
  void authenticateToSharedNotebook( ::evernote::edam::AuthenticationResult& _return, const std::string& shareKeyOrGlobalId, const std::string& authenticationToken);
  int32_t send_authenticateToSharedNotebook(const std::string& shareKeyOrGlobalId, const std::string& authenticationToken);
  void recv_authenticateToSharedNotebook( ::evernote::edam::AuthenticationResult& _return, const int32_t seqid);
  void getSharedNotebookByAuth( ::evernote::edam::SharedNotebook& _return, const std::string& authenticationToken);
  int32_t send_getSharedNotebookByAuth(const std::string& authenticationToken);
  void recv_getSharedNotebookByAuth( ::evernote::edam::SharedNotebook& _return, const int32_t seqid);
  void emailNote(const std::string& authenticationToken, const NoteEmailParameters& parameters);
  int32_t send_emailNote(const std::string& authenticationToken, const NoteEmailParameters& parameters);
  void recv_emailNote(const int32_t seqid);
  void shareNote(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_shareNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_shareNote(std::string& _return, const int32_t seqid);
  void stopSharingNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  int32_t send_stopSharingNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid);
  void recv_stopSharingNote(const int32_t seqid);
  void authenticateToSharedNote( ::evernote::edam::AuthenticationResult& _return, const std::string& guid, const std::string& noteKey, const std::string& authenticationToken);
  int32_t send_authenticateToSharedNote(const std::string& guid, const std::string& noteKey, const std::string& authenticationToken);
  void recv_authenticateToSharedNote( ::evernote::edam::AuthenticationResult& _return, const int32_t seqid);
  void findRelated(RelatedResult& _return, const std::string& authenticationToken, const RelatedQuery& query, const RelatedResultSpec& resultSpec);
  int32_t send_findRelated(const std::string& authenticationToken, const RelatedQuery& query, const RelatedResultSpec& resultSpec);
  void recv_findRelated(RelatedResult& _return, const int32_t seqid);
  void updateNoteIfUsnMatches(UpdateNoteIfUsnMatchesResult& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note);
  int32_t send_updateNoteIfUsnMatches(const std::string& authenticationToken, const  ::evernote::edam::Note& note);
  void recv_updateNoteIfUsnMatches(UpdateNoteIfUsnMatchesResult& _return, const int32_t seqid);
  void manageNotebookShares(ManageNotebookSharesResult& _return, const std::string& authenticationToken, const ManageNotebookSharesParameters& parameters);
  int32_t send_manageNotebookShares(const std::string& authenticationToken, const ManageNotebookSharesParameters& parameters);
  void recv_manageNotebookShares(ManageNotebookSharesResult& _return, const int32_t seqid);
  void getNotebookShares(ShareRelationships& _return, const std::string& authenticationToken, const std::string& notebookGuid);
  int32_t send_getNotebookShares(const std::string& authenticationToken, const std::string& notebookGuid);
  void recv_getNotebookShares(ShareRelationships& _return, const int32_t seqid);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _WIN32
  #pragma warning( pop )
#endif

}} // namespace

#endif
