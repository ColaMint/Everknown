/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "NoteStore.h"

namespace evernote { namespace edam {


NoteStore_getSyncState_args::~NoteStore_getSyncState_args() throw() {
}


uint32_t NoteStore_getSyncState_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getSyncState_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getSyncState_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getSyncState_pargs::~NoteStore_getSyncState_pargs() throw() {
}


uint32_t NoteStore_getSyncState_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getSyncState_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getSyncState_result::~NoteStore_getSyncState_result() throw() {
}


uint32_t NoteStore_getSyncState_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getSyncState_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getSyncState_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getSyncState_presult::~NoteStore_getSyncState_presult() throw() {
}


uint32_t NoteStore_getSyncState_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getFilteredSyncChunk_args::~NoteStore_getFilteredSyncChunk_args() throw() {
}


uint32_t NoteStore_getFilteredSyncChunk_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->afterUSN);
          this->__isset.afterUSN = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxEntries);
          this->__isset.maxEntries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->filter.read(iprot);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getFilteredSyncChunk_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getFilteredSyncChunk_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("afterUSN", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->afterUSN);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxEntries", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->maxEntries);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->filter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getFilteredSyncChunk_pargs::~NoteStore_getFilteredSyncChunk_pargs() throw() {
}


uint32_t NoteStore_getFilteredSyncChunk_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getFilteredSyncChunk_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("afterUSN", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->afterUSN)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxEntries", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->maxEntries)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->filter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getFilteredSyncChunk_result::~NoteStore_getFilteredSyncChunk_result() throw() {
}


uint32_t NoteStore_getFilteredSyncChunk_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getFilteredSyncChunk_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getFilteredSyncChunk_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getFilteredSyncChunk_presult::~NoteStore_getFilteredSyncChunk_presult() throw() {
}


uint32_t NoteStore_getFilteredSyncChunk_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getLinkedNotebookSyncState_args::~NoteStore_getLinkedNotebookSyncState_args() throw() {
}


uint32_t NoteStore_getLinkedNotebookSyncState_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->linkedNotebook.read(iprot);
          this->__isset.linkedNotebook = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getLinkedNotebookSyncState_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getLinkedNotebookSyncState_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("linkedNotebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->linkedNotebook.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getLinkedNotebookSyncState_pargs::~NoteStore_getLinkedNotebookSyncState_pargs() throw() {
}


uint32_t NoteStore_getLinkedNotebookSyncState_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getLinkedNotebookSyncState_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("linkedNotebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->linkedNotebook)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getLinkedNotebookSyncState_result::~NoteStore_getLinkedNotebookSyncState_result() throw() {
}


uint32_t NoteStore_getLinkedNotebookSyncState_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getLinkedNotebookSyncState_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getLinkedNotebookSyncState_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getLinkedNotebookSyncState_presult::~NoteStore_getLinkedNotebookSyncState_presult() throw() {
}


uint32_t NoteStore_getLinkedNotebookSyncState_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getLinkedNotebookSyncChunk_args::~NoteStore_getLinkedNotebookSyncChunk_args() throw() {
}


uint32_t NoteStore_getLinkedNotebookSyncChunk_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->linkedNotebook.read(iprot);
          this->__isset.linkedNotebook = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->afterUSN);
          this->__isset.afterUSN = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxEntries);
          this->__isset.maxEntries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->fullSyncOnly);
          this->__isset.fullSyncOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getLinkedNotebookSyncChunk_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getLinkedNotebookSyncChunk_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("linkedNotebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->linkedNotebook.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("afterUSN", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->afterUSN);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxEntries", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->maxEntries);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fullSyncOnly", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->fullSyncOnly);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getLinkedNotebookSyncChunk_pargs::~NoteStore_getLinkedNotebookSyncChunk_pargs() throw() {
}


uint32_t NoteStore_getLinkedNotebookSyncChunk_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getLinkedNotebookSyncChunk_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("linkedNotebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->linkedNotebook)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("afterUSN", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->afterUSN)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxEntries", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->maxEntries)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fullSyncOnly", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->fullSyncOnly)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getLinkedNotebookSyncChunk_result::~NoteStore_getLinkedNotebookSyncChunk_result() throw() {
}


uint32_t NoteStore_getLinkedNotebookSyncChunk_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getLinkedNotebookSyncChunk_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getLinkedNotebookSyncChunk_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getLinkedNotebookSyncChunk_presult::~NoteStore_getLinkedNotebookSyncChunk_presult() throw() {
}


uint32_t NoteStore_getLinkedNotebookSyncChunk_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_listNotebooks_args::~NoteStore_listNotebooks_args() throw() {
}


uint32_t NoteStore_listNotebooks_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listNotebooks_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listNotebooks_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listNotebooks_pargs::~NoteStore_listNotebooks_pargs() throw() {
}


uint32_t NoteStore_listNotebooks_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listNotebooks_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listNotebooks_result::~NoteStore_listNotebooks_result() throw() {
}


uint32_t NoteStore_listNotebooks_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size362;
            ::apache::thrift::protocol::TType _etype365;
            xfer += iprot->readListBegin(_etype365, _size362);
            this->success.resize(_size362);
            uint32_t _i366;
            for (_i366 = 0; _i366 < _size362; ++_i366)
            {
              xfer += this->success[_i366].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listNotebooks_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_listNotebooks_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::evernote::edam::Notebook> ::const_iterator _iter367;
      for (_iter367 = this->success.begin(); _iter367 != this->success.end(); ++_iter367)
      {
        xfer += (*_iter367).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listNotebooks_presult::~NoteStore_listNotebooks_presult() throw() {
}


uint32_t NoteStore_listNotebooks_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size368;
            ::apache::thrift::protocol::TType _etype371;
            xfer += iprot->readListBegin(_etype371, _size368);
            (*(this->success)).resize(_size368);
            uint32_t _i372;
            for (_i372 = 0; _i372 < _size368; ++_i372)
            {
              xfer += (*(this->success))[_i372].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_listAccessibleBusinessNotebooks_args::~NoteStore_listAccessibleBusinessNotebooks_args() throw() {
}


uint32_t NoteStore_listAccessibleBusinessNotebooks_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listAccessibleBusinessNotebooks_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listAccessibleBusinessNotebooks_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listAccessibleBusinessNotebooks_pargs::~NoteStore_listAccessibleBusinessNotebooks_pargs() throw() {
}


uint32_t NoteStore_listAccessibleBusinessNotebooks_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listAccessibleBusinessNotebooks_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listAccessibleBusinessNotebooks_result::~NoteStore_listAccessibleBusinessNotebooks_result() throw() {
}


uint32_t NoteStore_listAccessibleBusinessNotebooks_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size373;
            ::apache::thrift::protocol::TType _etype376;
            xfer += iprot->readListBegin(_etype376, _size373);
            this->success.resize(_size373);
            uint32_t _i377;
            for (_i377 = 0; _i377 < _size373; ++_i377)
            {
              xfer += this->success[_i377].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listAccessibleBusinessNotebooks_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_listAccessibleBusinessNotebooks_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::evernote::edam::Notebook> ::const_iterator _iter378;
      for (_iter378 = this->success.begin(); _iter378 != this->success.end(); ++_iter378)
      {
        xfer += (*_iter378).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listAccessibleBusinessNotebooks_presult::~NoteStore_listAccessibleBusinessNotebooks_presult() throw() {
}


uint32_t NoteStore_listAccessibleBusinessNotebooks_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size379;
            ::apache::thrift::protocol::TType _etype382;
            xfer += iprot->readListBegin(_etype382, _size379);
            (*(this->success)).resize(_size379);
            uint32_t _i383;
            for (_i383 = 0; _i383 < _size379; ++_i383)
            {
              xfer += (*(this->success))[_i383].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getNotebook_args::~NoteStore_getNotebook_args() throw() {
}


uint32_t NoteStore_getNotebook_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNotebook_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNotebook_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNotebook_pargs::~NoteStore_getNotebook_pargs() throw() {
}


uint32_t NoteStore_getNotebook_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNotebook_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNotebook_result::~NoteStore_getNotebook_result() throw() {
}


uint32_t NoteStore_getNotebook_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNotebook_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getNotebook_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNotebook_presult::~NoteStore_getNotebook_presult() throw() {
}


uint32_t NoteStore_getNotebook_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getDefaultNotebook_args::~NoteStore_getDefaultNotebook_args() throw() {
}


uint32_t NoteStore_getDefaultNotebook_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getDefaultNotebook_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getDefaultNotebook_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getDefaultNotebook_pargs::~NoteStore_getDefaultNotebook_pargs() throw() {
}


uint32_t NoteStore_getDefaultNotebook_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getDefaultNotebook_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getDefaultNotebook_result::~NoteStore_getDefaultNotebook_result() throw() {
}


uint32_t NoteStore_getDefaultNotebook_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getDefaultNotebook_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getDefaultNotebook_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getDefaultNotebook_presult::~NoteStore_getDefaultNotebook_presult() throw() {
}


uint32_t NoteStore_getDefaultNotebook_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_createNotebook_args::~NoteStore_createNotebook_args() throw() {
}


uint32_t NoteStore_createNotebook_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notebook.read(iprot);
          this->__isset.notebook = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_createNotebook_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_createNotebook_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->notebook.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createNotebook_pargs::~NoteStore_createNotebook_pargs() throw() {
}


uint32_t NoteStore_createNotebook_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_createNotebook_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->notebook)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createNotebook_result::~NoteStore_createNotebook_result() throw() {
}


uint32_t NoteStore_createNotebook_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_createNotebook_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_createNotebook_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createNotebook_presult::~NoteStore_createNotebook_presult() throw() {
}


uint32_t NoteStore_createNotebook_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_updateNotebook_args::~NoteStore_updateNotebook_args() throw() {
}


uint32_t NoteStore_updateNotebook_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notebook.read(iprot);
          this->__isset.notebook = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateNotebook_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateNotebook_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->notebook.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateNotebook_pargs::~NoteStore_updateNotebook_pargs() throw() {
}


uint32_t NoteStore_updateNotebook_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateNotebook_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->notebook)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateNotebook_result::~NoteStore_updateNotebook_result() throw() {
}


uint32_t NoteStore_updateNotebook_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateNotebook_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_updateNotebook_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateNotebook_presult::~NoteStore_updateNotebook_presult() throw() {
}


uint32_t NoteStore_updateNotebook_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_expungeNotebook_args::~NoteStore_expungeNotebook_args() throw() {
}


uint32_t NoteStore_expungeNotebook_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_expungeNotebook_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_expungeNotebook_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeNotebook_pargs::~NoteStore_expungeNotebook_pargs() throw() {
}


uint32_t NoteStore_expungeNotebook_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_expungeNotebook_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeNotebook_result::~NoteStore_expungeNotebook_result() throw() {
}


uint32_t NoteStore_expungeNotebook_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_expungeNotebook_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_expungeNotebook_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeNotebook_presult::~NoteStore_expungeNotebook_presult() throw() {
}


uint32_t NoteStore_expungeNotebook_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_listTags_args::~NoteStore_listTags_args() throw() {
}


uint32_t NoteStore_listTags_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listTags_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listTags_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listTags_pargs::~NoteStore_listTags_pargs() throw() {
}


uint32_t NoteStore_listTags_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listTags_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listTags_result::~NoteStore_listTags_result() throw() {
}


uint32_t NoteStore_listTags_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size384;
            ::apache::thrift::protocol::TType _etype387;
            xfer += iprot->readListBegin(_etype387, _size384);
            this->success.resize(_size384);
            uint32_t _i388;
            for (_i388 = 0; _i388 < _size384; ++_i388)
            {
              xfer += this->success[_i388].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listTags_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_listTags_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::evernote::edam::Tag> ::const_iterator _iter389;
      for (_iter389 = this->success.begin(); _iter389 != this->success.end(); ++_iter389)
      {
        xfer += (*_iter389).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listTags_presult::~NoteStore_listTags_presult() throw() {
}


uint32_t NoteStore_listTags_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size390;
            ::apache::thrift::protocol::TType _etype393;
            xfer += iprot->readListBegin(_etype393, _size390);
            (*(this->success)).resize(_size390);
            uint32_t _i394;
            for (_i394 = 0; _i394 < _size390; ++_i394)
            {
              xfer += (*(this->success))[_i394].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_listTagsByNotebook_args::~NoteStore_listTagsByNotebook_args() throw() {
}


uint32_t NoteStore_listTagsByNotebook_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->notebookGuid);
          this->__isset.notebookGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listTagsByNotebook_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listTagsByNotebook_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notebookGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->notebookGuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listTagsByNotebook_pargs::~NoteStore_listTagsByNotebook_pargs() throw() {
}


uint32_t NoteStore_listTagsByNotebook_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listTagsByNotebook_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notebookGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->notebookGuid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listTagsByNotebook_result::~NoteStore_listTagsByNotebook_result() throw() {
}


uint32_t NoteStore_listTagsByNotebook_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size395;
            ::apache::thrift::protocol::TType _etype398;
            xfer += iprot->readListBegin(_etype398, _size395);
            this->success.resize(_size395);
            uint32_t _i399;
            for (_i399 = 0; _i399 < _size395; ++_i399)
            {
              xfer += this->success[_i399].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listTagsByNotebook_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_listTagsByNotebook_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::evernote::edam::Tag> ::const_iterator _iter400;
      for (_iter400 = this->success.begin(); _iter400 != this->success.end(); ++_iter400)
      {
        xfer += (*_iter400).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listTagsByNotebook_presult::~NoteStore_listTagsByNotebook_presult() throw() {
}


uint32_t NoteStore_listTagsByNotebook_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size401;
            ::apache::thrift::protocol::TType _etype404;
            xfer += iprot->readListBegin(_etype404, _size401);
            (*(this->success)).resize(_size401);
            uint32_t _i405;
            for (_i405 = 0; _i405 < _size401; ++_i405)
            {
              xfer += (*(this->success))[_i405].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getTag_args::~NoteStore_getTag_args() throw() {
}


uint32_t NoteStore_getTag_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getTag_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getTag_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getTag_pargs::~NoteStore_getTag_pargs() throw() {
}


uint32_t NoteStore_getTag_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getTag_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getTag_result::~NoteStore_getTag_result() throw() {
}


uint32_t NoteStore_getTag_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getTag_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getTag_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getTag_presult::~NoteStore_getTag_presult() throw() {
}


uint32_t NoteStore_getTag_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_createTag_args::~NoteStore_createTag_args() throw() {
}


uint32_t NoteStore_createTag_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tag.read(iprot);
          this->__isset.tag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_createTag_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_createTag_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tag.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createTag_pargs::~NoteStore_createTag_pargs() throw() {
}


uint32_t NoteStore_createTag_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_createTag_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->tag)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createTag_result::~NoteStore_createTag_result() throw() {
}


uint32_t NoteStore_createTag_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_createTag_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_createTag_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createTag_presult::~NoteStore_createTag_presult() throw() {
}


uint32_t NoteStore_createTag_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_updateTag_args::~NoteStore_updateTag_args() throw() {
}


uint32_t NoteStore_updateTag_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tag.read(iprot);
          this->__isset.tag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateTag_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateTag_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tag.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateTag_pargs::~NoteStore_updateTag_pargs() throw() {
}


uint32_t NoteStore_updateTag_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateTag_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->tag)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateTag_result::~NoteStore_updateTag_result() throw() {
}


uint32_t NoteStore_updateTag_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateTag_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_updateTag_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateTag_presult::~NoteStore_updateTag_presult() throw() {
}


uint32_t NoteStore_updateTag_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_untagAll_args::~NoteStore_untagAll_args() throw() {
}


uint32_t NoteStore_untagAll_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_untagAll_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_untagAll_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_untagAll_pargs::~NoteStore_untagAll_pargs() throw() {
}


uint32_t NoteStore_untagAll_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_untagAll_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_untagAll_result::~NoteStore_untagAll_result() throw() {
}


uint32_t NoteStore_untagAll_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_untagAll_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_untagAll_result");

  if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_untagAll_presult::~NoteStore_untagAll_presult() throw() {
}


uint32_t NoteStore_untagAll_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_expungeTag_args::~NoteStore_expungeTag_args() throw() {
}


uint32_t NoteStore_expungeTag_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_expungeTag_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_expungeTag_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeTag_pargs::~NoteStore_expungeTag_pargs() throw() {
}


uint32_t NoteStore_expungeTag_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_expungeTag_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeTag_result::~NoteStore_expungeTag_result() throw() {
}


uint32_t NoteStore_expungeTag_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_expungeTag_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_expungeTag_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeTag_presult::~NoteStore_expungeTag_presult() throw() {
}


uint32_t NoteStore_expungeTag_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_listSearches_args::~NoteStore_listSearches_args() throw() {
}


uint32_t NoteStore_listSearches_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listSearches_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listSearches_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listSearches_pargs::~NoteStore_listSearches_pargs() throw() {
}


uint32_t NoteStore_listSearches_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listSearches_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listSearches_result::~NoteStore_listSearches_result() throw() {
}


uint32_t NoteStore_listSearches_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size406;
            ::apache::thrift::protocol::TType _etype409;
            xfer += iprot->readListBegin(_etype409, _size406);
            this->success.resize(_size406);
            uint32_t _i410;
            for (_i410 = 0; _i410 < _size406; ++_i410)
            {
              xfer += this->success[_i410].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listSearches_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_listSearches_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::evernote::edam::SavedSearch> ::const_iterator _iter411;
      for (_iter411 = this->success.begin(); _iter411 != this->success.end(); ++_iter411)
      {
        xfer += (*_iter411).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listSearches_presult::~NoteStore_listSearches_presult() throw() {
}


uint32_t NoteStore_listSearches_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size412;
            ::apache::thrift::protocol::TType _etype415;
            xfer += iprot->readListBegin(_etype415, _size412);
            (*(this->success)).resize(_size412);
            uint32_t _i416;
            for (_i416 = 0; _i416 < _size412; ++_i416)
            {
              xfer += (*(this->success))[_i416].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getSearch_args::~NoteStore_getSearch_args() throw() {
}


uint32_t NoteStore_getSearch_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getSearch_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getSearch_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getSearch_pargs::~NoteStore_getSearch_pargs() throw() {
}


uint32_t NoteStore_getSearch_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getSearch_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getSearch_result::~NoteStore_getSearch_result() throw() {
}


uint32_t NoteStore_getSearch_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getSearch_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getSearch_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getSearch_presult::~NoteStore_getSearch_presult() throw() {
}


uint32_t NoteStore_getSearch_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_createSearch_args::~NoteStore_createSearch_args() throw() {
}


uint32_t NoteStore_createSearch_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->search.read(iprot);
          this->__isset.search = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_createSearch_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_createSearch_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("search", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->search.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createSearch_pargs::~NoteStore_createSearch_pargs() throw() {
}


uint32_t NoteStore_createSearch_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_createSearch_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("search", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->search)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createSearch_result::~NoteStore_createSearch_result() throw() {
}


uint32_t NoteStore_createSearch_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_createSearch_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_createSearch_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createSearch_presult::~NoteStore_createSearch_presult() throw() {
}


uint32_t NoteStore_createSearch_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_updateSearch_args::~NoteStore_updateSearch_args() throw() {
}


uint32_t NoteStore_updateSearch_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->search.read(iprot);
          this->__isset.search = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateSearch_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateSearch_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("search", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->search.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateSearch_pargs::~NoteStore_updateSearch_pargs() throw() {
}


uint32_t NoteStore_updateSearch_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateSearch_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("search", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->search)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateSearch_result::~NoteStore_updateSearch_result() throw() {
}


uint32_t NoteStore_updateSearch_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateSearch_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_updateSearch_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateSearch_presult::~NoteStore_updateSearch_presult() throw() {
}


uint32_t NoteStore_updateSearch_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_expungeSearch_args::~NoteStore_expungeSearch_args() throw() {
}


uint32_t NoteStore_expungeSearch_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_expungeSearch_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_expungeSearch_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeSearch_pargs::~NoteStore_expungeSearch_pargs() throw() {
}


uint32_t NoteStore_expungeSearch_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_expungeSearch_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeSearch_result::~NoteStore_expungeSearch_result() throw() {
}


uint32_t NoteStore_expungeSearch_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_expungeSearch_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_expungeSearch_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeSearch_presult::~NoteStore_expungeSearch_presult() throw() {
}


uint32_t NoteStore_expungeSearch_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_findNoteOffset_args::~NoteStore_findNoteOffset_args() throw() {
}


uint32_t NoteStore_findNoteOffset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->filter.read(iprot);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_findNoteOffset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_findNoteOffset_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->filter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_findNoteOffset_pargs::~NoteStore_findNoteOffset_pargs() throw() {
}


uint32_t NoteStore_findNoteOffset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_findNoteOffset_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->filter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_findNoteOffset_result::~NoteStore_findNoteOffset_result() throw() {
}


uint32_t NoteStore_findNoteOffset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_findNoteOffset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_findNoteOffset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_findNoteOffset_presult::~NoteStore_findNoteOffset_presult() throw() {
}


uint32_t NoteStore_findNoteOffset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_findNotesMetadata_args::~NoteStore_findNotesMetadata_args() throw() {
}


uint32_t NoteStore_findNotesMetadata_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->filter.read(iprot);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxNotes);
          this->__isset.maxNotes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resultSpec.read(iprot);
          this->__isset.resultSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_findNotesMetadata_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_findNotesMetadata_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->filter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxNotes", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->maxNotes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultSpec", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->resultSpec.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_findNotesMetadata_pargs::~NoteStore_findNotesMetadata_pargs() throw() {
}


uint32_t NoteStore_findNotesMetadata_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_findNotesMetadata_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->filter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxNotes", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->maxNotes)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultSpec", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += (*(this->resultSpec)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_findNotesMetadata_result::~NoteStore_findNotesMetadata_result() throw() {
}


uint32_t NoteStore_findNotesMetadata_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_findNotesMetadata_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_findNotesMetadata_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_findNotesMetadata_presult::~NoteStore_findNotesMetadata_presult() throw() {
}


uint32_t NoteStore_findNotesMetadata_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_findNoteCounts_args::~NoteStore_findNoteCounts_args() throw() {
}


uint32_t NoteStore_findNoteCounts_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->filter.read(iprot);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withTrash);
          this->__isset.withTrash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_findNoteCounts_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_findNoteCounts_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->filter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withTrash", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->withTrash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_findNoteCounts_pargs::~NoteStore_findNoteCounts_pargs() throw() {
}


uint32_t NoteStore_findNoteCounts_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_findNoteCounts_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->filter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withTrash", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->withTrash)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_findNoteCounts_result::~NoteStore_findNoteCounts_result() throw() {
}


uint32_t NoteStore_findNoteCounts_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_findNoteCounts_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_findNoteCounts_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_findNoteCounts_presult::~NoteStore_findNoteCounts_presult() throw() {
}


uint32_t NoteStore_findNoteCounts_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getNoteWithResultSpec_args::~NoteStore_getNoteWithResultSpec_args() throw() {
}


uint32_t NoteStore_getNoteWithResultSpec_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resultSpec.read(iprot);
          this->__isset.resultSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteWithResultSpec_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteWithResultSpec_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultSpec", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->resultSpec.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteWithResultSpec_pargs::~NoteStore_getNoteWithResultSpec_pargs() throw() {
}


uint32_t NoteStore_getNoteWithResultSpec_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteWithResultSpec_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultSpec", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->resultSpec)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteWithResultSpec_result::~NoteStore_getNoteWithResultSpec_result() throw() {
}


uint32_t NoteStore_getNoteWithResultSpec_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteWithResultSpec_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getNoteWithResultSpec_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteWithResultSpec_presult::~NoteStore_getNoteWithResultSpec_presult() throw() {
}


uint32_t NoteStore_getNoteWithResultSpec_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getNote_args::~NoteStore_getNote_args() throw() {
}


uint32_t NoteStore_getNote_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withContent);
          this->__isset.withContent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withResourcesData);
          this->__isset.withResourcesData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withResourcesRecognition);
          this->__isset.withResourcesRecognition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withResourcesAlternateData);
          this->__isset.withResourcesAlternateData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNote_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNote_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withContent", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->withContent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withResourcesData", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->withResourcesData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withResourcesRecognition", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->withResourcesRecognition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withResourcesAlternateData", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->withResourcesAlternateData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNote_pargs::~NoteStore_getNote_pargs() throw() {
}


uint32_t NoteStore_getNote_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNote_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withContent", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->withContent)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withResourcesData", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->withResourcesData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withResourcesRecognition", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->withResourcesRecognition)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withResourcesAlternateData", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool((*(this->withResourcesAlternateData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNote_result::~NoteStore_getNote_result() throw() {
}


uint32_t NoteStore_getNote_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNote_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getNote_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNote_presult::~NoteStore_getNote_presult() throw() {
}


uint32_t NoteStore_getNote_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getNoteApplicationData_args::~NoteStore_getNoteApplicationData_args() throw() {
}


uint32_t NoteStore_getNoteApplicationData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteApplicationData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteApplicationData_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteApplicationData_pargs::~NoteStore_getNoteApplicationData_pargs() throw() {
}


uint32_t NoteStore_getNoteApplicationData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteApplicationData_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteApplicationData_result::~NoteStore_getNoteApplicationData_result() throw() {
}


uint32_t NoteStore_getNoteApplicationData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteApplicationData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getNoteApplicationData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteApplicationData_presult::~NoteStore_getNoteApplicationData_presult() throw() {
}


uint32_t NoteStore_getNoteApplicationData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getNoteApplicationDataEntry_args::~NoteStore_getNoteApplicationDataEntry_args() throw() {
}


uint32_t NoteStore_getNoteApplicationDataEntry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteApplicationDataEntry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteApplicationDataEntry_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteApplicationDataEntry_pargs::~NoteStore_getNoteApplicationDataEntry_pargs() throw() {
}


uint32_t NoteStore_getNoteApplicationDataEntry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteApplicationDataEntry_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteApplicationDataEntry_result::~NoteStore_getNoteApplicationDataEntry_result() throw() {
}


uint32_t NoteStore_getNoteApplicationDataEntry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteApplicationDataEntry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getNoteApplicationDataEntry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteApplicationDataEntry_presult::~NoteStore_getNoteApplicationDataEntry_presult() throw() {
}


uint32_t NoteStore_getNoteApplicationDataEntry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_setNoteApplicationDataEntry_args::~NoteStore_setNoteApplicationDataEntry_args() throw() {
}


uint32_t NoteStore_setNoteApplicationDataEntry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_setNoteApplicationDataEntry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_setNoteApplicationDataEntry_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_setNoteApplicationDataEntry_pargs::~NoteStore_setNoteApplicationDataEntry_pargs() throw() {
}


uint32_t NoteStore_setNoteApplicationDataEntry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_setNoteApplicationDataEntry_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_setNoteApplicationDataEntry_result::~NoteStore_setNoteApplicationDataEntry_result() throw() {
}


uint32_t NoteStore_setNoteApplicationDataEntry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_setNoteApplicationDataEntry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_setNoteApplicationDataEntry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_setNoteApplicationDataEntry_presult::~NoteStore_setNoteApplicationDataEntry_presult() throw() {
}


uint32_t NoteStore_setNoteApplicationDataEntry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_unsetNoteApplicationDataEntry_args::~NoteStore_unsetNoteApplicationDataEntry_args() throw() {
}


uint32_t NoteStore_unsetNoteApplicationDataEntry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_unsetNoteApplicationDataEntry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_unsetNoteApplicationDataEntry_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_unsetNoteApplicationDataEntry_pargs::~NoteStore_unsetNoteApplicationDataEntry_pargs() throw() {
}


uint32_t NoteStore_unsetNoteApplicationDataEntry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_unsetNoteApplicationDataEntry_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_unsetNoteApplicationDataEntry_result::~NoteStore_unsetNoteApplicationDataEntry_result() throw() {
}


uint32_t NoteStore_unsetNoteApplicationDataEntry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_unsetNoteApplicationDataEntry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_unsetNoteApplicationDataEntry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_unsetNoteApplicationDataEntry_presult::~NoteStore_unsetNoteApplicationDataEntry_presult() throw() {
}


uint32_t NoteStore_unsetNoteApplicationDataEntry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getNoteContent_args::~NoteStore_getNoteContent_args() throw() {
}


uint32_t NoteStore_getNoteContent_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteContent_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteContent_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteContent_pargs::~NoteStore_getNoteContent_pargs() throw() {
}


uint32_t NoteStore_getNoteContent_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteContent_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteContent_result::~NoteStore_getNoteContent_result() throw() {
}


uint32_t NoteStore_getNoteContent_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteContent_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getNoteContent_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteContent_presult::~NoteStore_getNoteContent_presult() throw() {
}


uint32_t NoteStore_getNoteContent_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getNoteSearchText_args::~NoteStore_getNoteSearchText_args() throw() {
}


uint32_t NoteStore_getNoteSearchText_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->noteOnly);
          this->__isset.noteOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->tokenizeForIndexing);
          this->__isset.tokenizeForIndexing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteSearchText_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteSearchText_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noteOnly", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->noteOnly);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tokenizeForIndexing", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->tokenizeForIndexing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteSearchText_pargs::~NoteStore_getNoteSearchText_pargs() throw() {
}


uint32_t NoteStore_getNoteSearchText_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteSearchText_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noteOnly", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->noteOnly)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tokenizeForIndexing", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->tokenizeForIndexing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteSearchText_result::~NoteStore_getNoteSearchText_result() throw() {
}


uint32_t NoteStore_getNoteSearchText_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteSearchText_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getNoteSearchText_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteSearchText_presult::~NoteStore_getNoteSearchText_presult() throw() {
}


uint32_t NoteStore_getNoteSearchText_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getResourceSearchText_args::~NoteStore_getResourceSearchText_args() throw() {
}


uint32_t NoteStore_getResourceSearchText_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceSearchText_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceSearchText_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceSearchText_pargs::~NoteStore_getResourceSearchText_pargs() throw() {
}


uint32_t NoteStore_getResourceSearchText_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceSearchText_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceSearchText_result::~NoteStore_getResourceSearchText_result() throw() {
}


uint32_t NoteStore_getResourceSearchText_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceSearchText_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getResourceSearchText_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceSearchText_presult::~NoteStore_getResourceSearchText_presult() throw() {
}


uint32_t NoteStore_getResourceSearchText_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getNoteTagNames_args::~NoteStore_getNoteTagNames_args() throw() {
}


uint32_t NoteStore_getNoteTagNames_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteTagNames_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteTagNames_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteTagNames_pargs::~NoteStore_getNoteTagNames_pargs() throw() {
}


uint32_t NoteStore_getNoteTagNames_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteTagNames_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteTagNames_result::~NoteStore_getNoteTagNames_result() throw() {
}


uint32_t NoteStore_getNoteTagNames_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size417;
            ::apache::thrift::protocol::TType _etype420;
            xfer += iprot->readListBegin(_etype420, _size417);
            this->success.resize(_size417);
            uint32_t _i421;
            for (_i421 = 0; _i421 < _size417; ++_i421)
            {
              xfer += iprot->readString(this->success[_i421]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteTagNames_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getNoteTagNames_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter422;
      for (_iter422 = this->success.begin(); _iter422 != this->success.end(); ++_iter422)
      {
        xfer += oprot->writeString((*_iter422));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteTagNames_presult::~NoteStore_getNoteTagNames_presult() throw() {
}


uint32_t NoteStore_getNoteTagNames_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size423;
            ::apache::thrift::protocol::TType _etype426;
            xfer += iprot->readListBegin(_etype426, _size423);
            (*(this->success)).resize(_size423);
            uint32_t _i427;
            for (_i427 = 0; _i427 < _size423; ++_i427)
            {
              xfer += iprot->readString((*(this->success))[_i427]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_createNote_args::~NoteStore_createNote_args() throw() {
}


uint32_t NoteStore_createNote_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->note.read(iprot);
          this->__isset.note = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_createNote_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_createNote_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("note", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->note.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createNote_pargs::~NoteStore_createNote_pargs() throw() {
}


uint32_t NoteStore_createNote_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_createNote_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("note", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->note)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createNote_result::~NoteStore_createNote_result() throw() {
}


uint32_t NoteStore_createNote_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_createNote_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_createNote_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createNote_presult::~NoteStore_createNote_presult() throw() {
}


uint32_t NoteStore_createNote_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_updateNote_args::~NoteStore_updateNote_args() throw() {
}


uint32_t NoteStore_updateNote_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->note.read(iprot);
          this->__isset.note = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateNote_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateNote_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("note", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->note.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateNote_pargs::~NoteStore_updateNote_pargs() throw() {
}


uint32_t NoteStore_updateNote_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateNote_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("note", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->note)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateNote_result::~NoteStore_updateNote_result() throw() {
}


uint32_t NoteStore_updateNote_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateNote_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_updateNote_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateNote_presult::~NoteStore_updateNote_presult() throw() {
}


uint32_t NoteStore_updateNote_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_deleteNote_args::~NoteStore_deleteNote_args() throw() {
}


uint32_t NoteStore_deleteNote_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_deleteNote_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_deleteNote_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_deleteNote_pargs::~NoteStore_deleteNote_pargs() throw() {
}


uint32_t NoteStore_deleteNote_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_deleteNote_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_deleteNote_result::~NoteStore_deleteNote_result() throw() {
}


uint32_t NoteStore_deleteNote_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_deleteNote_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_deleteNote_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_deleteNote_presult::~NoteStore_deleteNote_presult() throw() {
}


uint32_t NoteStore_deleteNote_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_expungeNote_args::~NoteStore_expungeNote_args() throw() {
}


uint32_t NoteStore_expungeNote_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_expungeNote_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_expungeNote_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeNote_pargs::~NoteStore_expungeNote_pargs() throw() {
}


uint32_t NoteStore_expungeNote_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_expungeNote_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeNote_result::~NoteStore_expungeNote_result() throw() {
}


uint32_t NoteStore_expungeNote_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_expungeNote_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_expungeNote_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeNote_presult::~NoteStore_expungeNote_presult() throw() {
}


uint32_t NoteStore_expungeNote_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_copyNote_args::~NoteStore_copyNote_args() throw() {
}


uint32_t NoteStore_copyNote_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->noteGuid);
          this->__isset.noteGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->toNotebookGuid);
          this->__isset.toNotebookGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_copyNote_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_copyNote_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noteGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->noteGuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("toNotebookGuid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->toNotebookGuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_copyNote_pargs::~NoteStore_copyNote_pargs() throw() {
}


uint32_t NoteStore_copyNote_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_copyNote_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noteGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->noteGuid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("toNotebookGuid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->toNotebookGuid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_copyNote_result::~NoteStore_copyNote_result() throw() {
}


uint32_t NoteStore_copyNote_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_copyNote_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_copyNote_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_copyNote_presult::~NoteStore_copyNote_presult() throw() {
}


uint32_t NoteStore_copyNote_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_listNoteVersions_args::~NoteStore_listNoteVersions_args() throw() {
}


uint32_t NoteStore_listNoteVersions_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->noteGuid);
          this->__isset.noteGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listNoteVersions_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listNoteVersions_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noteGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->noteGuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listNoteVersions_pargs::~NoteStore_listNoteVersions_pargs() throw() {
}


uint32_t NoteStore_listNoteVersions_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listNoteVersions_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noteGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->noteGuid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listNoteVersions_result::~NoteStore_listNoteVersions_result() throw() {
}


uint32_t NoteStore_listNoteVersions_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size428;
            ::apache::thrift::protocol::TType _etype431;
            xfer += iprot->readListBegin(_etype431, _size428);
            this->success.resize(_size428);
            uint32_t _i432;
            for (_i432 = 0; _i432 < _size428; ++_i432)
            {
              xfer += this->success[_i432].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listNoteVersions_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_listNoteVersions_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<NoteVersionId> ::const_iterator _iter433;
      for (_iter433 = this->success.begin(); _iter433 != this->success.end(); ++_iter433)
      {
        xfer += (*_iter433).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listNoteVersions_presult::~NoteStore_listNoteVersions_presult() throw() {
}


uint32_t NoteStore_listNoteVersions_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size434;
            ::apache::thrift::protocol::TType _etype437;
            xfer += iprot->readListBegin(_etype437, _size434);
            (*(this->success)).resize(_size434);
            uint32_t _i438;
            for (_i438 = 0; _i438 < _size434; ++_i438)
            {
              xfer += (*(this->success))[_i438].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getNoteVersion_args::~NoteStore_getNoteVersion_args() throw() {
}


uint32_t NoteStore_getNoteVersion_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->noteGuid);
          this->__isset.noteGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->updateSequenceNum);
          this->__isset.updateSequenceNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withResourcesData);
          this->__isset.withResourcesData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withResourcesRecognition);
          this->__isset.withResourcesRecognition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withResourcesAlternateData);
          this->__isset.withResourcesAlternateData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteVersion_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteVersion_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noteGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->noteGuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updateSequenceNum", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->updateSequenceNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withResourcesData", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->withResourcesData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withResourcesRecognition", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->withResourcesRecognition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withResourcesAlternateData", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->withResourcesAlternateData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteVersion_pargs::~NoteStore_getNoteVersion_pargs() throw() {
}


uint32_t NoteStore_getNoteVersion_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNoteVersion_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noteGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->noteGuid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updateSequenceNum", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->updateSequenceNum)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withResourcesData", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->withResourcesData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withResourcesRecognition", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->withResourcesRecognition)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withResourcesAlternateData", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool((*(this->withResourcesAlternateData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteVersion_result::~NoteStore_getNoteVersion_result() throw() {
}


uint32_t NoteStore_getNoteVersion_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNoteVersion_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getNoteVersion_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNoteVersion_presult::~NoteStore_getNoteVersion_presult() throw() {
}


uint32_t NoteStore_getNoteVersion_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getResource_args::~NoteStore_getResource_args() throw() {
}


uint32_t NoteStore_getResource_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withData);
          this->__isset.withData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withRecognition);
          this->__isset.withRecognition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withAttributes);
          this->__isset.withAttributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withAlternateData);
          this->__isset.withAlternateData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResource_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResource_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withData", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->withData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withRecognition", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->withRecognition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withAttributes", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->withAttributes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withAlternateData", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->withAlternateData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResource_pargs::~NoteStore_getResource_pargs() throw() {
}


uint32_t NoteStore_getResource_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResource_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withData", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->withData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withRecognition", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->withRecognition)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withAttributes", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->withAttributes)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withAlternateData", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool((*(this->withAlternateData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResource_result::~NoteStore_getResource_result() throw() {
}


uint32_t NoteStore_getResource_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResource_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getResource_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResource_presult::~NoteStore_getResource_presult() throw() {
}


uint32_t NoteStore_getResource_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getResourceApplicationData_args::~NoteStore_getResourceApplicationData_args() throw() {
}


uint32_t NoteStore_getResourceApplicationData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceApplicationData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceApplicationData_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceApplicationData_pargs::~NoteStore_getResourceApplicationData_pargs() throw() {
}


uint32_t NoteStore_getResourceApplicationData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceApplicationData_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceApplicationData_result::~NoteStore_getResourceApplicationData_result() throw() {
}


uint32_t NoteStore_getResourceApplicationData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceApplicationData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getResourceApplicationData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceApplicationData_presult::~NoteStore_getResourceApplicationData_presult() throw() {
}


uint32_t NoteStore_getResourceApplicationData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getResourceApplicationDataEntry_args::~NoteStore_getResourceApplicationDataEntry_args() throw() {
}


uint32_t NoteStore_getResourceApplicationDataEntry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceApplicationDataEntry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceApplicationDataEntry_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceApplicationDataEntry_pargs::~NoteStore_getResourceApplicationDataEntry_pargs() throw() {
}


uint32_t NoteStore_getResourceApplicationDataEntry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceApplicationDataEntry_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceApplicationDataEntry_result::~NoteStore_getResourceApplicationDataEntry_result() throw() {
}


uint32_t NoteStore_getResourceApplicationDataEntry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceApplicationDataEntry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getResourceApplicationDataEntry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceApplicationDataEntry_presult::~NoteStore_getResourceApplicationDataEntry_presult() throw() {
}


uint32_t NoteStore_getResourceApplicationDataEntry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_setResourceApplicationDataEntry_args::~NoteStore_setResourceApplicationDataEntry_args() throw() {
}


uint32_t NoteStore_setResourceApplicationDataEntry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_setResourceApplicationDataEntry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_setResourceApplicationDataEntry_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_setResourceApplicationDataEntry_pargs::~NoteStore_setResourceApplicationDataEntry_pargs() throw() {
}


uint32_t NoteStore_setResourceApplicationDataEntry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_setResourceApplicationDataEntry_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_setResourceApplicationDataEntry_result::~NoteStore_setResourceApplicationDataEntry_result() throw() {
}


uint32_t NoteStore_setResourceApplicationDataEntry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_setResourceApplicationDataEntry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_setResourceApplicationDataEntry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_setResourceApplicationDataEntry_presult::~NoteStore_setResourceApplicationDataEntry_presult() throw() {
}


uint32_t NoteStore_setResourceApplicationDataEntry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_unsetResourceApplicationDataEntry_args::~NoteStore_unsetResourceApplicationDataEntry_args() throw() {
}


uint32_t NoteStore_unsetResourceApplicationDataEntry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_unsetResourceApplicationDataEntry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_unsetResourceApplicationDataEntry_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_unsetResourceApplicationDataEntry_pargs::~NoteStore_unsetResourceApplicationDataEntry_pargs() throw() {
}


uint32_t NoteStore_unsetResourceApplicationDataEntry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_unsetResourceApplicationDataEntry_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_unsetResourceApplicationDataEntry_result::~NoteStore_unsetResourceApplicationDataEntry_result() throw() {
}


uint32_t NoteStore_unsetResourceApplicationDataEntry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_unsetResourceApplicationDataEntry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_unsetResourceApplicationDataEntry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_unsetResourceApplicationDataEntry_presult::~NoteStore_unsetResourceApplicationDataEntry_presult() throw() {
}


uint32_t NoteStore_unsetResourceApplicationDataEntry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_updateResource_args::~NoteStore_updateResource_args() throw() {
}


uint32_t NoteStore_updateResource_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource.read(iprot);
          this->__isset.resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateResource_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateResource_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resource", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->resource.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateResource_pargs::~NoteStore_updateResource_pargs() throw() {
}


uint32_t NoteStore_updateResource_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateResource_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resource", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->resource)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateResource_result::~NoteStore_updateResource_result() throw() {
}


uint32_t NoteStore_updateResource_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateResource_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_updateResource_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateResource_presult::~NoteStore_updateResource_presult() throw() {
}


uint32_t NoteStore_updateResource_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getResourceData_args::~NoteStore_getResourceData_args() throw() {
}


uint32_t NoteStore_getResourceData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceData_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceData_pargs::~NoteStore_getResourceData_pargs() throw() {
}


uint32_t NoteStore_getResourceData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceData_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceData_result::~NoteStore_getResourceData_result() throw() {
}


uint32_t NoteStore_getResourceData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getResourceData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeBinary(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceData_presult::~NoteStore_getResourceData_presult() throw() {
}


uint32_t NoteStore_getResourceData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getResourceByHash_args::~NoteStore_getResourceByHash_args() throw() {
}


uint32_t NoteStore_getResourceByHash_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->noteGuid);
          this->__isset.noteGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->contentHash);
          this->__isset.contentHash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withData);
          this->__isset.withData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withRecognition);
          this->__isset.withRecognition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withAlternateData);
          this->__isset.withAlternateData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceByHash_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceByHash_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noteGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->noteGuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contentHash", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->contentHash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withData", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->withData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withRecognition", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->withRecognition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withAlternateData", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->withAlternateData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceByHash_pargs::~NoteStore_getResourceByHash_pargs() throw() {
}


uint32_t NoteStore_getResourceByHash_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceByHash_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noteGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->noteGuid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contentHash", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->contentHash)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withData", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->withData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withRecognition", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->withRecognition)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withAlternateData", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool((*(this->withAlternateData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceByHash_result::~NoteStore_getResourceByHash_result() throw() {
}


uint32_t NoteStore_getResourceByHash_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceByHash_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getResourceByHash_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceByHash_presult::~NoteStore_getResourceByHash_presult() throw() {
}


uint32_t NoteStore_getResourceByHash_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getResourceRecognition_args::~NoteStore_getResourceRecognition_args() throw() {
}


uint32_t NoteStore_getResourceRecognition_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceRecognition_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceRecognition_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceRecognition_pargs::~NoteStore_getResourceRecognition_pargs() throw() {
}


uint32_t NoteStore_getResourceRecognition_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceRecognition_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceRecognition_result::~NoteStore_getResourceRecognition_result() throw() {
}


uint32_t NoteStore_getResourceRecognition_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceRecognition_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getResourceRecognition_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeBinary(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceRecognition_presult::~NoteStore_getResourceRecognition_presult() throw() {
}


uint32_t NoteStore_getResourceRecognition_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getResourceAlternateData_args::~NoteStore_getResourceAlternateData_args() throw() {
}


uint32_t NoteStore_getResourceAlternateData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceAlternateData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceAlternateData_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceAlternateData_pargs::~NoteStore_getResourceAlternateData_pargs() throw() {
}


uint32_t NoteStore_getResourceAlternateData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceAlternateData_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceAlternateData_result::~NoteStore_getResourceAlternateData_result() throw() {
}


uint32_t NoteStore_getResourceAlternateData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceAlternateData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getResourceAlternateData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeBinary(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceAlternateData_presult::~NoteStore_getResourceAlternateData_presult() throw() {
}


uint32_t NoteStore_getResourceAlternateData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getResourceAttributes_args::~NoteStore_getResourceAttributes_args() throw() {
}


uint32_t NoteStore_getResourceAttributes_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceAttributes_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceAttributes_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceAttributes_pargs::~NoteStore_getResourceAttributes_pargs() throw() {
}


uint32_t NoteStore_getResourceAttributes_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getResourceAttributes_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceAttributes_result::~NoteStore_getResourceAttributes_result() throw() {
}


uint32_t NoteStore_getResourceAttributes_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getResourceAttributes_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getResourceAttributes_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getResourceAttributes_presult::~NoteStore_getResourceAttributes_presult() throw() {
}


uint32_t NoteStore_getResourceAttributes_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getPublicNotebook_args::~NoteStore_getPublicNotebook_args() throw() {
}


uint32_t NoteStore_getPublicNotebook_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userId);
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->publicUri);
          this->__isset.publicUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getPublicNotebook_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getPublicNotebook_args");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("publicUri", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->publicUri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getPublicNotebook_pargs::~NoteStore_getPublicNotebook_pargs() throw() {
}


uint32_t NoteStore_getPublicNotebook_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getPublicNotebook_pargs");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->userId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("publicUri", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->publicUri)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getPublicNotebook_result::~NoteStore_getPublicNotebook_result() throw() {
}


uint32_t NoteStore_getPublicNotebook_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getPublicNotebook_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getPublicNotebook_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getPublicNotebook_presult::~NoteStore_getPublicNotebook_presult() throw() {
}


uint32_t NoteStore_getPublicNotebook_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_shareNotebook_args::~NoteStore_shareNotebook_args() throw() {
}


uint32_t NoteStore_shareNotebook_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sharedNotebook.read(iprot);
          this->__isset.sharedNotebook = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_shareNotebook_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_shareNotebook_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharedNotebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->sharedNotebook.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_shareNotebook_pargs::~NoteStore_shareNotebook_pargs() throw() {
}


uint32_t NoteStore_shareNotebook_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_shareNotebook_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharedNotebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->sharedNotebook)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->message)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_shareNotebook_result::~NoteStore_shareNotebook_result() throw() {
}


uint32_t NoteStore_shareNotebook_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_shareNotebook_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_shareNotebook_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_shareNotebook_presult::~NoteStore_shareNotebook_presult() throw() {
}


uint32_t NoteStore_shareNotebook_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_createOrUpdateNotebookShares_args::~NoteStore_createOrUpdateNotebookShares_args() throw() {
}


uint32_t NoteStore_createOrUpdateNotebookShares_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->shareTemplate.read(iprot);
          this->__isset.shareTemplate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_createOrUpdateNotebookShares_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_createOrUpdateNotebookShares_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shareTemplate", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->shareTemplate.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createOrUpdateNotebookShares_pargs::~NoteStore_createOrUpdateNotebookShares_pargs() throw() {
}


uint32_t NoteStore_createOrUpdateNotebookShares_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_createOrUpdateNotebookShares_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shareTemplate", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->shareTemplate)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createOrUpdateNotebookShares_result::~NoteStore_createOrUpdateNotebookShares_result() throw() {
}


uint32_t NoteStore_createOrUpdateNotebookShares_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->invalidContactsException.read(iprot);
          this->__isset.invalidContactsException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_createOrUpdateNotebookShares_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_createOrUpdateNotebookShares_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.invalidContactsException) {
    xfer += oprot->writeFieldBegin("invalidContactsException", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->invalidContactsException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createOrUpdateNotebookShares_presult::~NoteStore_createOrUpdateNotebookShares_presult() throw() {
}


uint32_t NoteStore_createOrUpdateNotebookShares_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->invalidContactsException.read(iprot);
          this->__isset.invalidContactsException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_updateSharedNotebook_args::~NoteStore_updateSharedNotebook_args() throw() {
}


uint32_t NoteStore_updateSharedNotebook_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sharedNotebook.read(iprot);
          this->__isset.sharedNotebook = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateSharedNotebook_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateSharedNotebook_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharedNotebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->sharedNotebook.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateSharedNotebook_pargs::~NoteStore_updateSharedNotebook_pargs() throw() {
}


uint32_t NoteStore_updateSharedNotebook_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateSharedNotebook_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharedNotebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->sharedNotebook)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateSharedNotebook_result::~NoteStore_updateSharedNotebook_result() throw() {
}


uint32_t NoteStore_updateSharedNotebook_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateSharedNotebook_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_updateSharedNotebook_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateSharedNotebook_presult::~NoteStore_updateSharedNotebook_presult() throw() {
}


uint32_t NoteStore_updateSharedNotebook_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_setNotebookRecipientSettings_args::~NoteStore_setNotebookRecipientSettings_args() throw() {
}


uint32_t NoteStore_setNotebookRecipientSettings_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->notebookGuid);
          this->__isset.notebookGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->recipientSettings.read(iprot);
          this->__isset.recipientSettings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_setNotebookRecipientSettings_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_setNotebookRecipientSettings_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notebookGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->notebookGuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("recipientSettings", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->recipientSettings.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_setNotebookRecipientSettings_pargs::~NoteStore_setNotebookRecipientSettings_pargs() throw() {
}


uint32_t NoteStore_setNotebookRecipientSettings_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_setNotebookRecipientSettings_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notebookGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->notebookGuid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("recipientSettings", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->recipientSettings)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_setNotebookRecipientSettings_result::~NoteStore_setNotebookRecipientSettings_result() throw() {
}


uint32_t NoteStore_setNotebookRecipientSettings_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_setNotebookRecipientSettings_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_setNotebookRecipientSettings_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_setNotebookRecipientSettings_presult::~NoteStore_setNotebookRecipientSettings_presult() throw() {
}


uint32_t NoteStore_setNotebookRecipientSettings_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_listSharedNotebooks_args::~NoteStore_listSharedNotebooks_args() throw() {
}


uint32_t NoteStore_listSharedNotebooks_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listSharedNotebooks_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listSharedNotebooks_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listSharedNotebooks_pargs::~NoteStore_listSharedNotebooks_pargs() throw() {
}


uint32_t NoteStore_listSharedNotebooks_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listSharedNotebooks_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listSharedNotebooks_result::~NoteStore_listSharedNotebooks_result() throw() {
}


uint32_t NoteStore_listSharedNotebooks_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size439;
            ::apache::thrift::protocol::TType _etype442;
            xfer += iprot->readListBegin(_etype442, _size439);
            this->success.resize(_size439);
            uint32_t _i443;
            for (_i443 = 0; _i443 < _size439; ++_i443)
            {
              xfer += this->success[_i443].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listSharedNotebooks_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_listSharedNotebooks_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::evernote::edam::SharedNotebook> ::const_iterator _iter444;
      for (_iter444 = this->success.begin(); _iter444 != this->success.end(); ++_iter444)
      {
        xfer += (*_iter444).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listSharedNotebooks_presult::~NoteStore_listSharedNotebooks_presult() throw() {
}


uint32_t NoteStore_listSharedNotebooks_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size445;
            ::apache::thrift::protocol::TType _etype448;
            xfer += iprot->readListBegin(_etype448, _size445);
            (*(this->success)).resize(_size445);
            uint32_t _i449;
            for (_i449 = 0; _i449 < _size445; ++_i449)
            {
              xfer += (*(this->success))[_i449].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_createLinkedNotebook_args::~NoteStore_createLinkedNotebook_args() throw() {
}


uint32_t NoteStore_createLinkedNotebook_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->linkedNotebook.read(iprot);
          this->__isset.linkedNotebook = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_createLinkedNotebook_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_createLinkedNotebook_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("linkedNotebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->linkedNotebook.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createLinkedNotebook_pargs::~NoteStore_createLinkedNotebook_pargs() throw() {
}


uint32_t NoteStore_createLinkedNotebook_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_createLinkedNotebook_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("linkedNotebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->linkedNotebook)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createLinkedNotebook_result::~NoteStore_createLinkedNotebook_result() throw() {
}


uint32_t NoteStore_createLinkedNotebook_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_createLinkedNotebook_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_createLinkedNotebook_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_createLinkedNotebook_presult::~NoteStore_createLinkedNotebook_presult() throw() {
}


uint32_t NoteStore_createLinkedNotebook_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_updateLinkedNotebook_args::~NoteStore_updateLinkedNotebook_args() throw() {
}


uint32_t NoteStore_updateLinkedNotebook_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->linkedNotebook.read(iprot);
          this->__isset.linkedNotebook = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateLinkedNotebook_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateLinkedNotebook_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("linkedNotebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->linkedNotebook.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateLinkedNotebook_pargs::~NoteStore_updateLinkedNotebook_pargs() throw() {
}


uint32_t NoteStore_updateLinkedNotebook_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateLinkedNotebook_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("linkedNotebook", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->linkedNotebook)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateLinkedNotebook_result::~NoteStore_updateLinkedNotebook_result() throw() {
}


uint32_t NoteStore_updateLinkedNotebook_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateLinkedNotebook_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_updateLinkedNotebook_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateLinkedNotebook_presult::~NoteStore_updateLinkedNotebook_presult() throw() {
}


uint32_t NoteStore_updateLinkedNotebook_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_listLinkedNotebooks_args::~NoteStore_listLinkedNotebooks_args() throw() {
}


uint32_t NoteStore_listLinkedNotebooks_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listLinkedNotebooks_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listLinkedNotebooks_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listLinkedNotebooks_pargs::~NoteStore_listLinkedNotebooks_pargs() throw() {
}


uint32_t NoteStore_listLinkedNotebooks_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_listLinkedNotebooks_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listLinkedNotebooks_result::~NoteStore_listLinkedNotebooks_result() throw() {
}


uint32_t NoteStore_listLinkedNotebooks_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size450;
            ::apache::thrift::protocol::TType _etype453;
            xfer += iprot->readListBegin(_etype453, _size450);
            this->success.resize(_size450);
            uint32_t _i454;
            for (_i454 = 0; _i454 < _size450; ++_i454)
            {
              xfer += this->success[_i454].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_listLinkedNotebooks_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_listLinkedNotebooks_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::evernote::edam::LinkedNotebook> ::const_iterator _iter455;
      for (_iter455 = this->success.begin(); _iter455 != this->success.end(); ++_iter455)
      {
        xfer += (*_iter455).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_listLinkedNotebooks_presult::~NoteStore_listLinkedNotebooks_presult() throw() {
}


uint32_t NoteStore_listLinkedNotebooks_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size456;
            ::apache::thrift::protocol::TType _etype459;
            xfer += iprot->readListBegin(_etype459, _size456);
            (*(this->success)).resize(_size456);
            uint32_t _i460;
            for (_i460 = 0; _i460 < _size456; ++_i460)
            {
              xfer += (*(this->success))[_i460].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_expungeLinkedNotebook_args::~NoteStore_expungeLinkedNotebook_args() throw() {
}


uint32_t NoteStore_expungeLinkedNotebook_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_expungeLinkedNotebook_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_expungeLinkedNotebook_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeLinkedNotebook_pargs::~NoteStore_expungeLinkedNotebook_pargs() throw() {
}


uint32_t NoteStore_expungeLinkedNotebook_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_expungeLinkedNotebook_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeLinkedNotebook_result::~NoteStore_expungeLinkedNotebook_result() throw() {
}


uint32_t NoteStore_expungeLinkedNotebook_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_expungeLinkedNotebook_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_expungeLinkedNotebook_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_expungeLinkedNotebook_presult::~NoteStore_expungeLinkedNotebook_presult() throw() {
}


uint32_t NoteStore_expungeLinkedNotebook_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_authenticateToSharedNotebook_args::~NoteStore_authenticateToSharedNotebook_args() throw() {
}


uint32_t NoteStore_authenticateToSharedNotebook_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->shareKeyOrGlobalId);
          this->__isset.shareKeyOrGlobalId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_authenticateToSharedNotebook_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_authenticateToSharedNotebook_args");

  xfer += oprot->writeFieldBegin("shareKeyOrGlobalId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->shareKeyOrGlobalId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_authenticateToSharedNotebook_pargs::~NoteStore_authenticateToSharedNotebook_pargs() throw() {
}


uint32_t NoteStore_authenticateToSharedNotebook_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_authenticateToSharedNotebook_pargs");

  xfer += oprot->writeFieldBegin("shareKeyOrGlobalId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->shareKeyOrGlobalId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_authenticateToSharedNotebook_result::~NoteStore_authenticateToSharedNotebook_result() throw() {
}


uint32_t NoteStore_authenticateToSharedNotebook_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_authenticateToSharedNotebook_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_authenticateToSharedNotebook_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_authenticateToSharedNotebook_presult::~NoteStore_authenticateToSharedNotebook_presult() throw() {
}


uint32_t NoteStore_authenticateToSharedNotebook_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getSharedNotebookByAuth_args::~NoteStore_getSharedNotebookByAuth_args() throw() {
}


uint32_t NoteStore_getSharedNotebookByAuth_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getSharedNotebookByAuth_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getSharedNotebookByAuth_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getSharedNotebookByAuth_pargs::~NoteStore_getSharedNotebookByAuth_pargs() throw() {
}


uint32_t NoteStore_getSharedNotebookByAuth_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getSharedNotebookByAuth_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getSharedNotebookByAuth_result::~NoteStore_getSharedNotebookByAuth_result() throw() {
}


uint32_t NoteStore_getSharedNotebookByAuth_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getSharedNotebookByAuth_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getSharedNotebookByAuth_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getSharedNotebookByAuth_presult::~NoteStore_getSharedNotebookByAuth_presult() throw() {
}


uint32_t NoteStore_getSharedNotebookByAuth_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_emailNote_args::~NoteStore_emailNote_args() throw() {
}


uint32_t NoteStore_emailNote_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->parameters.read(iprot);
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_emailNote_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_emailNote_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->parameters.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_emailNote_pargs::~NoteStore_emailNote_pargs() throw() {
}


uint32_t NoteStore_emailNote_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_emailNote_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->parameters)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_emailNote_result::~NoteStore_emailNote_result() throw() {
}


uint32_t NoteStore_emailNote_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_emailNote_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_emailNote_result");

  if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_emailNote_presult::~NoteStore_emailNote_presult() throw() {
}


uint32_t NoteStore_emailNote_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_shareNote_args::~NoteStore_shareNote_args() throw() {
}


uint32_t NoteStore_shareNote_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_shareNote_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_shareNote_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_shareNote_pargs::~NoteStore_shareNote_pargs() throw() {
}


uint32_t NoteStore_shareNote_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_shareNote_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_shareNote_result::~NoteStore_shareNote_result() throw() {
}


uint32_t NoteStore_shareNote_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_shareNote_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_shareNote_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_shareNote_presult::~NoteStore_shareNote_presult() throw() {
}


uint32_t NoteStore_shareNote_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_stopSharingNote_args::~NoteStore_stopSharingNote_args() throw() {
}


uint32_t NoteStore_stopSharingNote_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_stopSharingNote_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_stopSharingNote_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_stopSharingNote_pargs::~NoteStore_stopSharingNote_pargs() throw() {
}


uint32_t NoteStore_stopSharingNote_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_stopSharingNote_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_stopSharingNote_result::~NoteStore_stopSharingNote_result() throw() {
}


uint32_t NoteStore_stopSharingNote_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_stopSharingNote_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_stopSharingNote_result");

  if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_stopSharingNote_presult::~NoteStore_stopSharingNote_presult() throw() {
}


uint32_t NoteStore_stopSharingNote_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_authenticateToSharedNote_args::~NoteStore_authenticateToSharedNote_args() throw() {
}


uint32_t NoteStore_authenticateToSharedNote_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->noteKey);
          this->__isset.noteKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_authenticateToSharedNote_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_authenticateToSharedNote_args");

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noteKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->noteKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_authenticateToSharedNote_pargs::~NoteStore_authenticateToSharedNote_pargs() throw() {
}


uint32_t NoteStore_authenticateToSharedNote_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_authenticateToSharedNote_pargs");

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->guid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noteKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->noteKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_authenticateToSharedNote_result::~NoteStore_authenticateToSharedNote_result() throw() {
}


uint32_t NoteStore_authenticateToSharedNote_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_authenticateToSharedNote_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_authenticateToSharedNote_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_authenticateToSharedNote_presult::~NoteStore_authenticateToSharedNote_presult() throw() {
}


uint32_t NoteStore_authenticateToSharedNote_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_findRelated_args::~NoteStore_findRelated_args() throw() {
}


uint32_t NoteStore_findRelated_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query.read(iprot);
          this->__isset.query = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resultSpec.read(iprot);
          this->__isset.resultSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_findRelated_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_findRelated_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("query", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->query.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultSpec", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->resultSpec.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_findRelated_pargs::~NoteStore_findRelated_pargs() throw() {
}


uint32_t NoteStore_findRelated_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_findRelated_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("query", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->query)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultSpec", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->resultSpec)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_findRelated_result::~NoteStore_findRelated_result() throw() {
}


uint32_t NoteStore_findRelated_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_findRelated_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_findRelated_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_findRelated_presult::~NoteStore_findRelated_presult() throw() {
}


uint32_t NoteStore_findRelated_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_updateNoteIfUsnMatches_args::~NoteStore_updateNoteIfUsnMatches_args() throw() {
}


uint32_t NoteStore_updateNoteIfUsnMatches_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->note.read(iprot);
          this->__isset.note = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateNoteIfUsnMatches_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateNoteIfUsnMatches_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("note", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->note.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateNoteIfUsnMatches_pargs::~NoteStore_updateNoteIfUsnMatches_pargs() throw() {
}


uint32_t NoteStore_updateNoteIfUsnMatches_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_updateNoteIfUsnMatches_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("note", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->note)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateNoteIfUsnMatches_result::~NoteStore_updateNoteIfUsnMatches_result() throw() {
}


uint32_t NoteStore_updateNoteIfUsnMatches_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_updateNoteIfUsnMatches_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_updateNoteIfUsnMatches_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_updateNoteIfUsnMatches_presult::~NoteStore_updateNoteIfUsnMatches_presult() throw() {
}


uint32_t NoteStore_updateNoteIfUsnMatches_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_manageNotebookShares_args::~NoteStore_manageNotebookShares_args() throw() {
}


uint32_t NoteStore_manageNotebookShares_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->parameters.read(iprot);
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_manageNotebookShares_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_manageNotebookShares_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->parameters.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_manageNotebookShares_pargs::~NoteStore_manageNotebookShares_pargs() throw() {
}


uint32_t NoteStore_manageNotebookShares_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_manageNotebookShares_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->parameters)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_manageNotebookShares_result::~NoteStore_manageNotebookShares_result() throw() {
}


uint32_t NoteStore_manageNotebookShares_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_manageNotebookShares_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_manageNotebookShares_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_manageNotebookShares_presult::~NoteStore_manageNotebookShares_presult() throw() {
}


uint32_t NoteStore_manageNotebookShares_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


NoteStore_getNotebookShares_args::~NoteStore_getNotebookShares_args() throw() {
}


uint32_t NoteStore_getNotebookShares_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          this->__isset.authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->notebookGuid);
          this->__isset.notebookGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNotebookShares_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNotebookShares_args");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notebookGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->notebookGuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNotebookShares_pargs::~NoteStore_getNotebookShares_pargs() throw() {
}


uint32_t NoteStore_getNotebookShares_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoteStore_getNotebookShares_pargs");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->authenticationToken)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notebookGuid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->notebookGuid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNotebookShares_result::~NoteStore_getNotebookShares_result() throw() {
}


uint32_t NoteStore_getNotebookShares_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoteStore_getNotebookShares_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("NoteStore_getNotebookShares_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.userException) {
    xfer += oprot->writeFieldBegin("userException", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->userException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.notFoundException) {
    xfer += oprot->writeFieldBegin("notFoundException", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->notFoundException.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.systemException) {
    xfer += oprot->writeFieldBegin("systemException", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->systemException.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


NoteStore_getNotebookShares_presult::~NoteStore_getNotebookShares_presult() throw() {
}


uint32_t NoteStore_getNotebookShares_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userException.read(iprot);
          this->__isset.userException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->notFoundException.read(iprot);
          this->__isset.notFoundException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->systemException.read(iprot);
          this->__isset.systemException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void NoteStoreClient::getSyncState(SyncState& _return, const std::string& authenticationToken)
{
  send_getSyncState(authenticationToken);
  recv_getSyncState(_return);
}

void NoteStoreClient::send_getSyncState(const std::string& authenticationToken)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getSyncState", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getSyncState_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getSyncState(SyncState& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getSyncState") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getSyncState_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSyncState failed: unknown result");
}

void NoteStoreClient::getFilteredSyncChunk(SyncChunk& _return, const std::string& authenticationToken, const int32_t afterUSN, const int32_t maxEntries, const SyncChunkFilter& filter)
{
  send_getFilteredSyncChunk(authenticationToken, afterUSN, maxEntries, filter);
  recv_getFilteredSyncChunk(_return);
}

void NoteStoreClient::send_getFilteredSyncChunk(const std::string& authenticationToken, const int32_t afterUSN, const int32_t maxEntries, const SyncChunkFilter& filter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getFilteredSyncChunk", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getFilteredSyncChunk_pargs args;
  args.authenticationToken = &authenticationToken;
  args.afterUSN = &afterUSN;
  args.maxEntries = &maxEntries;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getFilteredSyncChunk(SyncChunk& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getFilteredSyncChunk") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getFilteredSyncChunk_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getFilteredSyncChunk failed: unknown result");
}

void NoteStoreClient::getLinkedNotebookSyncState(SyncState& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook)
{
  send_getLinkedNotebookSyncState(authenticationToken, linkedNotebook);
  recv_getLinkedNotebookSyncState(_return);
}

void NoteStoreClient::send_getLinkedNotebookSyncState(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getLinkedNotebookSyncState", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getLinkedNotebookSyncState_pargs args;
  args.authenticationToken = &authenticationToken;
  args.linkedNotebook = &linkedNotebook;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getLinkedNotebookSyncState(SyncState& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getLinkedNotebookSyncState") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getLinkedNotebookSyncState_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getLinkedNotebookSyncState failed: unknown result");
}

void NoteStoreClient::getLinkedNotebookSyncChunk(SyncChunk& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook, const int32_t afterUSN, const int32_t maxEntries, const bool fullSyncOnly)
{
  send_getLinkedNotebookSyncChunk(authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly);
  recv_getLinkedNotebookSyncChunk(_return);
}

void NoteStoreClient::send_getLinkedNotebookSyncChunk(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook, const int32_t afterUSN, const int32_t maxEntries, const bool fullSyncOnly)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getLinkedNotebookSyncChunk", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getLinkedNotebookSyncChunk_pargs args;
  args.authenticationToken = &authenticationToken;
  args.linkedNotebook = &linkedNotebook;
  args.afterUSN = &afterUSN;
  args.maxEntries = &maxEntries;
  args.fullSyncOnly = &fullSyncOnly;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getLinkedNotebookSyncChunk(SyncChunk& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getLinkedNotebookSyncChunk") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getLinkedNotebookSyncChunk_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getLinkedNotebookSyncChunk failed: unknown result");
}

void NoteStoreClient::listNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const std::string& authenticationToken)
{
  send_listNotebooks(authenticationToken);
  recv_listNotebooks(_return);
}

void NoteStoreClient::send_listNotebooks(const std::string& authenticationToken)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("listNotebooks", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listNotebooks_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_listNotebooks(std::vector< ::evernote::edam::Notebook> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("listNotebooks") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_listNotebooks_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listNotebooks failed: unknown result");
}

void NoteStoreClient::listAccessibleBusinessNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const std::string& authenticationToken)
{
  send_listAccessibleBusinessNotebooks(authenticationToken);
  recv_listAccessibleBusinessNotebooks(_return);
}

void NoteStoreClient::send_listAccessibleBusinessNotebooks(const std::string& authenticationToken)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("listAccessibleBusinessNotebooks", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listAccessibleBusinessNotebooks_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_listAccessibleBusinessNotebooks(std::vector< ::evernote::edam::Notebook> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("listAccessibleBusinessNotebooks") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_listAccessibleBusinessNotebooks_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listAccessibleBusinessNotebooks failed: unknown result");
}

void NoteStoreClient::getNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_getNotebook(authenticationToken, guid);
  recv_getNotebook(_return);
}

void NoteStoreClient::send_getNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getNotebook( ::evernote::edam::Notebook& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getNotebook") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getNotebook_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNotebook failed: unknown result");
}

void NoteStoreClient::getDefaultNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken)
{
  send_getDefaultNotebook(authenticationToken);
  recv_getDefaultNotebook(_return);
}

void NoteStoreClient::send_getDefaultNotebook(const std::string& authenticationToken)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getDefaultNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getDefaultNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getDefaultNotebook( ::evernote::edam::Notebook& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getDefaultNotebook") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getDefaultNotebook_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getDefaultNotebook failed: unknown result");
}

void NoteStoreClient::createNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook)
{
  send_createNotebook(authenticationToken, notebook);
  recv_createNotebook(_return);
}

void NoteStoreClient::send_createNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("createNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_createNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.notebook = &notebook;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_createNotebook( ::evernote::edam::Notebook& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("createNotebook") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_createNotebook_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createNotebook failed: unknown result");
}

int32_t NoteStoreClient::updateNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook)
{
  send_updateNotebook(authenticationToken, notebook);
  return recv_updateNotebook();
}

void NoteStoreClient::send_updateNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.notebook = &notebook;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_updateNotebook()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateNotebook") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_updateNotebook_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateNotebook failed: unknown result");
}

int32_t NoteStoreClient::expungeNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_expungeNotebook(authenticationToken, guid);
  return recv_expungeNotebook();
}

void NoteStoreClient::send_expungeNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("expungeNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_expungeNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_expungeNotebook()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("expungeNotebook") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_expungeNotebook_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "expungeNotebook failed: unknown result");
}

void NoteStoreClient::listTags(std::vector< ::evernote::edam::Tag> & _return, const std::string& authenticationToken)
{
  send_listTags(authenticationToken);
  recv_listTags(_return);
}

void NoteStoreClient::send_listTags(const std::string& authenticationToken)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("listTags", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listTags_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_listTags(std::vector< ::evernote::edam::Tag> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("listTags") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_listTags_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listTags failed: unknown result");
}

void NoteStoreClient::listTagsByNotebook(std::vector< ::evernote::edam::Tag> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& notebookGuid)
{
  send_listTagsByNotebook(authenticationToken, notebookGuid);
  recv_listTagsByNotebook(_return);
}

void NoteStoreClient::send_listTagsByNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& notebookGuid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("listTagsByNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listTagsByNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.notebookGuid = &notebookGuid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_listTagsByNotebook(std::vector< ::evernote::edam::Tag> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("listTagsByNotebook") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_listTagsByNotebook_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listTagsByNotebook failed: unknown result");
}

void NoteStoreClient::getTag( ::evernote::edam::Tag& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_getTag(authenticationToken, guid);
  recv_getTag(_return);
}

void NoteStoreClient::send_getTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getTag", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getTag_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getTag( ::evernote::edam::Tag& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getTag") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getTag_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getTag failed: unknown result");
}

void NoteStoreClient::createTag( ::evernote::edam::Tag& _return, const std::string& authenticationToken, const  ::evernote::edam::Tag& tag)
{
  send_createTag(authenticationToken, tag);
  recv_createTag(_return);
}

void NoteStoreClient::send_createTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("createTag", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_createTag_pargs args;
  args.authenticationToken = &authenticationToken;
  args.tag = &tag;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_createTag( ::evernote::edam::Tag& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("createTag") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_createTag_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createTag failed: unknown result");
}

int32_t NoteStoreClient::updateTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag)
{
  send_updateTag(authenticationToken, tag);
  return recv_updateTag();
}

void NoteStoreClient::send_updateTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateTag", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateTag_pargs args;
  args.authenticationToken = &authenticationToken;
  args.tag = &tag;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_updateTag()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateTag") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_updateTag_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateTag failed: unknown result");
}

void NoteStoreClient::untagAll(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_untagAll(authenticationToken, guid);
  recv_untagAll();
}

void NoteStoreClient::send_untagAll(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("untagAll", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_untagAll_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_untagAll()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("untagAll") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_untagAll_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  return;
}

int32_t NoteStoreClient::expungeTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_expungeTag(authenticationToken, guid);
  return recv_expungeTag();
}

void NoteStoreClient::send_expungeTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("expungeTag", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_expungeTag_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_expungeTag()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("expungeTag") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_expungeTag_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "expungeTag failed: unknown result");
}

void NoteStoreClient::listSearches(std::vector< ::evernote::edam::SavedSearch> & _return, const std::string& authenticationToken)
{
  send_listSearches(authenticationToken);
  recv_listSearches(_return);
}

void NoteStoreClient::send_listSearches(const std::string& authenticationToken)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("listSearches", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listSearches_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_listSearches(std::vector< ::evernote::edam::SavedSearch> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("listSearches") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_listSearches_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listSearches failed: unknown result");
}

void NoteStoreClient::getSearch( ::evernote::edam::SavedSearch& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_getSearch(authenticationToken, guid);
  recv_getSearch(_return);
}

void NoteStoreClient::send_getSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getSearch", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getSearch_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getSearch( ::evernote::edam::SavedSearch& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getSearch") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getSearch_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSearch failed: unknown result");
}

void NoteStoreClient::createSearch( ::evernote::edam::SavedSearch& _return, const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search)
{
  send_createSearch(authenticationToken, search);
  recv_createSearch(_return);
}

void NoteStoreClient::send_createSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("createSearch", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_createSearch_pargs args;
  args.authenticationToken = &authenticationToken;
  args.search = &search;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_createSearch( ::evernote::edam::SavedSearch& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("createSearch") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_createSearch_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createSearch failed: unknown result");
}

int32_t NoteStoreClient::updateSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search)
{
  send_updateSearch(authenticationToken, search);
  return recv_updateSearch();
}

void NoteStoreClient::send_updateSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateSearch", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateSearch_pargs args;
  args.authenticationToken = &authenticationToken;
  args.search = &search;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_updateSearch()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateSearch") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_updateSearch_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateSearch failed: unknown result");
}

int32_t NoteStoreClient::expungeSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_expungeSearch(authenticationToken, guid);
  return recv_expungeSearch();
}

void NoteStoreClient::send_expungeSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("expungeSearch", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_expungeSearch_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_expungeSearch()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("expungeSearch") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_expungeSearch_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "expungeSearch failed: unknown result");
}

int32_t NoteStoreClient::findNoteOffset(const std::string& authenticationToken, const NoteFilter& filter, const  ::evernote::edam::Guid& guid)
{
  send_findNoteOffset(authenticationToken, filter, guid);
  return recv_findNoteOffset();
}

void NoteStoreClient::send_findNoteOffset(const std::string& authenticationToken, const NoteFilter& filter, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("findNoteOffset", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_findNoteOffset_pargs args;
  args.authenticationToken = &authenticationToken;
  args.filter = &filter;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_findNoteOffset()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("findNoteOffset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_findNoteOffset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "findNoteOffset failed: unknown result");
}

void NoteStoreClient::findNotesMetadata(NotesMetadataList& _return, const std::string& authenticationToken, const NoteFilter& filter, const int32_t offset, const int32_t maxNotes, const NotesMetadataResultSpec& resultSpec)
{
  send_findNotesMetadata(authenticationToken, filter, offset, maxNotes, resultSpec);
  recv_findNotesMetadata(_return);
}

void NoteStoreClient::send_findNotesMetadata(const std::string& authenticationToken, const NoteFilter& filter, const int32_t offset, const int32_t maxNotes, const NotesMetadataResultSpec& resultSpec)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("findNotesMetadata", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_findNotesMetadata_pargs args;
  args.authenticationToken = &authenticationToken;
  args.filter = &filter;
  args.offset = &offset;
  args.maxNotes = &maxNotes;
  args.resultSpec = &resultSpec;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_findNotesMetadata(NotesMetadataList& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("findNotesMetadata") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_findNotesMetadata_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "findNotesMetadata failed: unknown result");
}

void NoteStoreClient::findNoteCounts(NoteCollectionCounts& _return, const std::string& authenticationToken, const NoteFilter& filter, const bool withTrash)
{
  send_findNoteCounts(authenticationToken, filter, withTrash);
  recv_findNoteCounts(_return);
}

void NoteStoreClient::send_findNoteCounts(const std::string& authenticationToken, const NoteFilter& filter, const bool withTrash)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("findNoteCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_findNoteCounts_pargs args;
  args.authenticationToken = &authenticationToken;
  args.filter = &filter;
  args.withTrash = &withTrash;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_findNoteCounts(NoteCollectionCounts& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("findNoteCounts") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_findNoteCounts_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "findNoteCounts failed: unknown result");
}

void NoteStoreClient::getNoteWithResultSpec( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const NoteResultSpec& resultSpec)
{
  send_getNoteWithResultSpec(authenticationToken, guid, resultSpec);
  recv_getNoteWithResultSpec(_return);
}

void NoteStoreClient::send_getNoteWithResultSpec(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const NoteResultSpec& resultSpec)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getNoteWithResultSpec", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteWithResultSpec_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.resultSpec = &resultSpec;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getNoteWithResultSpec( ::evernote::edam::Note& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getNoteWithResultSpec") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getNoteWithResultSpec_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteWithResultSpec failed: unknown result");
}

void NoteStoreClient::getNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withContent, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData)
{
  send_getNote(authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
  recv_getNote(_return);
}

void NoteStoreClient::send_getNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withContent, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.withContent = &withContent;
  args.withResourcesData = &withResourcesData;
  args.withResourcesRecognition = &withResourcesRecognition;
  args.withResourcesAlternateData = &withResourcesAlternateData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getNote( ::evernote::edam::Note& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getNote") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getNote_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNote failed: unknown result");
}

void NoteStoreClient::getNoteApplicationData( ::evernote::edam::LazyMap& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_getNoteApplicationData(authenticationToken, guid);
  recv_getNoteApplicationData(_return);
}

void NoteStoreClient::send_getNoteApplicationData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getNoteApplicationData", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteApplicationData_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getNoteApplicationData( ::evernote::edam::LazyMap& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getNoteApplicationData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getNoteApplicationData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteApplicationData failed: unknown result");
}

void NoteStoreClient::getNoteApplicationDataEntry(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  send_getNoteApplicationDataEntry(authenticationToken, guid, key);
  recv_getNoteApplicationDataEntry(_return);
}

void NoteStoreClient::send_getNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getNoteApplicationDataEntry", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteApplicationDataEntry_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getNoteApplicationDataEntry(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getNoteApplicationDataEntry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getNoteApplicationDataEntry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteApplicationDataEntry failed: unknown result");
}

int32_t NoteStoreClient::setNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value)
{
  send_setNoteApplicationDataEntry(authenticationToken, guid, key, value);
  return recv_setNoteApplicationDataEntry();
}

void NoteStoreClient::send_setNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("setNoteApplicationDataEntry", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_setNoteApplicationDataEntry_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.key = &key;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_setNoteApplicationDataEntry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("setNoteApplicationDataEntry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_setNoteApplicationDataEntry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "setNoteApplicationDataEntry failed: unknown result");
}

int32_t NoteStoreClient::unsetNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  send_unsetNoteApplicationDataEntry(authenticationToken, guid, key);
  return recv_unsetNoteApplicationDataEntry();
}

void NoteStoreClient::send_unsetNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("unsetNoteApplicationDataEntry", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_unsetNoteApplicationDataEntry_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_unsetNoteApplicationDataEntry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("unsetNoteApplicationDataEntry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_unsetNoteApplicationDataEntry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "unsetNoteApplicationDataEntry failed: unknown result");
}

void NoteStoreClient::getNoteContent(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_getNoteContent(authenticationToken, guid);
  recv_getNoteContent(_return);
}

void NoteStoreClient::send_getNoteContent(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getNoteContent", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteContent_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getNoteContent(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getNoteContent") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getNoteContent_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteContent failed: unknown result");
}

void NoteStoreClient::getNoteSearchText(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool noteOnly, const bool tokenizeForIndexing)
{
  send_getNoteSearchText(authenticationToken, guid, noteOnly, tokenizeForIndexing);
  recv_getNoteSearchText(_return);
}

void NoteStoreClient::send_getNoteSearchText(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool noteOnly, const bool tokenizeForIndexing)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getNoteSearchText", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteSearchText_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.noteOnly = &noteOnly;
  args.tokenizeForIndexing = &tokenizeForIndexing;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getNoteSearchText(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getNoteSearchText") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getNoteSearchText_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteSearchText failed: unknown result");
}

void NoteStoreClient::getResourceSearchText(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_getResourceSearchText(authenticationToken, guid);
  recv_getResourceSearchText(_return);
}

void NoteStoreClient::send_getResourceSearchText(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getResourceSearchText", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceSearchText_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getResourceSearchText(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getResourceSearchText") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getResourceSearchText_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceSearchText failed: unknown result");
}

void NoteStoreClient::getNoteTagNames(std::vector<std::string> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_getNoteTagNames(authenticationToken, guid);
  recv_getNoteTagNames(_return);
}

void NoteStoreClient::send_getNoteTagNames(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getNoteTagNames", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteTagNames_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getNoteTagNames(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getNoteTagNames") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getNoteTagNames_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteTagNames failed: unknown result");
}

void NoteStoreClient::createNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note)
{
  send_createNote(authenticationToken, note);
  recv_createNote(_return);
}

void NoteStoreClient::send_createNote(const std::string& authenticationToken, const  ::evernote::edam::Note& note)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("createNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_createNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.note = &note;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_createNote( ::evernote::edam::Note& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("createNote") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_createNote_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createNote failed: unknown result");
}

void NoteStoreClient::updateNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note)
{
  send_updateNote(authenticationToken, note);
  recv_updateNote(_return);
}

void NoteStoreClient::send_updateNote(const std::string& authenticationToken, const  ::evernote::edam::Note& note)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.note = &note;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_updateNote( ::evernote::edam::Note& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateNote") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_updateNote_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateNote failed: unknown result");
}

int32_t NoteStoreClient::deleteNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_deleteNote(authenticationToken, guid);
  return recv_deleteNote();
}

void NoteStoreClient::send_deleteNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_deleteNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_deleteNote()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteNote") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_deleteNote_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteNote failed: unknown result");
}

int32_t NoteStoreClient::expungeNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_expungeNote(authenticationToken, guid);
  return recv_expungeNote();
}

void NoteStoreClient::send_expungeNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("expungeNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_expungeNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_expungeNote()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("expungeNote") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_expungeNote_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "expungeNote failed: unknown result");
}

void NoteStoreClient::copyNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const  ::evernote::edam::Guid& toNotebookGuid)
{
  send_copyNote(authenticationToken, noteGuid, toNotebookGuid);
  recv_copyNote(_return);
}

void NoteStoreClient::send_copyNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const  ::evernote::edam::Guid& toNotebookGuid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("copyNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_copyNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.noteGuid = &noteGuid;
  args.toNotebookGuid = &toNotebookGuid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_copyNote( ::evernote::edam::Note& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("copyNote") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_copyNote_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "copyNote failed: unknown result");
}

void NoteStoreClient::listNoteVersions(std::vector<NoteVersionId> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid)
{
  send_listNoteVersions(authenticationToken, noteGuid);
  recv_listNoteVersions(_return);
}

void NoteStoreClient::send_listNoteVersions(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("listNoteVersions", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listNoteVersions_pargs args;
  args.authenticationToken = &authenticationToken;
  args.noteGuid = &noteGuid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_listNoteVersions(std::vector<NoteVersionId> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("listNoteVersions") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_listNoteVersions_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listNoteVersions failed: unknown result");
}

void NoteStoreClient::getNoteVersion( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const int32_t updateSequenceNum, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData)
{
  send_getNoteVersion(authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
  recv_getNoteVersion(_return);
}

void NoteStoreClient::send_getNoteVersion(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const int32_t updateSequenceNum, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getNoteVersion", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteVersion_pargs args;
  args.authenticationToken = &authenticationToken;
  args.noteGuid = &noteGuid;
  args.updateSequenceNum = &updateSequenceNum;
  args.withResourcesData = &withResourcesData;
  args.withResourcesRecognition = &withResourcesRecognition;
  args.withResourcesAlternateData = &withResourcesAlternateData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getNoteVersion( ::evernote::edam::Note& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getNoteVersion") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getNoteVersion_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteVersion failed: unknown result");
}

void NoteStoreClient::getResource( ::evernote::edam::Resource& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withData, const bool withRecognition, const bool withAttributes, const bool withAlternateData)
{
  send_getResource(authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData);
  recv_getResource(_return);
}

void NoteStoreClient::send_getResource(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withData, const bool withRecognition, const bool withAttributes, const bool withAlternateData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getResource", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResource_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.withData = &withData;
  args.withRecognition = &withRecognition;
  args.withAttributes = &withAttributes;
  args.withAlternateData = &withAlternateData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getResource( ::evernote::edam::Resource& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getResource") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getResource_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResource failed: unknown result");
}

void NoteStoreClient::getResourceApplicationData( ::evernote::edam::LazyMap& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_getResourceApplicationData(authenticationToken, guid);
  recv_getResourceApplicationData(_return);
}

void NoteStoreClient::send_getResourceApplicationData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getResourceApplicationData", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceApplicationData_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getResourceApplicationData( ::evernote::edam::LazyMap& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getResourceApplicationData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getResourceApplicationData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceApplicationData failed: unknown result");
}

void NoteStoreClient::getResourceApplicationDataEntry(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  send_getResourceApplicationDataEntry(authenticationToken, guid, key);
  recv_getResourceApplicationDataEntry(_return);
}

void NoteStoreClient::send_getResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getResourceApplicationDataEntry", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceApplicationDataEntry_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getResourceApplicationDataEntry(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getResourceApplicationDataEntry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getResourceApplicationDataEntry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceApplicationDataEntry failed: unknown result");
}

int32_t NoteStoreClient::setResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value)
{
  send_setResourceApplicationDataEntry(authenticationToken, guid, key, value);
  return recv_setResourceApplicationDataEntry();
}

void NoteStoreClient::send_setResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("setResourceApplicationDataEntry", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_setResourceApplicationDataEntry_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.key = &key;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_setResourceApplicationDataEntry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("setResourceApplicationDataEntry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_setResourceApplicationDataEntry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "setResourceApplicationDataEntry failed: unknown result");
}

int32_t NoteStoreClient::unsetResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  send_unsetResourceApplicationDataEntry(authenticationToken, guid, key);
  return recv_unsetResourceApplicationDataEntry();
}

void NoteStoreClient::send_unsetResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("unsetResourceApplicationDataEntry", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_unsetResourceApplicationDataEntry_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_unsetResourceApplicationDataEntry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("unsetResourceApplicationDataEntry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_unsetResourceApplicationDataEntry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "unsetResourceApplicationDataEntry failed: unknown result");
}

int32_t NoteStoreClient::updateResource(const std::string& authenticationToken, const  ::evernote::edam::Resource& resource)
{
  send_updateResource(authenticationToken, resource);
  return recv_updateResource();
}

void NoteStoreClient::send_updateResource(const std::string& authenticationToken, const  ::evernote::edam::Resource& resource)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateResource", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateResource_pargs args;
  args.authenticationToken = &authenticationToken;
  args.resource = &resource;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_updateResource()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateResource") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_updateResource_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateResource failed: unknown result");
}

void NoteStoreClient::getResourceData(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_getResourceData(authenticationToken, guid);
  recv_getResourceData(_return);
}

void NoteStoreClient::send_getResourceData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getResourceData", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceData_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getResourceData(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getResourceData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getResourceData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceData failed: unknown result");
}

void NoteStoreClient::getResourceByHash( ::evernote::edam::Resource& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const std::string& contentHash, const bool withData, const bool withRecognition, const bool withAlternateData)
{
  send_getResourceByHash(authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData);
  recv_getResourceByHash(_return);
}

void NoteStoreClient::send_getResourceByHash(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const std::string& contentHash, const bool withData, const bool withRecognition, const bool withAlternateData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getResourceByHash", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceByHash_pargs args;
  args.authenticationToken = &authenticationToken;
  args.noteGuid = &noteGuid;
  args.contentHash = &contentHash;
  args.withData = &withData;
  args.withRecognition = &withRecognition;
  args.withAlternateData = &withAlternateData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getResourceByHash( ::evernote::edam::Resource& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getResourceByHash") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getResourceByHash_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceByHash failed: unknown result");
}

void NoteStoreClient::getResourceRecognition(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_getResourceRecognition(authenticationToken, guid);
  recv_getResourceRecognition(_return);
}

void NoteStoreClient::send_getResourceRecognition(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getResourceRecognition", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceRecognition_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getResourceRecognition(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getResourceRecognition") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getResourceRecognition_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceRecognition failed: unknown result");
}

void NoteStoreClient::getResourceAlternateData(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_getResourceAlternateData(authenticationToken, guid);
  recv_getResourceAlternateData(_return);
}

void NoteStoreClient::send_getResourceAlternateData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getResourceAlternateData", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceAlternateData_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getResourceAlternateData(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getResourceAlternateData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getResourceAlternateData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceAlternateData failed: unknown result");
}

void NoteStoreClient::getResourceAttributes( ::evernote::edam::ResourceAttributes& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_getResourceAttributes(authenticationToken, guid);
  recv_getResourceAttributes(_return);
}

void NoteStoreClient::send_getResourceAttributes(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getResourceAttributes", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceAttributes_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getResourceAttributes( ::evernote::edam::ResourceAttributes& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getResourceAttributes") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getResourceAttributes_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceAttributes failed: unknown result");
}

void NoteStoreClient::getPublicNotebook( ::evernote::edam::Notebook& _return, const  ::evernote::edam::UserID userId, const std::string& publicUri)
{
  send_getPublicNotebook(userId, publicUri);
  recv_getPublicNotebook(_return);
}

void NoteStoreClient::send_getPublicNotebook(const  ::evernote::edam::UserID userId, const std::string& publicUri)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getPublicNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getPublicNotebook_pargs args;
  args.userId = &userId;
  args.publicUri = &publicUri;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getPublicNotebook( ::evernote::edam::Notebook& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getPublicNotebook") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getPublicNotebook_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getPublicNotebook failed: unknown result");
}

void NoteStoreClient::shareNotebook( ::evernote::edam::SharedNotebook& _return, const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook, const std::string& message)
{
  send_shareNotebook(authenticationToken, sharedNotebook, message);
  recv_shareNotebook(_return);
}

void NoteStoreClient::send_shareNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook, const std::string& message)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("shareNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_shareNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.sharedNotebook = &sharedNotebook;
  args.message = &message;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_shareNotebook( ::evernote::edam::SharedNotebook& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("shareNotebook") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_shareNotebook_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "shareNotebook failed: unknown result");
}

void NoteStoreClient::createOrUpdateNotebookShares(CreateOrUpdateNotebookSharesResult& _return, const std::string& authenticationToken, const NotebookShareTemplate& shareTemplate)
{
  send_createOrUpdateNotebookShares(authenticationToken, shareTemplate);
  recv_createOrUpdateNotebookShares(_return);
}

void NoteStoreClient::send_createOrUpdateNotebookShares(const std::string& authenticationToken, const NotebookShareTemplate& shareTemplate)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("createOrUpdateNotebookShares", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_createOrUpdateNotebookShares_pargs args;
  args.authenticationToken = &authenticationToken;
  args.shareTemplate = &shareTemplate;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_createOrUpdateNotebookShares(CreateOrUpdateNotebookSharesResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("createOrUpdateNotebookShares") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_createOrUpdateNotebookShares_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.invalidContactsException) {
    throw result.invalidContactsException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createOrUpdateNotebookShares failed: unknown result");
}

int32_t NoteStoreClient::updateSharedNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook)
{
  send_updateSharedNotebook(authenticationToken, sharedNotebook);
  return recv_updateSharedNotebook();
}

void NoteStoreClient::send_updateSharedNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateSharedNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateSharedNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.sharedNotebook = &sharedNotebook;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_updateSharedNotebook()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateSharedNotebook") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_updateSharedNotebook_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateSharedNotebook failed: unknown result");
}

void NoteStoreClient::setNotebookRecipientSettings( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const std::string& notebookGuid, const  ::evernote::edam::NotebookRecipientSettings& recipientSettings)
{
  send_setNotebookRecipientSettings(authenticationToken, notebookGuid, recipientSettings);
  recv_setNotebookRecipientSettings(_return);
}

void NoteStoreClient::send_setNotebookRecipientSettings(const std::string& authenticationToken, const std::string& notebookGuid, const  ::evernote::edam::NotebookRecipientSettings& recipientSettings)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("setNotebookRecipientSettings", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_setNotebookRecipientSettings_pargs args;
  args.authenticationToken = &authenticationToken;
  args.notebookGuid = &notebookGuid;
  args.recipientSettings = &recipientSettings;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_setNotebookRecipientSettings( ::evernote::edam::Notebook& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("setNotebookRecipientSettings") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_setNotebookRecipientSettings_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "setNotebookRecipientSettings failed: unknown result");
}

void NoteStoreClient::listSharedNotebooks(std::vector< ::evernote::edam::SharedNotebook> & _return, const std::string& authenticationToken)
{
  send_listSharedNotebooks(authenticationToken);
  recv_listSharedNotebooks(_return);
}

void NoteStoreClient::send_listSharedNotebooks(const std::string& authenticationToken)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("listSharedNotebooks", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listSharedNotebooks_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_listSharedNotebooks(std::vector< ::evernote::edam::SharedNotebook> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("listSharedNotebooks") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_listSharedNotebooks_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listSharedNotebooks failed: unknown result");
}

void NoteStoreClient::createLinkedNotebook( ::evernote::edam::LinkedNotebook& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook)
{
  send_createLinkedNotebook(authenticationToken, linkedNotebook);
  recv_createLinkedNotebook(_return);
}

void NoteStoreClient::send_createLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("createLinkedNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_createLinkedNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.linkedNotebook = &linkedNotebook;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_createLinkedNotebook( ::evernote::edam::LinkedNotebook& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("createLinkedNotebook") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_createLinkedNotebook_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createLinkedNotebook failed: unknown result");
}

int32_t NoteStoreClient::updateLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook)
{
  send_updateLinkedNotebook(authenticationToken, linkedNotebook);
  return recv_updateLinkedNotebook();
}

void NoteStoreClient::send_updateLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateLinkedNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateLinkedNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.linkedNotebook = &linkedNotebook;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_updateLinkedNotebook()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateLinkedNotebook") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_updateLinkedNotebook_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateLinkedNotebook failed: unknown result");
}

void NoteStoreClient::listLinkedNotebooks(std::vector< ::evernote::edam::LinkedNotebook> & _return, const std::string& authenticationToken)
{
  send_listLinkedNotebooks(authenticationToken);
  recv_listLinkedNotebooks(_return);
}

void NoteStoreClient::send_listLinkedNotebooks(const std::string& authenticationToken)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("listLinkedNotebooks", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listLinkedNotebooks_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_listLinkedNotebooks(std::vector< ::evernote::edam::LinkedNotebook> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("listLinkedNotebooks") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_listLinkedNotebooks_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listLinkedNotebooks failed: unknown result");
}

int32_t NoteStoreClient::expungeLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_expungeLinkedNotebook(authenticationToken, guid);
  return recv_expungeLinkedNotebook();
}

void NoteStoreClient::send_expungeLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("expungeLinkedNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_expungeLinkedNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t NoteStoreClient::recv_expungeLinkedNotebook()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("expungeLinkedNotebook") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  NoteStore_expungeLinkedNotebook_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "expungeLinkedNotebook failed: unknown result");
}

void NoteStoreClient::authenticateToSharedNotebook( ::evernote::edam::AuthenticationResult& _return, const std::string& shareKeyOrGlobalId, const std::string& authenticationToken)
{
  send_authenticateToSharedNotebook(shareKeyOrGlobalId, authenticationToken);
  recv_authenticateToSharedNotebook(_return);
}

void NoteStoreClient::send_authenticateToSharedNotebook(const std::string& shareKeyOrGlobalId, const std::string& authenticationToken)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("authenticateToSharedNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_authenticateToSharedNotebook_pargs args;
  args.shareKeyOrGlobalId = &shareKeyOrGlobalId;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_authenticateToSharedNotebook( ::evernote::edam::AuthenticationResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("authenticateToSharedNotebook") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_authenticateToSharedNotebook_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "authenticateToSharedNotebook failed: unknown result");
}

void NoteStoreClient::getSharedNotebookByAuth( ::evernote::edam::SharedNotebook& _return, const std::string& authenticationToken)
{
  send_getSharedNotebookByAuth(authenticationToken);
  recv_getSharedNotebookByAuth(_return);
}

void NoteStoreClient::send_getSharedNotebookByAuth(const std::string& authenticationToken)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getSharedNotebookByAuth", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getSharedNotebookByAuth_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getSharedNotebookByAuth( ::evernote::edam::SharedNotebook& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getSharedNotebookByAuth") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getSharedNotebookByAuth_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSharedNotebookByAuth failed: unknown result");
}

void NoteStoreClient::emailNote(const std::string& authenticationToken, const NoteEmailParameters& parameters)
{
  send_emailNote(authenticationToken, parameters);
  recv_emailNote();
}

void NoteStoreClient::send_emailNote(const std::string& authenticationToken, const NoteEmailParameters& parameters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("emailNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_emailNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.parameters = &parameters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_emailNote()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("emailNote") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_emailNote_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  return;
}

void NoteStoreClient::shareNote(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_shareNote(authenticationToken, guid);
  recv_shareNote(_return);
}

void NoteStoreClient::send_shareNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("shareNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_shareNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_shareNote(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("shareNote") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_shareNote_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "shareNote failed: unknown result");
}

void NoteStoreClient::stopSharingNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  send_stopSharingNote(authenticationToken, guid);
  recv_stopSharingNote();
}

void NoteStoreClient::send_stopSharingNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("stopSharingNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_stopSharingNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_stopSharingNote()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("stopSharingNote") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_stopSharingNote_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  return;
}

void NoteStoreClient::authenticateToSharedNote( ::evernote::edam::AuthenticationResult& _return, const std::string& guid, const std::string& noteKey, const std::string& authenticationToken)
{
  send_authenticateToSharedNote(guid, noteKey, authenticationToken);
  recv_authenticateToSharedNote(_return);
}

void NoteStoreClient::send_authenticateToSharedNote(const std::string& guid, const std::string& noteKey, const std::string& authenticationToken)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("authenticateToSharedNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_authenticateToSharedNote_pargs args;
  args.guid = &guid;
  args.noteKey = &noteKey;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_authenticateToSharedNote( ::evernote::edam::AuthenticationResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("authenticateToSharedNote") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_authenticateToSharedNote_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "authenticateToSharedNote failed: unknown result");
}

void NoteStoreClient::findRelated(RelatedResult& _return, const std::string& authenticationToken, const RelatedQuery& query, const RelatedResultSpec& resultSpec)
{
  send_findRelated(authenticationToken, query, resultSpec);
  recv_findRelated(_return);
}

void NoteStoreClient::send_findRelated(const std::string& authenticationToken, const RelatedQuery& query, const RelatedResultSpec& resultSpec)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("findRelated", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_findRelated_pargs args;
  args.authenticationToken = &authenticationToken;
  args.query = &query;
  args.resultSpec = &resultSpec;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_findRelated(RelatedResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("findRelated") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_findRelated_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "findRelated failed: unknown result");
}

void NoteStoreClient::updateNoteIfUsnMatches(UpdateNoteIfUsnMatchesResult& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note)
{
  send_updateNoteIfUsnMatches(authenticationToken, note);
  recv_updateNoteIfUsnMatches(_return);
}

void NoteStoreClient::send_updateNoteIfUsnMatches(const std::string& authenticationToken, const  ::evernote::edam::Note& note)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateNoteIfUsnMatches", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateNoteIfUsnMatches_pargs args;
  args.authenticationToken = &authenticationToken;
  args.note = &note;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_updateNoteIfUsnMatches(UpdateNoteIfUsnMatchesResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateNoteIfUsnMatches") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_updateNoteIfUsnMatches_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateNoteIfUsnMatches failed: unknown result");
}

void NoteStoreClient::manageNotebookShares(ManageNotebookSharesResult& _return, const std::string& authenticationToken, const ManageNotebookSharesParameters& parameters)
{
  send_manageNotebookShares(authenticationToken, parameters);
  recv_manageNotebookShares(_return);
}

void NoteStoreClient::send_manageNotebookShares(const std::string& authenticationToken, const ManageNotebookSharesParameters& parameters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("manageNotebookShares", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_manageNotebookShares_pargs args;
  args.authenticationToken = &authenticationToken;
  args.parameters = &parameters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_manageNotebookShares(ManageNotebookSharesResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("manageNotebookShares") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_manageNotebookShares_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "manageNotebookShares failed: unknown result");
}

void NoteStoreClient::getNotebookShares(ShareRelationships& _return, const std::string& authenticationToken, const std::string& notebookGuid)
{
  send_getNotebookShares(authenticationToken, notebookGuid);
  recv_getNotebookShares(_return);
}

void NoteStoreClient::send_getNotebookShares(const std::string& authenticationToken, const std::string& notebookGuid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getNotebookShares", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNotebookShares_pargs args;
  args.authenticationToken = &authenticationToken;
  args.notebookGuid = &notebookGuid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void NoteStoreClient::recv_getNotebookShares(ShareRelationships& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getNotebookShares") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  NoteStore_getNotebookShares_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.userException) {
    throw result.userException;
  }
  if (result.__isset.notFoundException) {
    throw result.notFoundException;
  }
  if (result.__isset.systemException) {
    throw result.systemException;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNotebookShares failed: unknown result");
}

bool NoteStoreProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void NoteStoreProcessor::process_getSyncState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getSyncState", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getSyncState");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getSyncState");
  }

  NoteStore_getSyncState_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getSyncState", bytes);
  }

  NoteStore_getSyncState_result result;
  try {
    iface_->getSyncState(result.success, args.authenticationToken);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getSyncState");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getSyncState", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getSyncState");
  }

  oprot->writeMessageBegin("getSyncState", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getSyncState", bytes);
  }
}

void NoteStoreProcessor::process_getFilteredSyncChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getFilteredSyncChunk", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getFilteredSyncChunk");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getFilteredSyncChunk");
  }

  NoteStore_getFilteredSyncChunk_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getFilteredSyncChunk", bytes);
  }

  NoteStore_getFilteredSyncChunk_result result;
  try {
    iface_->getFilteredSyncChunk(result.success, args.authenticationToken, args.afterUSN, args.maxEntries, args.filter);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getFilteredSyncChunk");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getFilteredSyncChunk", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getFilteredSyncChunk");
  }

  oprot->writeMessageBegin("getFilteredSyncChunk", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getFilteredSyncChunk", bytes);
  }
}

void NoteStoreProcessor::process_getLinkedNotebookSyncState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getLinkedNotebookSyncState", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getLinkedNotebookSyncState");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getLinkedNotebookSyncState");
  }

  NoteStore_getLinkedNotebookSyncState_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getLinkedNotebookSyncState", bytes);
  }

  NoteStore_getLinkedNotebookSyncState_result result;
  try {
    iface_->getLinkedNotebookSyncState(result.success, args.authenticationToken, args.linkedNotebook);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getLinkedNotebookSyncState");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getLinkedNotebookSyncState", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getLinkedNotebookSyncState");
  }

  oprot->writeMessageBegin("getLinkedNotebookSyncState", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getLinkedNotebookSyncState", bytes);
  }
}

void NoteStoreProcessor::process_getLinkedNotebookSyncChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getLinkedNotebookSyncChunk", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getLinkedNotebookSyncChunk");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getLinkedNotebookSyncChunk");
  }

  NoteStore_getLinkedNotebookSyncChunk_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getLinkedNotebookSyncChunk", bytes);
  }

  NoteStore_getLinkedNotebookSyncChunk_result result;
  try {
    iface_->getLinkedNotebookSyncChunk(result.success, args.authenticationToken, args.linkedNotebook, args.afterUSN, args.maxEntries, args.fullSyncOnly);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getLinkedNotebookSyncChunk");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getLinkedNotebookSyncChunk", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getLinkedNotebookSyncChunk");
  }

  oprot->writeMessageBegin("getLinkedNotebookSyncChunk", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getLinkedNotebookSyncChunk", bytes);
  }
}

void NoteStoreProcessor::process_listNotebooks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.listNotebooks", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.listNotebooks");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.listNotebooks");
  }

  NoteStore_listNotebooks_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.listNotebooks", bytes);
  }

  NoteStore_listNotebooks_result result;
  try {
    iface_->listNotebooks(result.success, args.authenticationToken);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.listNotebooks");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("listNotebooks", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.listNotebooks");
  }

  oprot->writeMessageBegin("listNotebooks", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.listNotebooks", bytes);
  }
}

void NoteStoreProcessor::process_listAccessibleBusinessNotebooks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.listAccessibleBusinessNotebooks", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.listAccessibleBusinessNotebooks");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.listAccessibleBusinessNotebooks");
  }

  NoteStore_listAccessibleBusinessNotebooks_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.listAccessibleBusinessNotebooks", bytes);
  }

  NoteStore_listAccessibleBusinessNotebooks_result result;
  try {
    iface_->listAccessibleBusinessNotebooks(result.success, args.authenticationToken);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.listAccessibleBusinessNotebooks");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("listAccessibleBusinessNotebooks", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.listAccessibleBusinessNotebooks");
  }

  oprot->writeMessageBegin("listAccessibleBusinessNotebooks", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.listAccessibleBusinessNotebooks", bytes);
  }
}

void NoteStoreProcessor::process_getNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getNotebook", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getNotebook");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getNotebook");
  }

  NoteStore_getNotebook_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getNotebook", bytes);
  }

  NoteStore_getNotebook_result result;
  try {
    iface_->getNotebook(result.success, args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getNotebook");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getNotebook", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getNotebook");
  }

  oprot->writeMessageBegin("getNotebook", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getNotebook", bytes);
  }
}

void NoteStoreProcessor::process_getDefaultNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getDefaultNotebook", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getDefaultNotebook");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getDefaultNotebook");
  }

  NoteStore_getDefaultNotebook_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getDefaultNotebook", bytes);
  }

  NoteStore_getDefaultNotebook_result result;
  try {
    iface_->getDefaultNotebook(result.success, args.authenticationToken);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getDefaultNotebook");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getDefaultNotebook", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getDefaultNotebook");
  }

  oprot->writeMessageBegin("getDefaultNotebook", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getDefaultNotebook", bytes);
  }
}

void NoteStoreProcessor::process_createNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.createNotebook", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.createNotebook");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.createNotebook");
  }

  NoteStore_createNotebook_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.createNotebook", bytes);
  }

  NoteStore_createNotebook_result result;
  try {
    iface_->createNotebook(result.success, args.authenticationToken, args.notebook);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.createNotebook");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("createNotebook", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.createNotebook");
  }

  oprot->writeMessageBegin("createNotebook", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.createNotebook", bytes);
  }
}

void NoteStoreProcessor::process_updateNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.updateNotebook", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.updateNotebook");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.updateNotebook");
  }

  NoteStore_updateNotebook_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.updateNotebook", bytes);
  }

  NoteStore_updateNotebook_result result;
  try {
    result.success = iface_->updateNotebook(args.authenticationToken, args.notebook);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.updateNotebook");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateNotebook", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.updateNotebook");
  }

  oprot->writeMessageBegin("updateNotebook", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.updateNotebook", bytes);
  }
}

void NoteStoreProcessor::process_expungeNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.expungeNotebook", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.expungeNotebook");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.expungeNotebook");
  }

  NoteStore_expungeNotebook_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.expungeNotebook", bytes);
  }

  NoteStore_expungeNotebook_result result;
  try {
    result.success = iface_->expungeNotebook(args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.expungeNotebook");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("expungeNotebook", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.expungeNotebook");
  }

  oprot->writeMessageBegin("expungeNotebook", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.expungeNotebook", bytes);
  }
}

void NoteStoreProcessor::process_listTags(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.listTags", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.listTags");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.listTags");
  }

  NoteStore_listTags_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.listTags", bytes);
  }

  NoteStore_listTags_result result;
  try {
    iface_->listTags(result.success, args.authenticationToken);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.listTags");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("listTags", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.listTags");
  }

  oprot->writeMessageBegin("listTags", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.listTags", bytes);
  }
}

void NoteStoreProcessor::process_listTagsByNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.listTagsByNotebook", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.listTagsByNotebook");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.listTagsByNotebook");
  }

  NoteStore_listTagsByNotebook_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.listTagsByNotebook", bytes);
  }

  NoteStore_listTagsByNotebook_result result;
  try {
    iface_->listTagsByNotebook(result.success, args.authenticationToken, args.notebookGuid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.listTagsByNotebook");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("listTagsByNotebook", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.listTagsByNotebook");
  }

  oprot->writeMessageBegin("listTagsByNotebook", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.listTagsByNotebook", bytes);
  }
}

void NoteStoreProcessor::process_getTag(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getTag", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getTag");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getTag");
  }

  NoteStore_getTag_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getTag", bytes);
  }

  NoteStore_getTag_result result;
  try {
    iface_->getTag(result.success, args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getTag");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getTag", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getTag");
  }

  oprot->writeMessageBegin("getTag", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getTag", bytes);
  }
}

void NoteStoreProcessor::process_createTag(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.createTag", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.createTag");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.createTag");
  }

  NoteStore_createTag_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.createTag", bytes);
  }

  NoteStore_createTag_result result;
  try {
    iface_->createTag(result.success, args.authenticationToken, args.tag);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.createTag");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("createTag", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.createTag");
  }

  oprot->writeMessageBegin("createTag", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.createTag", bytes);
  }
}

void NoteStoreProcessor::process_updateTag(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.updateTag", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.updateTag");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.updateTag");
  }

  NoteStore_updateTag_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.updateTag", bytes);
  }

  NoteStore_updateTag_result result;
  try {
    result.success = iface_->updateTag(args.authenticationToken, args.tag);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.updateTag");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateTag", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.updateTag");
  }

  oprot->writeMessageBegin("updateTag", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.updateTag", bytes);
  }
}

void NoteStoreProcessor::process_untagAll(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.untagAll", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.untagAll");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.untagAll");
  }

  NoteStore_untagAll_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.untagAll", bytes);
  }

  NoteStore_untagAll_result result;
  try {
    iface_->untagAll(args.authenticationToken, args.guid);
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.untagAll");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("untagAll", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.untagAll");
  }

  oprot->writeMessageBegin("untagAll", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.untagAll", bytes);
  }
}

void NoteStoreProcessor::process_expungeTag(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.expungeTag", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.expungeTag");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.expungeTag");
  }

  NoteStore_expungeTag_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.expungeTag", bytes);
  }

  NoteStore_expungeTag_result result;
  try {
    result.success = iface_->expungeTag(args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.expungeTag");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("expungeTag", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.expungeTag");
  }

  oprot->writeMessageBegin("expungeTag", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.expungeTag", bytes);
  }
}

void NoteStoreProcessor::process_listSearches(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.listSearches", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.listSearches");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.listSearches");
  }

  NoteStore_listSearches_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.listSearches", bytes);
  }

  NoteStore_listSearches_result result;
  try {
    iface_->listSearches(result.success, args.authenticationToken);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.listSearches");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("listSearches", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.listSearches");
  }

  oprot->writeMessageBegin("listSearches", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.listSearches", bytes);
  }
}

void NoteStoreProcessor::process_getSearch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getSearch", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getSearch");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getSearch");
  }

  NoteStore_getSearch_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getSearch", bytes);
  }

  NoteStore_getSearch_result result;
  try {
    iface_->getSearch(result.success, args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getSearch");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getSearch", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getSearch");
  }

  oprot->writeMessageBegin("getSearch", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getSearch", bytes);
  }
}

void NoteStoreProcessor::process_createSearch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.createSearch", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.createSearch");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.createSearch");
  }

  NoteStore_createSearch_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.createSearch", bytes);
  }

  NoteStore_createSearch_result result;
  try {
    iface_->createSearch(result.success, args.authenticationToken, args.search);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.createSearch");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("createSearch", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.createSearch");
  }

  oprot->writeMessageBegin("createSearch", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.createSearch", bytes);
  }
}

void NoteStoreProcessor::process_updateSearch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.updateSearch", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.updateSearch");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.updateSearch");
  }

  NoteStore_updateSearch_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.updateSearch", bytes);
  }

  NoteStore_updateSearch_result result;
  try {
    result.success = iface_->updateSearch(args.authenticationToken, args.search);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.updateSearch");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateSearch", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.updateSearch");
  }

  oprot->writeMessageBegin("updateSearch", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.updateSearch", bytes);
  }
}

void NoteStoreProcessor::process_expungeSearch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.expungeSearch", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.expungeSearch");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.expungeSearch");
  }

  NoteStore_expungeSearch_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.expungeSearch", bytes);
  }

  NoteStore_expungeSearch_result result;
  try {
    result.success = iface_->expungeSearch(args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.expungeSearch");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("expungeSearch", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.expungeSearch");
  }

  oprot->writeMessageBegin("expungeSearch", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.expungeSearch", bytes);
  }
}

void NoteStoreProcessor::process_findNoteOffset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.findNoteOffset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.findNoteOffset");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.findNoteOffset");
  }

  NoteStore_findNoteOffset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.findNoteOffset", bytes);
  }

  NoteStore_findNoteOffset_result result;
  try {
    result.success = iface_->findNoteOffset(args.authenticationToken, args.filter, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.findNoteOffset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("findNoteOffset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.findNoteOffset");
  }

  oprot->writeMessageBegin("findNoteOffset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.findNoteOffset", bytes);
  }
}

void NoteStoreProcessor::process_findNotesMetadata(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.findNotesMetadata", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.findNotesMetadata");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.findNotesMetadata");
  }

  NoteStore_findNotesMetadata_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.findNotesMetadata", bytes);
  }

  NoteStore_findNotesMetadata_result result;
  try {
    iface_->findNotesMetadata(result.success, args.authenticationToken, args.filter, args.offset, args.maxNotes, args.resultSpec);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.findNotesMetadata");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("findNotesMetadata", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.findNotesMetadata");
  }

  oprot->writeMessageBegin("findNotesMetadata", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.findNotesMetadata", bytes);
  }
}

void NoteStoreProcessor::process_findNoteCounts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.findNoteCounts", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.findNoteCounts");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.findNoteCounts");
  }

  NoteStore_findNoteCounts_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.findNoteCounts", bytes);
  }

  NoteStore_findNoteCounts_result result;
  try {
    iface_->findNoteCounts(result.success, args.authenticationToken, args.filter, args.withTrash);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.findNoteCounts");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("findNoteCounts", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.findNoteCounts");
  }

  oprot->writeMessageBegin("findNoteCounts", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.findNoteCounts", bytes);
  }
}

void NoteStoreProcessor::process_getNoteWithResultSpec(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getNoteWithResultSpec", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getNoteWithResultSpec");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getNoteWithResultSpec");
  }

  NoteStore_getNoteWithResultSpec_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getNoteWithResultSpec", bytes);
  }

  NoteStore_getNoteWithResultSpec_result result;
  try {
    iface_->getNoteWithResultSpec(result.success, args.authenticationToken, args.guid, args.resultSpec);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getNoteWithResultSpec");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getNoteWithResultSpec", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getNoteWithResultSpec");
  }

  oprot->writeMessageBegin("getNoteWithResultSpec", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getNoteWithResultSpec", bytes);
  }
}

void NoteStoreProcessor::process_getNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getNote", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getNote");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getNote");
  }

  NoteStore_getNote_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getNote", bytes);
  }

  NoteStore_getNote_result result;
  try {
    iface_->getNote(result.success, args.authenticationToken, args.guid, args.withContent, args.withResourcesData, args.withResourcesRecognition, args.withResourcesAlternateData);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getNote");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getNote", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getNote");
  }

  oprot->writeMessageBegin("getNote", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getNote", bytes);
  }
}

void NoteStoreProcessor::process_getNoteApplicationData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getNoteApplicationData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getNoteApplicationData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getNoteApplicationData");
  }

  NoteStore_getNoteApplicationData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getNoteApplicationData", bytes);
  }

  NoteStore_getNoteApplicationData_result result;
  try {
    iface_->getNoteApplicationData(result.success, args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getNoteApplicationData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getNoteApplicationData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getNoteApplicationData");
  }

  oprot->writeMessageBegin("getNoteApplicationData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getNoteApplicationData", bytes);
  }
}

void NoteStoreProcessor::process_getNoteApplicationDataEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getNoteApplicationDataEntry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getNoteApplicationDataEntry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getNoteApplicationDataEntry");
  }

  NoteStore_getNoteApplicationDataEntry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getNoteApplicationDataEntry", bytes);
  }

  NoteStore_getNoteApplicationDataEntry_result result;
  try {
    iface_->getNoteApplicationDataEntry(result.success, args.authenticationToken, args.guid, args.key);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getNoteApplicationDataEntry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getNoteApplicationDataEntry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getNoteApplicationDataEntry");
  }

  oprot->writeMessageBegin("getNoteApplicationDataEntry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getNoteApplicationDataEntry", bytes);
  }
}

void NoteStoreProcessor::process_setNoteApplicationDataEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.setNoteApplicationDataEntry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.setNoteApplicationDataEntry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.setNoteApplicationDataEntry");
  }

  NoteStore_setNoteApplicationDataEntry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.setNoteApplicationDataEntry", bytes);
  }

  NoteStore_setNoteApplicationDataEntry_result result;
  try {
    result.success = iface_->setNoteApplicationDataEntry(args.authenticationToken, args.guid, args.key, args.value);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.setNoteApplicationDataEntry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("setNoteApplicationDataEntry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.setNoteApplicationDataEntry");
  }

  oprot->writeMessageBegin("setNoteApplicationDataEntry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.setNoteApplicationDataEntry", bytes);
  }
}

void NoteStoreProcessor::process_unsetNoteApplicationDataEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.unsetNoteApplicationDataEntry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.unsetNoteApplicationDataEntry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.unsetNoteApplicationDataEntry");
  }

  NoteStore_unsetNoteApplicationDataEntry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.unsetNoteApplicationDataEntry", bytes);
  }

  NoteStore_unsetNoteApplicationDataEntry_result result;
  try {
    result.success = iface_->unsetNoteApplicationDataEntry(args.authenticationToken, args.guid, args.key);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.unsetNoteApplicationDataEntry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("unsetNoteApplicationDataEntry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.unsetNoteApplicationDataEntry");
  }

  oprot->writeMessageBegin("unsetNoteApplicationDataEntry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.unsetNoteApplicationDataEntry", bytes);
  }
}

void NoteStoreProcessor::process_getNoteContent(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getNoteContent", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getNoteContent");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getNoteContent");
  }

  NoteStore_getNoteContent_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getNoteContent", bytes);
  }

  NoteStore_getNoteContent_result result;
  try {
    iface_->getNoteContent(result.success, args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getNoteContent");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getNoteContent", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getNoteContent");
  }

  oprot->writeMessageBegin("getNoteContent", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getNoteContent", bytes);
  }
}

void NoteStoreProcessor::process_getNoteSearchText(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getNoteSearchText", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getNoteSearchText");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getNoteSearchText");
  }

  NoteStore_getNoteSearchText_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getNoteSearchText", bytes);
  }

  NoteStore_getNoteSearchText_result result;
  try {
    iface_->getNoteSearchText(result.success, args.authenticationToken, args.guid, args.noteOnly, args.tokenizeForIndexing);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getNoteSearchText");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getNoteSearchText", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getNoteSearchText");
  }

  oprot->writeMessageBegin("getNoteSearchText", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getNoteSearchText", bytes);
  }
}

void NoteStoreProcessor::process_getResourceSearchText(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getResourceSearchText", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getResourceSearchText");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getResourceSearchText");
  }

  NoteStore_getResourceSearchText_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getResourceSearchText", bytes);
  }

  NoteStore_getResourceSearchText_result result;
  try {
    iface_->getResourceSearchText(result.success, args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getResourceSearchText");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getResourceSearchText", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getResourceSearchText");
  }

  oprot->writeMessageBegin("getResourceSearchText", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getResourceSearchText", bytes);
  }
}

void NoteStoreProcessor::process_getNoteTagNames(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getNoteTagNames", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getNoteTagNames");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getNoteTagNames");
  }

  NoteStore_getNoteTagNames_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getNoteTagNames", bytes);
  }

  NoteStore_getNoteTagNames_result result;
  try {
    iface_->getNoteTagNames(result.success, args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getNoteTagNames");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getNoteTagNames", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getNoteTagNames");
  }

  oprot->writeMessageBegin("getNoteTagNames", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getNoteTagNames", bytes);
  }
}

void NoteStoreProcessor::process_createNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.createNote", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.createNote");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.createNote");
  }

  NoteStore_createNote_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.createNote", bytes);
  }

  NoteStore_createNote_result result;
  try {
    iface_->createNote(result.success, args.authenticationToken, args.note);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.createNote");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("createNote", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.createNote");
  }

  oprot->writeMessageBegin("createNote", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.createNote", bytes);
  }
}

void NoteStoreProcessor::process_updateNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.updateNote", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.updateNote");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.updateNote");
  }

  NoteStore_updateNote_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.updateNote", bytes);
  }

  NoteStore_updateNote_result result;
  try {
    iface_->updateNote(result.success, args.authenticationToken, args.note);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.updateNote");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateNote", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.updateNote");
  }

  oprot->writeMessageBegin("updateNote", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.updateNote", bytes);
  }
}

void NoteStoreProcessor::process_deleteNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.deleteNote", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.deleteNote");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.deleteNote");
  }

  NoteStore_deleteNote_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.deleteNote", bytes);
  }

  NoteStore_deleteNote_result result;
  try {
    result.success = iface_->deleteNote(args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.deleteNote");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteNote", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.deleteNote");
  }

  oprot->writeMessageBegin("deleteNote", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.deleteNote", bytes);
  }
}

void NoteStoreProcessor::process_expungeNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.expungeNote", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.expungeNote");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.expungeNote");
  }

  NoteStore_expungeNote_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.expungeNote", bytes);
  }

  NoteStore_expungeNote_result result;
  try {
    result.success = iface_->expungeNote(args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.expungeNote");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("expungeNote", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.expungeNote");
  }

  oprot->writeMessageBegin("expungeNote", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.expungeNote", bytes);
  }
}

void NoteStoreProcessor::process_copyNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.copyNote", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.copyNote");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.copyNote");
  }

  NoteStore_copyNote_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.copyNote", bytes);
  }

  NoteStore_copyNote_result result;
  try {
    iface_->copyNote(result.success, args.authenticationToken, args.noteGuid, args.toNotebookGuid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.copyNote");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("copyNote", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.copyNote");
  }

  oprot->writeMessageBegin("copyNote", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.copyNote", bytes);
  }
}

void NoteStoreProcessor::process_listNoteVersions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.listNoteVersions", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.listNoteVersions");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.listNoteVersions");
  }

  NoteStore_listNoteVersions_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.listNoteVersions", bytes);
  }

  NoteStore_listNoteVersions_result result;
  try {
    iface_->listNoteVersions(result.success, args.authenticationToken, args.noteGuid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.listNoteVersions");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("listNoteVersions", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.listNoteVersions");
  }

  oprot->writeMessageBegin("listNoteVersions", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.listNoteVersions", bytes);
  }
}

void NoteStoreProcessor::process_getNoteVersion(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getNoteVersion", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getNoteVersion");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getNoteVersion");
  }

  NoteStore_getNoteVersion_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getNoteVersion", bytes);
  }

  NoteStore_getNoteVersion_result result;
  try {
    iface_->getNoteVersion(result.success, args.authenticationToken, args.noteGuid, args.updateSequenceNum, args.withResourcesData, args.withResourcesRecognition, args.withResourcesAlternateData);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getNoteVersion");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getNoteVersion", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getNoteVersion");
  }

  oprot->writeMessageBegin("getNoteVersion", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getNoteVersion", bytes);
  }
}

void NoteStoreProcessor::process_getResource(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getResource", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getResource");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getResource");
  }

  NoteStore_getResource_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getResource", bytes);
  }

  NoteStore_getResource_result result;
  try {
    iface_->getResource(result.success, args.authenticationToken, args.guid, args.withData, args.withRecognition, args.withAttributes, args.withAlternateData);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getResource");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getResource", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getResource");
  }

  oprot->writeMessageBegin("getResource", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getResource", bytes);
  }
}

void NoteStoreProcessor::process_getResourceApplicationData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getResourceApplicationData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getResourceApplicationData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getResourceApplicationData");
  }

  NoteStore_getResourceApplicationData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getResourceApplicationData", bytes);
  }

  NoteStore_getResourceApplicationData_result result;
  try {
    iface_->getResourceApplicationData(result.success, args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getResourceApplicationData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getResourceApplicationData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getResourceApplicationData");
  }

  oprot->writeMessageBegin("getResourceApplicationData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getResourceApplicationData", bytes);
  }
}

void NoteStoreProcessor::process_getResourceApplicationDataEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getResourceApplicationDataEntry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getResourceApplicationDataEntry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getResourceApplicationDataEntry");
  }

  NoteStore_getResourceApplicationDataEntry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getResourceApplicationDataEntry", bytes);
  }

  NoteStore_getResourceApplicationDataEntry_result result;
  try {
    iface_->getResourceApplicationDataEntry(result.success, args.authenticationToken, args.guid, args.key);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getResourceApplicationDataEntry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getResourceApplicationDataEntry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getResourceApplicationDataEntry");
  }

  oprot->writeMessageBegin("getResourceApplicationDataEntry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getResourceApplicationDataEntry", bytes);
  }
}

void NoteStoreProcessor::process_setResourceApplicationDataEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.setResourceApplicationDataEntry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.setResourceApplicationDataEntry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.setResourceApplicationDataEntry");
  }

  NoteStore_setResourceApplicationDataEntry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.setResourceApplicationDataEntry", bytes);
  }

  NoteStore_setResourceApplicationDataEntry_result result;
  try {
    result.success = iface_->setResourceApplicationDataEntry(args.authenticationToken, args.guid, args.key, args.value);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.setResourceApplicationDataEntry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("setResourceApplicationDataEntry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.setResourceApplicationDataEntry");
  }

  oprot->writeMessageBegin("setResourceApplicationDataEntry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.setResourceApplicationDataEntry", bytes);
  }
}

void NoteStoreProcessor::process_unsetResourceApplicationDataEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.unsetResourceApplicationDataEntry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.unsetResourceApplicationDataEntry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.unsetResourceApplicationDataEntry");
  }

  NoteStore_unsetResourceApplicationDataEntry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.unsetResourceApplicationDataEntry", bytes);
  }

  NoteStore_unsetResourceApplicationDataEntry_result result;
  try {
    result.success = iface_->unsetResourceApplicationDataEntry(args.authenticationToken, args.guid, args.key);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.unsetResourceApplicationDataEntry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("unsetResourceApplicationDataEntry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.unsetResourceApplicationDataEntry");
  }

  oprot->writeMessageBegin("unsetResourceApplicationDataEntry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.unsetResourceApplicationDataEntry", bytes);
  }
}

void NoteStoreProcessor::process_updateResource(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.updateResource", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.updateResource");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.updateResource");
  }

  NoteStore_updateResource_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.updateResource", bytes);
  }

  NoteStore_updateResource_result result;
  try {
    result.success = iface_->updateResource(args.authenticationToken, args.resource);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.updateResource");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateResource", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.updateResource");
  }

  oprot->writeMessageBegin("updateResource", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.updateResource", bytes);
  }
}

void NoteStoreProcessor::process_getResourceData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getResourceData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getResourceData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getResourceData");
  }

  NoteStore_getResourceData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getResourceData", bytes);
  }

  NoteStore_getResourceData_result result;
  try {
    iface_->getResourceData(result.success, args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getResourceData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getResourceData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getResourceData");
  }

  oprot->writeMessageBegin("getResourceData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getResourceData", bytes);
  }
}

void NoteStoreProcessor::process_getResourceByHash(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getResourceByHash", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getResourceByHash");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getResourceByHash");
  }

  NoteStore_getResourceByHash_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getResourceByHash", bytes);
  }

  NoteStore_getResourceByHash_result result;
  try {
    iface_->getResourceByHash(result.success, args.authenticationToken, args.noteGuid, args.contentHash, args.withData, args.withRecognition, args.withAlternateData);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getResourceByHash");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getResourceByHash", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getResourceByHash");
  }

  oprot->writeMessageBegin("getResourceByHash", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getResourceByHash", bytes);
  }
}

void NoteStoreProcessor::process_getResourceRecognition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getResourceRecognition", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getResourceRecognition");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getResourceRecognition");
  }

  NoteStore_getResourceRecognition_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getResourceRecognition", bytes);
  }

  NoteStore_getResourceRecognition_result result;
  try {
    iface_->getResourceRecognition(result.success, args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getResourceRecognition");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getResourceRecognition", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getResourceRecognition");
  }

  oprot->writeMessageBegin("getResourceRecognition", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getResourceRecognition", bytes);
  }
}

void NoteStoreProcessor::process_getResourceAlternateData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getResourceAlternateData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getResourceAlternateData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getResourceAlternateData");
  }

  NoteStore_getResourceAlternateData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getResourceAlternateData", bytes);
  }

  NoteStore_getResourceAlternateData_result result;
  try {
    iface_->getResourceAlternateData(result.success, args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getResourceAlternateData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getResourceAlternateData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getResourceAlternateData");
  }

  oprot->writeMessageBegin("getResourceAlternateData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getResourceAlternateData", bytes);
  }
}

void NoteStoreProcessor::process_getResourceAttributes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getResourceAttributes", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getResourceAttributes");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getResourceAttributes");
  }

  NoteStore_getResourceAttributes_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getResourceAttributes", bytes);
  }

  NoteStore_getResourceAttributes_result result;
  try {
    iface_->getResourceAttributes(result.success, args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getResourceAttributes");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getResourceAttributes", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getResourceAttributes");
  }

  oprot->writeMessageBegin("getResourceAttributes", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getResourceAttributes", bytes);
  }
}

void NoteStoreProcessor::process_getPublicNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getPublicNotebook", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getPublicNotebook");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getPublicNotebook");
  }

  NoteStore_getPublicNotebook_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getPublicNotebook", bytes);
  }

  NoteStore_getPublicNotebook_result result;
  try {
    iface_->getPublicNotebook(result.success, args.userId, args.publicUri);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getPublicNotebook");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getPublicNotebook", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getPublicNotebook");
  }

  oprot->writeMessageBegin("getPublicNotebook", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getPublicNotebook", bytes);
  }
}

void NoteStoreProcessor::process_shareNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.shareNotebook", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.shareNotebook");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.shareNotebook");
  }

  NoteStore_shareNotebook_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.shareNotebook", bytes);
  }

  NoteStore_shareNotebook_result result;
  try {
    iface_->shareNotebook(result.success, args.authenticationToken, args.sharedNotebook, args.message);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.shareNotebook");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("shareNotebook", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.shareNotebook");
  }

  oprot->writeMessageBegin("shareNotebook", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.shareNotebook", bytes);
  }
}

void NoteStoreProcessor::process_createOrUpdateNotebookShares(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.createOrUpdateNotebookShares", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.createOrUpdateNotebookShares");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.createOrUpdateNotebookShares");
  }

  NoteStore_createOrUpdateNotebookShares_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.createOrUpdateNotebookShares", bytes);
  }

  NoteStore_createOrUpdateNotebookShares_result result;
  try {
    iface_->createOrUpdateNotebookShares(result.success, args.authenticationToken, args.shareTemplate);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMInvalidContactsException &invalidContactsException) {
    result.invalidContactsException = invalidContactsException;
    result.__isset.invalidContactsException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.createOrUpdateNotebookShares");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("createOrUpdateNotebookShares", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.createOrUpdateNotebookShares");
  }

  oprot->writeMessageBegin("createOrUpdateNotebookShares", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.createOrUpdateNotebookShares", bytes);
  }
}

void NoteStoreProcessor::process_updateSharedNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.updateSharedNotebook", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.updateSharedNotebook");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.updateSharedNotebook");
  }

  NoteStore_updateSharedNotebook_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.updateSharedNotebook", bytes);
  }

  NoteStore_updateSharedNotebook_result result;
  try {
    result.success = iface_->updateSharedNotebook(args.authenticationToken, args.sharedNotebook);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.updateSharedNotebook");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateSharedNotebook", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.updateSharedNotebook");
  }

  oprot->writeMessageBegin("updateSharedNotebook", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.updateSharedNotebook", bytes);
  }
}

void NoteStoreProcessor::process_setNotebookRecipientSettings(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.setNotebookRecipientSettings", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.setNotebookRecipientSettings");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.setNotebookRecipientSettings");
  }

  NoteStore_setNotebookRecipientSettings_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.setNotebookRecipientSettings", bytes);
  }

  NoteStore_setNotebookRecipientSettings_result result;
  try {
    iface_->setNotebookRecipientSettings(result.success, args.authenticationToken, args.notebookGuid, args.recipientSettings);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.setNotebookRecipientSettings");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("setNotebookRecipientSettings", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.setNotebookRecipientSettings");
  }

  oprot->writeMessageBegin("setNotebookRecipientSettings", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.setNotebookRecipientSettings", bytes);
  }
}

void NoteStoreProcessor::process_listSharedNotebooks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.listSharedNotebooks", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.listSharedNotebooks");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.listSharedNotebooks");
  }

  NoteStore_listSharedNotebooks_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.listSharedNotebooks", bytes);
  }

  NoteStore_listSharedNotebooks_result result;
  try {
    iface_->listSharedNotebooks(result.success, args.authenticationToken);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.listSharedNotebooks");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("listSharedNotebooks", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.listSharedNotebooks");
  }

  oprot->writeMessageBegin("listSharedNotebooks", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.listSharedNotebooks", bytes);
  }
}

void NoteStoreProcessor::process_createLinkedNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.createLinkedNotebook", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.createLinkedNotebook");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.createLinkedNotebook");
  }

  NoteStore_createLinkedNotebook_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.createLinkedNotebook", bytes);
  }

  NoteStore_createLinkedNotebook_result result;
  try {
    iface_->createLinkedNotebook(result.success, args.authenticationToken, args.linkedNotebook);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.createLinkedNotebook");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("createLinkedNotebook", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.createLinkedNotebook");
  }

  oprot->writeMessageBegin("createLinkedNotebook", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.createLinkedNotebook", bytes);
  }
}

void NoteStoreProcessor::process_updateLinkedNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.updateLinkedNotebook", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.updateLinkedNotebook");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.updateLinkedNotebook");
  }

  NoteStore_updateLinkedNotebook_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.updateLinkedNotebook", bytes);
  }

  NoteStore_updateLinkedNotebook_result result;
  try {
    result.success = iface_->updateLinkedNotebook(args.authenticationToken, args.linkedNotebook);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.updateLinkedNotebook");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateLinkedNotebook", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.updateLinkedNotebook");
  }

  oprot->writeMessageBegin("updateLinkedNotebook", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.updateLinkedNotebook", bytes);
  }
}

void NoteStoreProcessor::process_listLinkedNotebooks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.listLinkedNotebooks", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.listLinkedNotebooks");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.listLinkedNotebooks");
  }

  NoteStore_listLinkedNotebooks_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.listLinkedNotebooks", bytes);
  }

  NoteStore_listLinkedNotebooks_result result;
  try {
    iface_->listLinkedNotebooks(result.success, args.authenticationToken);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.listLinkedNotebooks");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("listLinkedNotebooks", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.listLinkedNotebooks");
  }

  oprot->writeMessageBegin("listLinkedNotebooks", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.listLinkedNotebooks", bytes);
  }
}

void NoteStoreProcessor::process_expungeLinkedNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.expungeLinkedNotebook", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.expungeLinkedNotebook");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.expungeLinkedNotebook");
  }

  NoteStore_expungeLinkedNotebook_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.expungeLinkedNotebook", bytes);
  }

  NoteStore_expungeLinkedNotebook_result result;
  try {
    result.success = iface_->expungeLinkedNotebook(args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.expungeLinkedNotebook");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("expungeLinkedNotebook", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.expungeLinkedNotebook");
  }

  oprot->writeMessageBegin("expungeLinkedNotebook", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.expungeLinkedNotebook", bytes);
  }
}

void NoteStoreProcessor::process_authenticateToSharedNotebook(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.authenticateToSharedNotebook", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.authenticateToSharedNotebook");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.authenticateToSharedNotebook");
  }

  NoteStore_authenticateToSharedNotebook_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.authenticateToSharedNotebook", bytes);
  }

  NoteStore_authenticateToSharedNotebook_result result;
  try {
    iface_->authenticateToSharedNotebook(result.success, args.shareKeyOrGlobalId, args.authenticationToken);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.authenticateToSharedNotebook");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("authenticateToSharedNotebook", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.authenticateToSharedNotebook");
  }

  oprot->writeMessageBegin("authenticateToSharedNotebook", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.authenticateToSharedNotebook", bytes);
  }
}

void NoteStoreProcessor::process_getSharedNotebookByAuth(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getSharedNotebookByAuth", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getSharedNotebookByAuth");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getSharedNotebookByAuth");
  }

  NoteStore_getSharedNotebookByAuth_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getSharedNotebookByAuth", bytes);
  }

  NoteStore_getSharedNotebookByAuth_result result;
  try {
    iface_->getSharedNotebookByAuth(result.success, args.authenticationToken);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getSharedNotebookByAuth");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getSharedNotebookByAuth", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getSharedNotebookByAuth");
  }

  oprot->writeMessageBegin("getSharedNotebookByAuth", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getSharedNotebookByAuth", bytes);
  }
}

void NoteStoreProcessor::process_emailNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.emailNote", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.emailNote");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.emailNote");
  }

  NoteStore_emailNote_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.emailNote", bytes);
  }

  NoteStore_emailNote_result result;
  try {
    iface_->emailNote(args.authenticationToken, args.parameters);
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.emailNote");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("emailNote", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.emailNote");
  }

  oprot->writeMessageBegin("emailNote", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.emailNote", bytes);
  }
}

void NoteStoreProcessor::process_shareNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.shareNote", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.shareNote");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.shareNote");
  }

  NoteStore_shareNote_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.shareNote", bytes);
  }

  NoteStore_shareNote_result result;
  try {
    iface_->shareNote(result.success, args.authenticationToken, args.guid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.shareNote");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("shareNote", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.shareNote");
  }

  oprot->writeMessageBegin("shareNote", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.shareNote", bytes);
  }
}

void NoteStoreProcessor::process_stopSharingNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.stopSharingNote", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.stopSharingNote");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.stopSharingNote");
  }

  NoteStore_stopSharingNote_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.stopSharingNote", bytes);
  }

  NoteStore_stopSharingNote_result result;
  try {
    iface_->stopSharingNote(args.authenticationToken, args.guid);
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.stopSharingNote");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("stopSharingNote", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.stopSharingNote");
  }

  oprot->writeMessageBegin("stopSharingNote", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.stopSharingNote", bytes);
  }
}

void NoteStoreProcessor::process_authenticateToSharedNote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.authenticateToSharedNote", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.authenticateToSharedNote");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.authenticateToSharedNote");
  }

  NoteStore_authenticateToSharedNote_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.authenticateToSharedNote", bytes);
  }

  NoteStore_authenticateToSharedNote_result result;
  try {
    iface_->authenticateToSharedNote(result.success, args.guid, args.noteKey, args.authenticationToken);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.authenticateToSharedNote");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("authenticateToSharedNote", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.authenticateToSharedNote");
  }

  oprot->writeMessageBegin("authenticateToSharedNote", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.authenticateToSharedNote", bytes);
  }
}

void NoteStoreProcessor::process_findRelated(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.findRelated", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.findRelated");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.findRelated");
  }

  NoteStore_findRelated_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.findRelated", bytes);
  }

  NoteStore_findRelated_result result;
  try {
    iface_->findRelated(result.success, args.authenticationToken, args.query, args.resultSpec);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.findRelated");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("findRelated", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.findRelated");
  }

  oprot->writeMessageBegin("findRelated", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.findRelated", bytes);
  }
}

void NoteStoreProcessor::process_updateNoteIfUsnMatches(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.updateNoteIfUsnMatches", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.updateNoteIfUsnMatches");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.updateNoteIfUsnMatches");
  }

  NoteStore_updateNoteIfUsnMatches_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.updateNoteIfUsnMatches", bytes);
  }

  NoteStore_updateNoteIfUsnMatches_result result;
  try {
    iface_->updateNoteIfUsnMatches(result.success, args.authenticationToken, args.note);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.updateNoteIfUsnMatches");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateNoteIfUsnMatches", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.updateNoteIfUsnMatches");
  }

  oprot->writeMessageBegin("updateNoteIfUsnMatches", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.updateNoteIfUsnMatches", bytes);
  }
}

void NoteStoreProcessor::process_manageNotebookShares(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.manageNotebookShares", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.manageNotebookShares");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.manageNotebookShares");
  }

  NoteStore_manageNotebookShares_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.manageNotebookShares", bytes);
  }

  NoteStore_manageNotebookShares_result result;
  try {
    iface_->manageNotebookShares(result.success, args.authenticationToken, args.parameters);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.manageNotebookShares");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("manageNotebookShares", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.manageNotebookShares");
  }

  oprot->writeMessageBegin("manageNotebookShares", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.manageNotebookShares", bytes);
  }
}

void NoteStoreProcessor::process_getNotebookShares(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("NoteStore.getNotebookShares", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "NoteStore.getNotebookShares");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "NoteStore.getNotebookShares");
  }

  NoteStore_getNotebookShares_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "NoteStore.getNotebookShares", bytes);
  }

  NoteStore_getNotebookShares_result result;
  try {
    iface_->getNotebookShares(result.success, args.authenticationToken, args.notebookGuid);
    result.__isset.success = true;
  } catch ( ::evernote::edam::EDAMUserException &userException) {
    result.userException = userException;
    result.__isset.userException = true;
  } catch ( ::evernote::edam::EDAMNotFoundException &notFoundException) {
    result.notFoundException = notFoundException;
    result.__isset.notFoundException = true;
  } catch ( ::evernote::edam::EDAMSystemException &systemException) {
    result.systemException = systemException;
    result.__isset.systemException = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "NoteStore.getNotebookShares");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getNotebookShares", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "NoteStore.getNotebookShares");
  }

  oprot->writeMessageBegin("getNotebookShares", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "NoteStore.getNotebookShares", bytes);
  }
}

::boost::shared_ptr< ::apache::thrift::TProcessor > NoteStoreProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< NoteStoreIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< NoteStoreIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new NoteStoreProcessor(handler));
  return processor;
}

void NoteStoreConcurrentClient::getSyncState(SyncState& _return, const std::string& authenticationToken)
{
  int32_t seqid = send_getSyncState(authenticationToken);
  recv_getSyncState(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getSyncState(const std::string& authenticationToken)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getSyncState", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getSyncState_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getSyncState(SyncState& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getSyncState") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getSyncState_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSyncState failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getFilteredSyncChunk(SyncChunk& _return, const std::string& authenticationToken, const int32_t afterUSN, const int32_t maxEntries, const SyncChunkFilter& filter)
{
  int32_t seqid = send_getFilteredSyncChunk(authenticationToken, afterUSN, maxEntries, filter);
  recv_getFilteredSyncChunk(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getFilteredSyncChunk(const std::string& authenticationToken, const int32_t afterUSN, const int32_t maxEntries, const SyncChunkFilter& filter)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getFilteredSyncChunk", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getFilteredSyncChunk_pargs args;
  args.authenticationToken = &authenticationToken;
  args.afterUSN = &afterUSN;
  args.maxEntries = &maxEntries;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getFilteredSyncChunk(SyncChunk& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getFilteredSyncChunk") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getFilteredSyncChunk_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getFilteredSyncChunk failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getLinkedNotebookSyncState(SyncState& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook)
{
  int32_t seqid = send_getLinkedNotebookSyncState(authenticationToken, linkedNotebook);
  recv_getLinkedNotebookSyncState(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getLinkedNotebookSyncState(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getLinkedNotebookSyncState", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getLinkedNotebookSyncState_pargs args;
  args.authenticationToken = &authenticationToken;
  args.linkedNotebook = &linkedNotebook;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getLinkedNotebookSyncState(SyncState& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getLinkedNotebookSyncState") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getLinkedNotebookSyncState_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getLinkedNotebookSyncState failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getLinkedNotebookSyncChunk(SyncChunk& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook, const int32_t afterUSN, const int32_t maxEntries, const bool fullSyncOnly)
{
  int32_t seqid = send_getLinkedNotebookSyncChunk(authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly);
  recv_getLinkedNotebookSyncChunk(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getLinkedNotebookSyncChunk(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook, const int32_t afterUSN, const int32_t maxEntries, const bool fullSyncOnly)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getLinkedNotebookSyncChunk", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getLinkedNotebookSyncChunk_pargs args;
  args.authenticationToken = &authenticationToken;
  args.linkedNotebook = &linkedNotebook;
  args.afterUSN = &afterUSN;
  args.maxEntries = &maxEntries;
  args.fullSyncOnly = &fullSyncOnly;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getLinkedNotebookSyncChunk(SyncChunk& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getLinkedNotebookSyncChunk") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getLinkedNotebookSyncChunk_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getLinkedNotebookSyncChunk failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::listNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const std::string& authenticationToken)
{
  int32_t seqid = send_listNotebooks(authenticationToken);
  recv_listNotebooks(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_listNotebooks(const std::string& authenticationToken)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("listNotebooks", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listNotebooks_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_listNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("listNotebooks") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_listNotebooks_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listNotebooks failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::listAccessibleBusinessNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const std::string& authenticationToken)
{
  int32_t seqid = send_listAccessibleBusinessNotebooks(authenticationToken);
  recv_listAccessibleBusinessNotebooks(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_listAccessibleBusinessNotebooks(const std::string& authenticationToken)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("listAccessibleBusinessNotebooks", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listAccessibleBusinessNotebooks_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_listAccessibleBusinessNotebooks(std::vector< ::evernote::edam::Notebook> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("listAccessibleBusinessNotebooks") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_listAccessibleBusinessNotebooks_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listAccessibleBusinessNotebooks failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_getNotebook(authenticationToken, guid);
  recv_getNotebook(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getNotebook( ::evernote::edam::Notebook& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getNotebook") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getNotebook_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNotebook failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getDefaultNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken)
{
  int32_t seqid = send_getDefaultNotebook(authenticationToken);
  recv_getDefaultNotebook(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getDefaultNotebook(const std::string& authenticationToken)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getDefaultNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getDefaultNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getDefaultNotebook( ::evernote::edam::Notebook& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getDefaultNotebook") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getDefaultNotebook_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getDefaultNotebook failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::createNotebook( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook)
{
  int32_t seqid = send_createNotebook(authenticationToken, notebook);
  recv_createNotebook(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_createNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("createNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_createNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.notebook = &notebook;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_createNotebook( ::evernote::edam::Notebook& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("createNotebook") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_createNotebook_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createNotebook failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::updateNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook)
{
  int32_t seqid = send_updateNotebook(authenticationToken, notebook);
  return recv_updateNotebook(seqid);
}

int32_t NoteStoreConcurrentClient::send_updateNotebook(const std::string& authenticationToken, const  ::evernote::edam::Notebook& notebook)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("updateNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.notebook = &notebook;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_updateNotebook(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("updateNotebook") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_updateNotebook_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateNotebook failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::expungeNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_expungeNotebook(authenticationToken, guid);
  return recv_expungeNotebook(seqid);
}

int32_t NoteStoreConcurrentClient::send_expungeNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("expungeNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_expungeNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_expungeNotebook(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("expungeNotebook") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_expungeNotebook_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "expungeNotebook failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::listTags(std::vector< ::evernote::edam::Tag> & _return, const std::string& authenticationToken)
{
  int32_t seqid = send_listTags(authenticationToken);
  recv_listTags(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_listTags(const std::string& authenticationToken)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("listTags", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listTags_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_listTags(std::vector< ::evernote::edam::Tag> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("listTags") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_listTags_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listTags failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::listTagsByNotebook(std::vector< ::evernote::edam::Tag> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& notebookGuid)
{
  int32_t seqid = send_listTagsByNotebook(authenticationToken, notebookGuid);
  recv_listTagsByNotebook(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_listTagsByNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& notebookGuid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("listTagsByNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listTagsByNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.notebookGuid = &notebookGuid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_listTagsByNotebook(std::vector< ::evernote::edam::Tag> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("listTagsByNotebook") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_listTagsByNotebook_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listTagsByNotebook failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getTag( ::evernote::edam::Tag& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_getTag(authenticationToken, guid);
  recv_getTag(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getTag", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getTag_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getTag( ::evernote::edam::Tag& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getTag") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getTag_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getTag failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::createTag( ::evernote::edam::Tag& _return, const std::string& authenticationToken, const  ::evernote::edam::Tag& tag)
{
  int32_t seqid = send_createTag(authenticationToken, tag);
  recv_createTag(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_createTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("createTag", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_createTag_pargs args;
  args.authenticationToken = &authenticationToken;
  args.tag = &tag;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_createTag( ::evernote::edam::Tag& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("createTag") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_createTag_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createTag failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::updateTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag)
{
  int32_t seqid = send_updateTag(authenticationToken, tag);
  return recv_updateTag(seqid);
}

int32_t NoteStoreConcurrentClient::send_updateTag(const std::string& authenticationToken, const  ::evernote::edam::Tag& tag)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("updateTag", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateTag_pargs args;
  args.authenticationToken = &authenticationToken;
  args.tag = &tag;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_updateTag(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("updateTag") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_updateTag_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateTag failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::untagAll(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_untagAll(authenticationToken, guid);
  recv_untagAll(seqid);
}

int32_t NoteStoreConcurrentClient::send_untagAll(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("untagAll", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_untagAll_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_untagAll(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("untagAll") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_untagAll_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::expungeTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_expungeTag(authenticationToken, guid);
  return recv_expungeTag(seqid);
}

int32_t NoteStoreConcurrentClient::send_expungeTag(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("expungeTag", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_expungeTag_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_expungeTag(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("expungeTag") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_expungeTag_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "expungeTag failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::listSearches(std::vector< ::evernote::edam::SavedSearch> & _return, const std::string& authenticationToken)
{
  int32_t seqid = send_listSearches(authenticationToken);
  recv_listSearches(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_listSearches(const std::string& authenticationToken)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("listSearches", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listSearches_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_listSearches(std::vector< ::evernote::edam::SavedSearch> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("listSearches") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_listSearches_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listSearches failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getSearch( ::evernote::edam::SavedSearch& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_getSearch(authenticationToken, guid);
  recv_getSearch(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getSearch", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getSearch_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getSearch( ::evernote::edam::SavedSearch& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getSearch") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getSearch_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSearch failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::createSearch( ::evernote::edam::SavedSearch& _return, const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search)
{
  int32_t seqid = send_createSearch(authenticationToken, search);
  recv_createSearch(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_createSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("createSearch", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_createSearch_pargs args;
  args.authenticationToken = &authenticationToken;
  args.search = &search;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_createSearch( ::evernote::edam::SavedSearch& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("createSearch") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_createSearch_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createSearch failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::updateSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search)
{
  int32_t seqid = send_updateSearch(authenticationToken, search);
  return recv_updateSearch(seqid);
}

int32_t NoteStoreConcurrentClient::send_updateSearch(const std::string& authenticationToken, const  ::evernote::edam::SavedSearch& search)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("updateSearch", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateSearch_pargs args;
  args.authenticationToken = &authenticationToken;
  args.search = &search;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_updateSearch(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("updateSearch") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_updateSearch_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateSearch failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::expungeSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_expungeSearch(authenticationToken, guid);
  return recv_expungeSearch(seqid);
}

int32_t NoteStoreConcurrentClient::send_expungeSearch(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("expungeSearch", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_expungeSearch_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_expungeSearch(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("expungeSearch") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_expungeSearch_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "expungeSearch failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::findNoteOffset(const std::string& authenticationToken, const NoteFilter& filter, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_findNoteOffset(authenticationToken, filter, guid);
  return recv_findNoteOffset(seqid);
}

int32_t NoteStoreConcurrentClient::send_findNoteOffset(const std::string& authenticationToken, const NoteFilter& filter, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("findNoteOffset", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_findNoteOffset_pargs args;
  args.authenticationToken = &authenticationToken;
  args.filter = &filter;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_findNoteOffset(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("findNoteOffset") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_findNoteOffset_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "findNoteOffset failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::findNotesMetadata(NotesMetadataList& _return, const std::string& authenticationToken, const NoteFilter& filter, const int32_t offset, const int32_t maxNotes, const NotesMetadataResultSpec& resultSpec)
{
  int32_t seqid = send_findNotesMetadata(authenticationToken, filter, offset, maxNotes, resultSpec);
  recv_findNotesMetadata(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_findNotesMetadata(const std::string& authenticationToken, const NoteFilter& filter, const int32_t offset, const int32_t maxNotes, const NotesMetadataResultSpec& resultSpec)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("findNotesMetadata", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_findNotesMetadata_pargs args;
  args.authenticationToken = &authenticationToken;
  args.filter = &filter;
  args.offset = &offset;
  args.maxNotes = &maxNotes;
  args.resultSpec = &resultSpec;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_findNotesMetadata(NotesMetadataList& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("findNotesMetadata") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_findNotesMetadata_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "findNotesMetadata failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::findNoteCounts(NoteCollectionCounts& _return, const std::string& authenticationToken, const NoteFilter& filter, const bool withTrash)
{
  int32_t seqid = send_findNoteCounts(authenticationToken, filter, withTrash);
  recv_findNoteCounts(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_findNoteCounts(const std::string& authenticationToken, const NoteFilter& filter, const bool withTrash)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("findNoteCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_findNoteCounts_pargs args;
  args.authenticationToken = &authenticationToken;
  args.filter = &filter;
  args.withTrash = &withTrash;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_findNoteCounts(NoteCollectionCounts& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("findNoteCounts") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_findNoteCounts_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "findNoteCounts failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getNoteWithResultSpec( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const NoteResultSpec& resultSpec)
{
  int32_t seqid = send_getNoteWithResultSpec(authenticationToken, guid, resultSpec);
  recv_getNoteWithResultSpec(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getNoteWithResultSpec(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const NoteResultSpec& resultSpec)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getNoteWithResultSpec", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteWithResultSpec_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.resultSpec = &resultSpec;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getNoteWithResultSpec( ::evernote::edam::Note& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getNoteWithResultSpec") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getNoteWithResultSpec_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteWithResultSpec failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withContent, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData)
{
  int32_t seqid = send_getNote(authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
  recv_getNote(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withContent, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.withContent = &withContent;
  args.withResourcesData = &withResourcesData;
  args.withResourcesRecognition = &withResourcesRecognition;
  args.withResourcesAlternateData = &withResourcesAlternateData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getNote( ::evernote::edam::Note& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getNote") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getNote_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNote failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getNoteApplicationData( ::evernote::edam::LazyMap& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_getNoteApplicationData(authenticationToken, guid);
  recv_getNoteApplicationData(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getNoteApplicationData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getNoteApplicationData", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteApplicationData_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getNoteApplicationData( ::evernote::edam::LazyMap& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getNoteApplicationData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getNoteApplicationData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteApplicationData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getNoteApplicationDataEntry(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  int32_t seqid = send_getNoteApplicationDataEntry(authenticationToken, guid, key);
  recv_getNoteApplicationDataEntry(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getNoteApplicationDataEntry", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteApplicationDataEntry_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getNoteApplicationDataEntry(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getNoteApplicationDataEntry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getNoteApplicationDataEntry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteApplicationDataEntry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::setNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value)
{
  int32_t seqid = send_setNoteApplicationDataEntry(authenticationToken, guid, key, value);
  return recv_setNoteApplicationDataEntry(seqid);
}

int32_t NoteStoreConcurrentClient::send_setNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("setNoteApplicationDataEntry", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_setNoteApplicationDataEntry_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.key = &key;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_setNoteApplicationDataEntry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("setNoteApplicationDataEntry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_setNoteApplicationDataEntry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "setNoteApplicationDataEntry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::unsetNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  int32_t seqid = send_unsetNoteApplicationDataEntry(authenticationToken, guid, key);
  return recv_unsetNoteApplicationDataEntry(seqid);
}

int32_t NoteStoreConcurrentClient::send_unsetNoteApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("unsetNoteApplicationDataEntry", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_unsetNoteApplicationDataEntry_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_unsetNoteApplicationDataEntry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("unsetNoteApplicationDataEntry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_unsetNoteApplicationDataEntry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "unsetNoteApplicationDataEntry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getNoteContent(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_getNoteContent(authenticationToken, guid);
  recv_getNoteContent(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getNoteContent(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getNoteContent", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteContent_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getNoteContent(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getNoteContent") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getNoteContent_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteContent failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getNoteSearchText(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool noteOnly, const bool tokenizeForIndexing)
{
  int32_t seqid = send_getNoteSearchText(authenticationToken, guid, noteOnly, tokenizeForIndexing);
  recv_getNoteSearchText(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getNoteSearchText(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool noteOnly, const bool tokenizeForIndexing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getNoteSearchText", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteSearchText_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.noteOnly = &noteOnly;
  args.tokenizeForIndexing = &tokenizeForIndexing;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getNoteSearchText(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getNoteSearchText") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getNoteSearchText_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteSearchText failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getResourceSearchText(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_getResourceSearchText(authenticationToken, guid);
  recv_getResourceSearchText(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getResourceSearchText(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getResourceSearchText", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceSearchText_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getResourceSearchText(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getResourceSearchText") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getResourceSearchText_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceSearchText failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getNoteTagNames(std::vector<std::string> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_getNoteTagNames(authenticationToken, guid);
  recv_getNoteTagNames(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getNoteTagNames(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getNoteTagNames", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteTagNames_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getNoteTagNames(std::vector<std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getNoteTagNames") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getNoteTagNames_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteTagNames failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::createNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note)
{
  int32_t seqid = send_createNote(authenticationToken, note);
  recv_createNote(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_createNote(const std::string& authenticationToken, const  ::evernote::edam::Note& note)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("createNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_createNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.note = &note;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_createNote( ::evernote::edam::Note& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("createNote") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_createNote_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createNote failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::updateNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note)
{
  int32_t seqid = send_updateNote(authenticationToken, note);
  recv_updateNote(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_updateNote(const std::string& authenticationToken, const  ::evernote::edam::Note& note)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("updateNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.note = &note;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_updateNote( ::evernote::edam::Note& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("updateNote") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_updateNote_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateNote failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::deleteNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_deleteNote(authenticationToken, guid);
  return recv_deleteNote(seqid);
}

int32_t NoteStoreConcurrentClient::send_deleteNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("deleteNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_deleteNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_deleteNote(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("deleteNote") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_deleteNote_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteNote failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::expungeNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_expungeNote(authenticationToken, guid);
  return recv_expungeNote(seqid);
}

int32_t NoteStoreConcurrentClient::send_expungeNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("expungeNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_expungeNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_expungeNote(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("expungeNote") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_expungeNote_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "expungeNote failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::copyNote( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const  ::evernote::edam::Guid& toNotebookGuid)
{
  int32_t seqid = send_copyNote(authenticationToken, noteGuid, toNotebookGuid);
  recv_copyNote(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_copyNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const  ::evernote::edam::Guid& toNotebookGuid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("copyNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_copyNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.noteGuid = &noteGuid;
  args.toNotebookGuid = &toNotebookGuid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_copyNote( ::evernote::edam::Note& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("copyNote") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_copyNote_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "copyNote failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::listNoteVersions(std::vector<NoteVersionId> & _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid)
{
  int32_t seqid = send_listNoteVersions(authenticationToken, noteGuid);
  recv_listNoteVersions(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_listNoteVersions(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("listNoteVersions", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listNoteVersions_pargs args;
  args.authenticationToken = &authenticationToken;
  args.noteGuid = &noteGuid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_listNoteVersions(std::vector<NoteVersionId> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("listNoteVersions") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_listNoteVersions_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listNoteVersions failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getNoteVersion( ::evernote::edam::Note& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const int32_t updateSequenceNum, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData)
{
  int32_t seqid = send_getNoteVersion(authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
  recv_getNoteVersion(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getNoteVersion(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const int32_t updateSequenceNum, const bool withResourcesData, const bool withResourcesRecognition, const bool withResourcesAlternateData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getNoteVersion", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNoteVersion_pargs args;
  args.authenticationToken = &authenticationToken;
  args.noteGuid = &noteGuid;
  args.updateSequenceNum = &updateSequenceNum;
  args.withResourcesData = &withResourcesData;
  args.withResourcesRecognition = &withResourcesRecognition;
  args.withResourcesAlternateData = &withResourcesAlternateData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getNoteVersion( ::evernote::edam::Note& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getNoteVersion") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getNoteVersion_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNoteVersion failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getResource( ::evernote::edam::Resource& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withData, const bool withRecognition, const bool withAttributes, const bool withAlternateData)
{
  int32_t seqid = send_getResource(authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData);
  recv_getResource(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getResource(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const bool withData, const bool withRecognition, const bool withAttributes, const bool withAlternateData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getResource", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResource_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.withData = &withData;
  args.withRecognition = &withRecognition;
  args.withAttributes = &withAttributes;
  args.withAlternateData = &withAlternateData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getResource( ::evernote::edam::Resource& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getResource") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getResource_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResource failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getResourceApplicationData( ::evernote::edam::LazyMap& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_getResourceApplicationData(authenticationToken, guid);
  recv_getResourceApplicationData(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getResourceApplicationData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getResourceApplicationData", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceApplicationData_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getResourceApplicationData( ::evernote::edam::LazyMap& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getResourceApplicationData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getResourceApplicationData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceApplicationData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getResourceApplicationDataEntry(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  int32_t seqid = send_getResourceApplicationDataEntry(authenticationToken, guid, key);
  recv_getResourceApplicationDataEntry(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getResourceApplicationDataEntry", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceApplicationDataEntry_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getResourceApplicationDataEntry(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getResourceApplicationDataEntry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getResourceApplicationDataEntry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceApplicationDataEntry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::setResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value)
{
  int32_t seqid = send_setResourceApplicationDataEntry(authenticationToken, guid, key, value);
  return recv_setResourceApplicationDataEntry(seqid);
}

int32_t NoteStoreConcurrentClient::send_setResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key, const std::string& value)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("setResourceApplicationDataEntry", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_setResourceApplicationDataEntry_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.key = &key;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_setResourceApplicationDataEntry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("setResourceApplicationDataEntry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_setResourceApplicationDataEntry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "setResourceApplicationDataEntry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::unsetResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  int32_t seqid = send_unsetResourceApplicationDataEntry(authenticationToken, guid, key);
  return recv_unsetResourceApplicationDataEntry(seqid);
}

int32_t NoteStoreConcurrentClient::send_unsetResourceApplicationDataEntry(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid, const std::string& key)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("unsetResourceApplicationDataEntry", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_unsetResourceApplicationDataEntry_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_unsetResourceApplicationDataEntry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("unsetResourceApplicationDataEntry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_unsetResourceApplicationDataEntry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "unsetResourceApplicationDataEntry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::updateResource(const std::string& authenticationToken, const  ::evernote::edam::Resource& resource)
{
  int32_t seqid = send_updateResource(authenticationToken, resource);
  return recv_updateResource(seqid);
}

int32_t NoteStoreConcurrentClient::send_updateResource(const std::string& authenticationToken, const  ::evernote::edam::Resource& resource)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("updateResource", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateResource_pargs args;
  args.authenticationToken = &authenticationToken;
  args.resource = &resource;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_updateResource(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("updateResource") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_updateResource_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateResource failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getResourceData(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_getResourceData(authenticationToken, guid);
  recv_getResourceData(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getResourceData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getResourceData", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceData_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getResourceData(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getResourceData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getResourceData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getResourceByHash( ::evernote::edam::Resource& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const std::string& contentHash, const bool withData, const bool withRecognition, const bool withAlternateData)
{
  int32_t seqid = send_getResourceByHash(authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData);
  recv_getResourceByHash(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getResourceByHash(const std::string& authenticationToken, const  ::evernote::edam::Guid& noteGuid, const std::string& contentHash, const bool withData, const bool withRecognition, const bool withAlternateData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getResourceByHash", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceByHash_pargs args;
  args.authenticationToken = &authenticationToken;
  args.noteGuid = &noteGuid;
  args.contentHash = &contentHash;
  args.withData = &withData;
  args.withRecognition = &withRecognition;
  args.withAlternateData = &withAlternateData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getResourceByHash( ::evernote::edam::Resource& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getResourceByHash") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getResourceByHash_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceByHash failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getResourceRecognition(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_getResourceRecognition(authenticationToken, guid);
  recv_getResourceRecognition(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getResourceRecognition(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getResourceRecognition", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceRecognition_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getResourceRecognition(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getResourceRecognition") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getResourceRecognition_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceRecognition failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getResourceAlternateData(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_getResourceAlternateData(authenticationToken, guid);
  recv_getResourceAlternateData(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getResourceAlternateData(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getResourceAlternateData", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceAlternateData_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getResourceAlternateData(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getResourceAlternateData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getResourceAlternateData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceAlternateData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getResourceAttributes( ::evernote::edam::ResourceAttributes& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_getResourceAttributes(authenticationToken, guid);
  recv_getResourceAttributes(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getResourceAttributes(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getResourceAttributes", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getResourceAttributes_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getResourceAttributes( ::evernote::edam::ResourceAttributes& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getResourceAttributes") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getResourceAttributes_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getResourceAttributes failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getPublicNotebook( ::evernote::edam::Notebook& _return, const  ::evernote::edam::UserID userId, const std::string& publicUri)
{
  int32_t seqid = send_getPublicNotebook(userId, publicUri);
  recv_getPublicNotebook(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getPublicNotebook(const  ::evernote::edam::UserID userId, const std::string& publicUri)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getPublicNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getPublicNotebook_pargs args;
  args.userId = &userId;
  args.publicUri = &publicUri;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getPublicNotebook( ::evernote::edam::Notebook& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getPublicNotebook") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getPublicNotebook_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getPublicNotebook failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::shareNotebook( ::evernote::edam::SharedNotebook& _return, const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook, const std::string& message)
{
  int32_t seqid = send_shareNotebook(authenticationToken, sharedNotebook, message);
  recv_shareNotebook(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_shareNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook, const std::string& message)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("shareNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_shareNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.sharedNotebook = &sharedNotebook;
  args.message = &message;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_shareNotebook( ::evernote::edam::SharedNotebook& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("shareNotebook") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_shareNotebook_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "shareNotebook failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::createOrUpdateNotebookShares(CreateOrUpdateNotebookSharesResult& _return, const std::string& authenticationToken, const NotebookShareTemplate& shareTemplate)
{
  int32_t seqid = send_createOrUpdateNotebookShares(authenticationToken, shareTemplate);
  recv_createOrUpdateNotebookShares(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_createOrUpdateNotebookShares(const std::string& authenticationToken, const NotebookShareTemplate& shareTemplate)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("createOrUpdateNotebookShares", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_createOrUpdateNotebookShares_pargs args;
  args.authenticationToken = &authenticationToken;
  args.shareTemplate = &shareTemplate;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_createOrUpdateNotebookShares(CreateOrUpdateNotebookSharesResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("createOrUpdateNotebookShares") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_createOrUpdateNotebookShares_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.invalidContactsException) {
        sentry.commit();
        throw result.invalidContactsException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createOrUpdateNotebookShares failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::updateSharedNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook)
{
  int32_t seqid = send_updateSharedNotebook(authenticationToken, sharedNotebook);
  return recv_updateSharedNotebook(seqid);
}

int32_t NoteStoreConcurrentClient::send_updateSharedNotebook(const std::string& authenticationToken, const  ::evernote::edam::SharedNotebook& sharedNotebook)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("updateSharedNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateSharedNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.sharedNotebook = &sharedNotebook;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_updateSharedNotebook(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("updateSharedNotebook") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_updateSharedNotebook_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateSharedNotebook failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::setNotebookRecipientSettings( ::evernote::edam::Notebook& _return, const std::string& authenticationToken, const std::string& notebookGuid, const  ::evernote::edam::NotebookRecipientSettings& recipientSettings)
{
  int32_t seqid = send_setNotebookRecipientSettings(authenticationToken, notebookGuid, recipientSettings);
  recv_setNotebookRecipientSettings(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_setNotebookRecipientSettings(const std::string& authenticationToken, const std::string& notebookGuid, const  ::evernote::edam::NotebookRecipientSettings& recipientSettings)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("setNotebookRecipientSettings", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_setNotebookRecipientSettings_pargs args;
  args.authenticationToken = &authenticationToken;
  args.notebookGuid = &notebookGuid;
  args.recipientSettings = &recipientSettings;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_setNotebookRecipientSettings( ::evernote::edam::Notebook& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("setNotebookRecipientSettings") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_setNotebookRecipientSettings_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "setNotebookRecipientSettings failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::listSharedNotebooks(std::vector< ::evernote::edam::SharedNotebook> & _return, const std::string& authenticationToken)
{
  int32_t seqid = send_listSharedNotebooks(authenticationToken);
  recv_listSharedNotebooks(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_listSharedNotebooks(const std::string& authenticationToken)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("listSharedNotebooks", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listSharedNotebooks_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_listSharedNotebooks(std::vector< ::evernote::edam::SharedNotebook> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("listSharedNotebooks") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_listSharedNotebooks_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listSharedNotebooks failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::createLinkedNotebook( ::evernote::edam::LinkedNotebook& _return, const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook)
{
  int32_t seqid = send_createLinkedNotebook(authenticationToken, linkedNotebook);
  recv_createLinkedNotebook(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_createLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("createLinkedNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_createLinkedNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.linkedNotebook = &linkedNotebook;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_createLinkedNotebook( ::evernote::edam::LinkedNotebook& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("createLinkedNotebook") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_createLinkedNotebook_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createLinkedNotebook failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::updateLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook)
{
  int32_t seqid = send_updateLinkedNotebook(authenticationToken, linkedNotebook);
  return recv_updateLinkedNotebook(seqid);
}

int32_t NoteStoreConcurrentClient::send_updateLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::LinkedNotebook& linkedNotebook)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("updateLinkedNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateLinkedNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.linkedNotebook = &linkedNotebook;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_updateLinkedNotebook(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("updateLinkedNotebook") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_updateLinkedNotebook_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateLinkedNotebook failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::listLinkedNotebooks(std::vector< ::evernote::edam::LinkedNotebook> & _return, const std::string& authenticationToken)
{
  int32_t seqid = send_listLinkedNotebooks(authenticationToken);
  recv_listLinkedNotebooks(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_listLinkedNotebooks(const std::string& authenticationToken)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("listLinkedNotebooks", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_listLinkedNotebooks_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_listLinkedNotebooks(std::vector< ::evernote::edam::LinkedNotebook> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("listLinkedNotebooks") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_listLinkedNotebooks_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listLinkedNotebooks failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t NoteStoreConcurrentClient::expungeLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_expungeLinkedNotebook(authenticationToken, guid);
  return recv_expungeLinkedNotebook(seqid);
}

int32_t NoteStoreConcurrentClient::send_expungeLinkedNotebook(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("expungeLinkedNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_expungeLinkedNotebook_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t NoteStoreConcurrentClient::recv_expungeLinkedNotebook(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("expungeLinkedNotebook") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      NoteStore_expungeLinkedNotebook_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "expungeLinkedNotebook failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::authenticateToSharedNotebook( ::evernote::edam::AuthenticationResult& _return, const std::string& shareKeyOrGlobalId, const std::string& authenticationToken)
{
  int32_t seqid = send_authenticateToSharedNotebook(shareKeyOrGlobalId, authenticationToken);
  recv_authenticateToSharedNotebook(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_authenticateToSharedNotebook(const std::string& shareKeyOrGlobalId, const std::string& authenticationToken)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("authenticateToSharedNotebook", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_authenticateToSharedNotebook_pargs args;
  args.shareKeyOrGlobalId = &shareKeyOrGlobalId;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_authenticateToSharedNotebook( ::evernote::edam::AuthenticationResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("authenticateToSharedNotebook") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_authenticateToSharedNotebook_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "authenticateToSharedNotebook failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getSharedNotebookByAuth( ::evernote::edam::SharedNotebook& _return, const std::string& authenticationToken)
{
  int32_t seqid = send_getSharedNotebookByAuth(authenticationToken);
  recv_getSharedNotebookByAuth(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getSharedNotebookByAuth(const std::string& authenticationToken)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getSharedNotebookByAuth", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getSharedNotebookByAuth_pargs args;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getSharedNotebookByAuth( ::evernote::edam::SharedNotebook& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getSharedNotebookByAuth") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getSharedNotebookByAuth_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSharedNotebookByAuth failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::emailNote(const std::string& authenticationToken, const NoteEmailParameters& parameters)
{
  int32_t seqid = send_emailNote(authenticationToken, parameters);
  recv_emailNote(seqid);
}

int32_t NoteStoreConcurrentClient::send_emailNote(const std::string& authenticationToken, const NoteEmailParameters& parameters)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("emailNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_emailNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.parameters = &parameters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_emailNote(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("emailNote") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_emailNote_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::shareNote(std::string& _return, const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_shareNote(authenticationToken, guid);
  recv_shareNote(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_shareNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("shareNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_shareNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_shareNote(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("shareNote") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_shareNote_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "shareNote failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::stopSharingNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t seqid = send_stopSharingNote(authenticationToken, guid);
  recv_stopSharingNote(seqid);
}

int32_t NoteStoreConcurrentClient::send_stopSharingNote(const std::string& authenticationToken, const  ::evernote::edam::Guid& guid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("stopSharingNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_stopSharingNote_pargs args;
  args.authenticationToken = &authenticationToken;
  args.guid = &guid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_stopSharingNote(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("stopSharingNote") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_stopSharingNote_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::authenticateToSharedNote( ::evernote::edam::AuthenticationResult& _return, const std::string& guid, const std::string& noteKey, const std::string& authenticationToken)
{
  int32_t seqid = send_authenticateToSharedNote(guid, noteKey, authenticationToken);
  recv_authenticateToSharedNote(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_authenticateToSharedNote(const std::string& guid, const std::string& noteKey, const std::string& authenticationToken)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("authenticateToSharedNote", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_authenticateToSharedNote_pargs args;
  args.guid = &guid;
  args.noteKey = &noteKey;
  args.authenticationToken = &authenticationToken;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_authenticateToSharedNote( ::evernote::edam::AuthenticationResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("authenticateToSharedNote") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_authenticateToSharedNote_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "authenticateToSharedNote failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::findRelated(RelatedResult& _return, const std::string& authenticationToken, const RelatedQuery& query, const RelatedResultSpec& resultSpec)
{
  int32_t seqid = send_findRelated(authenticationToken, query, resultSpec);
  recv_findRelated(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_findRelated(const std::string& authenticationToken, const RelatedQuery& query, const RelatedResultSpec& resultSpec)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("findRelated", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_findRelated_pargs args;
  args.authenticationToken = &authenticationToken;
  args.query = &query;
  args.resultSpec = &resultSpec;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_findRelated(RelatedResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("findRelated") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_findRelated_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "findRelated failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::updateNoteIfUsnMatches(UpdateNoteIfUsnMatchesResult& _return, const std::string& authenticationToken, const  ::evernote::edam::Note& note)
{
  int32_t seqid = send_updateNoteIfUsnMatches(authenticationToken, note);
  recv_updateNoteIfUsnMatches(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_updateNoteIfUsnMatches(const std::string& authenticationToken, const  ::evernote::edam::Note& note)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("updateNoteIfUsnMatches", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_updateNoteIfUsnMatches_pargs args;
  args.authenticationToken = &authenticationToken;
  args.note = &note;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_updateNoteIfUsnMatches(UpdateNoteIfUsnMatchesResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("updateNoteIfUsnMatches") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_updateNoteIfUsnMatches_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateNoteIfUsnMatches failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::manageNotebookShares(ManageNotebookSharesResult& _return, const std::string& authenticationToken, const ManageNotebookSharesParameters& parameters)
{
  int32_t seqid = send_manageNotebookShares(authenticationToken, parameters);
  recv_manageNotebookShares(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_manageNotebookShares(const std::string& authenticationToken, const ManageNotebookSharesParameters& parameters)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("manageNotebookShares", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_manageNotebookShares_pargs args;
  args.authenticationToken = &authenticationToken;
  args.parameters = &parameters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_manageNotebookShares(ManageNotebookSharesResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("manageNotebookShares") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_manageNotebookShares_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "manageNotebookShares failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void NoteStoreConcurrentClient::getNotebookShares(ShareRelationships& _return, const std::string& authenticationToken, const std::string& notebookGuid)
{
  int32_t seqid = send_getNotebookShares(authenticationToken, notebookGuid);
  recv_getNotebookShares(_return, seqid);
}

int32_t NoteStoreConcurrentClient::send_getNotebookShares(const std::string& authenticationToken, const std::string& notebookGuid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getNotebookShares", ::apache::thrift::protocol::T_CALL, cseqid);

  NoteStore_getNotebookShares_pargs args;
  args.authenticationToken = &authenticationToken;
  args.notebookGuid = &notebookGuid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void NoteStoreConcurrentClient::recv_getNotebookShares(ShareRelationships& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getNotebookShares") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      NoteStore_getNotebookShares_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.userException) {
        sentry.commit();
        throw result.userException;
      }
      if (result.__isset.notFoundException) {
        sentry.commit();
        throw result.notFoundException;
      }
      if (result.__isset.systemException) {
        sentry.commit();
        throw result.systemException;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNotebookShares failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

}} // namespace

