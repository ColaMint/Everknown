/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef UserStore_H
#define UserStore_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "UserStore_types.h"

namespace evernote { namespace edam {

#ifdef _WIN32
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class UserStoreIf {
 public:
  virtual ~UserStoreIf() {}

  /**
   * This should be the first call made by a client to the EDAM service.  It
   * tells the service what protocol version is used by the client.  The
   * service will then return true if the client is capable of talking to
   * the service, and false if the client's protocol version is incompatible
   * with the service, so the client must upgrade.  If a client receives a
   * false value, it should report the incompatibility to the user and not
   * continue with any more EDAM requests (UserStore or NoteStore).
   * 
   * @param clientName
   *   This string provides some information about the client for
   *   tracking/logging on the service.  It should provide information about
   *   the client's software and platform. The structure should be:
   *   application/version; platform/version; [ device/version ]
   *   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
   * 
   * @param edamVersionMajor
   *   This should be the major protocol version that was compiled by the
   *   client.  This should be the current value of the EDAM_VERSION_MAJOR
   *   constant for the client.
   * 
   * @param edamVersionMinor
   *   This should be the major protocol version that was compiled by the
   *   client.  This should be the current value of the EDAM_VERSION_MINOR
   *   constant for the client.
   * 
   * @param clientName
   * @param edamVersionMajor
   * @param edamVersionMinor
   */
  virtual bool checkVersion(const std::string& clientName, const int16_t edamVersionMajor, const int16_t edamVersionMinor) = 0;

  /**
   * This provides bootstrap information to the client. Various bootstrap
   * profiles and settings may be used by the client to configure itself.
   * 
   * @param locale
   *   The client's current locale, expressed in language[_country]
   *   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
   *   language and country codes.
   * 
   * @return
   *   The bootstrap information suitable for this client.
   * 
   * @param locale
   */
  virtual void getBootstrapInfo(BootstrapInfo& _return, const std::string& locale) = 0;

  /**
   * This is used to check a username and password in order to create a
   * long-lived authentication token that can be used for further actions.
   * 
   * This function is not available to most third party applications,
   * which typically authenticate using OAuth as
   * described at
   * <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
   * If you believe that your application requires permission to authenticate
   * using username and password instead of OAuth, please contact Evernote
   * developer support by visiting
   * <a href="http://dev.evernote.com">dev.evernote.com</a>.
   * 
   * @param username
   *   The username or registered email address of the account to
   *   authenticate against.
   * 
   * @param password
   *   The plaintext password to check against the account.  Since
   *   this is not protected by the EDAM protocol, this information must be
   *   provided over a protected transport (i.e. SSL).
   * 
   * @param consumerKey
   *   The "consumer key" portion of the API key issued to the client application
   *   by Evernote.
   * 
   * @param consumerSecret
   *   The "consumer secret" portion of the API key issued to the client application
   *   by Evernote.
   * 
   * @param deviceIdentifier
   *   An optional string that uniquely identifies the device from which the
   *   authentication is being performed. This string allows the service to return the
   *   same authentication token when a given application requests authentication
   *   repeatedly from the same device. This may happen when the user logs out of an
   *   application and then logs back in, or when the application is uninstalled
   *   and later reinstalled. If no reliable device identifier can be created,
   *   this value should be omitted. If set, the device identifier must be between
   *   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
   *   EDAM_DEVICE_ID_REGEX.
   * 
   * @param deviceDescription
   *   A description of the device from which the authentication is being performed.
   *   This field is displayed to the user in a list of authorized applications to
   *   allow them to distinguish between multiple tokens issued to the same client
   *   application on different devices. For example, the Evernote iOS client on
   *   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
   *   "Bob's iPad". The device description must be between 1 and
   *   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
   *   expression EDAM_DEVICE_DESCRIPTION_REGEX.
   * 
   * @param supportsTwoFactor
   *   Whether the calling application supports two-factor authentication. If this
   *   parameter is false, this method will fail with the error code INVALID_AUTH and the
   *   parameter "password" when called for a user who has enabled two-factor
   *   authentication.
   * 
   * @return
   *   <p>The result of the authentication. The level of detail provided in the returned
   *   AuthenticationResult.User structure depends on the access level granted by
   *   calling application's API key.</p>
   *   <p>If the user has two-factor authentication enabled,
   *   AuthenticationResult.secondFactorRequired will be set and
   *   AuthenticationResult.authenticationToken will contain a short-lived token
   *   that may only be used to complete the two-factor authentication process by calling
   *   UserStore.completeTwoFactorAuthentication.</p>
   * 
   * @throws EDAMUserException <ul>
   *   <li> DATA_REQUIRED "username" - username is empty
   *   <li> DATA_REQUIRED "password" - password is empty
   *   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
   *   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
   *   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
   *   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
   *   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
   *   <li> INVALID_AUTH "username" - username not found
   *   <li> INVALID_AUTH "password" - password did not match
   *   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
   *   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
   *   <li> PERMISSION_DENIED "User.active" - user account is closed
   *   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
   *     failed authentication too often
   *   <li> AUTH_EXPIRED "password" - user password is expired
   * </ul>
   * 
   * @param username
   * @param password
   * @param consumerKey
   * @param consumerSecret
   * @param deviceIdentifier
   * @param deviceDescription
   * @param supportsTwoFactor
   */
  virtual void authenticateLongSession(AuthenticationResult& _return, const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const std::string& deviceIdentifier, const std::string& deviceDescription, const bool supportsTwoFactor) = 0;

  /**
   * Complete the authentication process when a second factor is required. This
   * call is made after a successful call to authenticate or authenticateLongSession
   * when the authenticating user has enabled two-factor authentication.
   * 
   * @param authenticationToken An authentication token returned by a previous
   *   call to UserStore.authenticate or UserStore.authenticateLongSession that
   *   could not be completed in a single call because a second factor was required.
   * 
   * @param oneTimeCode The one time code entered by the user. This value is delivered
   *   out-of-band, typically via SMS or an authenticator application.
   * 
   * @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
   * 
   * @param deviceDescription See the corresponding parameter in authenticateLongSession.
   * 
   * @return
   *   The result of the authentication. The level of detail provided in the returned
   *   AuthenticationResult.User structure depends on the access level granted by the
   *   calling application's API key. If the initial authentication call was made to
   *   authenticateLongSession, the AuthenticationResult will contain a long-lived
   *   authentication token.
   * 
   * @throws EDAMUserException <ul>
   *   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
   *   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
   *   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
   *   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
   *   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
   *   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
   *   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
   *   <li> PERMISSION_DENIED "User.active" - user account is closed
   *   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
   *     failed authentication too often
   *   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
   *      two-factor authentication.</li>
   * </ul>
   * 
   * @param authenticationToken
   * @param oneTimeCode
   * @param deviceIdentifier
   * @param deviceDescription
   */
  virtual void completeTwoFactorAuthentication(AuthenticationResult& _return, const std::string& authenticationToken, const std::string& oneTimeCode, const std::string& deviceIdentifier, const std::string& deviceDescription) = 0;

  /**
   * Revoke an existing long lived authentication token. This can be used to
   * revoke OAuth tokens or tokens created by calling authenticateLongSession,
   * and allows a user to effectively log out of Evernote from the perspective
   * of the application that holds the token. The authentication token that is
   * passed is immediately revoked and may not be used to call any authenticated
   * EDAM function.
   * 
   * @param authenticationToken the authentication token to revoke.
   * 
   * @throws EDAMUserException <ul>
   *   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
   *   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
   *   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
   *   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
   *     is already revoked.
   * </ul>
   * 
   * @param authenticationToken
   */
  virtual void revokeLongSession(const std::string& authenticationToken) = 0;

  /**
   * This is used to take an existing authentication token that grants access
   * to an individual user account (returned from 'authenticate',
   * 'authenticateLongSession' or an OAuth authorization) and obtain an additional
   * authentication token that may be used to access business notebooks if the user
   * is a member of an Evernote Business account.
   * 
   * The resulting authentication token may be used to make NoteStore API calls
   * against the business using the NoteStore URL returned in the result.
   * 
   * @param authenticationToken
   *   The authentication token for the user. This may not be a shared authentication
   *   token (returned by NoteStore.authenticateToSharedNotebook or
   *   NoteStore.authenticateToSharedNote) or a business authentication token.
   * 
   * @return
   *   The result of the authentication, with the token granting access to the
   *   business in the result's 'authenticationToken' field. The URL that must
   *   be used to access the business account NoteStore will be returned in the
   *   result's 'noteStoreUrl' field.  The 'User' field will
   *   not be set in the result.
   * 
   * @throws EDAMUserException <ul>
   *   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
   *        is a shared or business authentication token. </li>
   *   <li> PERMISSION_DENIED "Business" - the user identified by the provided
   *        authentication token is not currently a member of a business. </li>
   *   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
   *        member of is not currently in an active status. </li>
   *   <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
   *        sign-on before authenticating to the business.
   * </ul>
   * 
   * @param authenticationToken
   */
  virtual void authenticateToBusiness(AuthenticationResult& _return, const std::string& authenticationToken) = 0;

  /**
   * Returns the User corresponding to the provided authentication token,
   * or throws an exception if this token is not valid.
   * The level of detail provided in the returned User structure depends on
   * the access level granted by the token, so a web service client may receive
   * fewer fields than an integrated desktop client.
   * 
   * @param authenticationToken
   */
  virtual void getUser( ::evernote::edam::User& _return, const std::string& authenticationToken) = 0;

  /**
   * Asks the UserStore about the publicly available location information for
   * a particular username.
   * 
   * @throws EDAMUserException <ul>
   *   <li> DATA_REQUIRED "username" - username is empty
   * </ul>
   * 
   * @param username
   */
  virtual void getPublicUserInfo(PublicUserInfo& _return, const std::string& username) = 0;

  /**
   * <p>Returns the URLs that should be used when sending requests to the service on
   * behalf of the account represented by the provided authenticationToken.</p>
   * 
   * <p>This method isn't needed by most clients, who can retreive the correct set of
   * UserUrls from the AuthenticationResult returned from
   * UserStore#authenticateLongSession(). This method is typically only needed to look up
   * the correct URLs for an existing long-lived authentication token.</p>
   * 
   * @param authenticationToken
   */
  virtual void getUserUrls(UserUrls& _return, const std::string& authenticationToken) = 0;

  /**
   * Invite a user to join an Evernote Business account.
   * 
   * Behavior will depend on the auth token. <ol>
   *   <li>
   *     auth token with privileges to manage Evernote Business membership.
   *       "External Provisioning" - The user will receive an email inviting
   *       them to join the business. They do not need to have an existing Evernote
   *       account. If the user has already been invited, a new invitation email
   *       will be sent.
   *   </li>
   *   <li>
   *     business auth token issued to an admin user. Only for first-party clients:
   *       "Approve Invitation" - If there has been a request to invite the email,
   *       approve it. Invited user will receive email with a link to join business.
   *       "Invite User" - If no invitation for the email exists, create an approved
   *       invitation for the email. An email will be sent to the emailAddress with
   *       a link to join the caller's business.
   *   </li>
   *   </li>
   *     business auth token:
   *       "Request Invitation" - If no invitation exists, create a request to
   *       invite the user to the business. These requests do not count towards a
   *       business' max active user limit.
   *   </li>
   * </ol>
   * 
   * @param authenticationToken
   *   the authentication token with sufficient privileges to manage Evernote Business
   *   membership or a business auth token.
   * 
   * @param emailAddress
   *   the email address of the user to invite to join the Evernote Business account.
   * 
   * @throws EDAMUserException <ul>
   *   <li> DATA_REQUIRED "email" - if no email address was provided </li>
   *   <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
   *   <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
   *     whose business email address matches the specified email address. </li>
   *   <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
   *     user limit. </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param emailAddress
   */
  virtual void inviteToBusiness(const std::string& authenticationToken, const std::string& emailAddress) = 0;

  /**
   * Remove a user from an Evernote Business account. Once removed, the user will no
   * longer be able to access content within the Evernote Business account.
   * 
   * <p>The email address of the user to remove from the business must match the email
   * address used to invite a user to join the business via UserStore.inviteToBusiness.
   * This function will only remove users who were invited by external provisioning</p>
   * 
   * @param authenticationToken
   *   An authentication token with sufficient privileges to manage Evernote Business
   *   membership.
   * 
   * @param emailAddress
   *   The email address of the user to remove from the Evernote Business account.
   * 
   * @throws EDAMUserException <ul>
   *   <li> DATA_REQUIRED "email" - if no email address was provided </li>
   *   <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
   * </ul>
   * @throws EDAMNotFoundException <ul>
   *   <li> "email" - If there is no user with the specified email address in the
   *     business or that user was not invited via external provisioning. </li>
   * </ul>
   * 
   * @param authenticationToken
   * @param emailAddress
   */
  virtual void removeFromBusiness(const std::string& authenticationToken, const std::string& emailAddress) = 0;

  /**
   * Update the email address used to uniquely identify an Evernote Business user.
   * 
   * This will update the identifier for a user who was previously invited using
   * inviteToBusiness, ensuring that caller and the Evernote service maintain an
   * agreed-upon identifier for a specific user.
   * 
   * For example, the following sequence of calls would invite a user to join
   * a business, update their email address, and then remove the user
   * from the business using the updated email address.
   * 
   * inviteToBusiness("foo@bar.com")
   * updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
   * removeFromBusiness("baz@bar.com")
   * 
   * @param authenticationToken
   *   An authentication token with sufficient privileges to manage Evernote Business
   *   membership.
   * 
   * @param oldEmailAddress
   *   The existing email address used to uniquely identify the user.
   * 
   * @param newEmailAddress
   *   The new email address used to uniquely identify the user.
   * 
   * @throws EDAMUserException <ul>
   *   <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
   *   <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
   *   <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
   *   <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
   *   <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
   *   <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
   *     the provided new email address.</li>
   *   <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
   *     oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
   *     updated.</li>
   * </ul>
   * @throws EDAMNotFoundException <ul>
   *   <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
   *     in the business.</li>
   * </ul>
   * 
   * @param authenticationToken
   * @param oldEmailAddress
   * @param newEmailAddress
   */
  virtual void updateBusinessUserIdentifier(const std::string& authenticationToken, const std::string& oldEmailAddress, const std::string& newEmailAddress) = 0;

  /**
   * Returns a list of active business users in a given business.
   * 
   * Clients are required to cache this information and re-fetch no more than once per day
   * or when they encountered a user ID or username that was not known to them.
   * 
   * To avoid excessive look ups, clients should also track user IDs and usernames that belong
   * to users who are not in the business, since they will not be included in the result.
   * 
   * I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
   * listBusinessUsers to find information about this user. If the user is not in the resulting
   * list, the client should track that fact and not re-query the service the next time that it sees
   * this user on a note.
   * 
   * @param authenticationToken
   *   A business authentication token returned by authenticateToBusiness or with sufficient
   *   privileges to manage Evernote Business membership.
   * 
   * @param authenticationToken
   */
  virtual void listBusinessUsers(std::vector< ::evernote::edam::UserProfile> & _return, const std::string& authenticationToken) = 0;

  /**
   * Returns a list of outstanding invitations to join an Evernote Business account.
   * 
   * Only outstanding invitations are returned by this function. Users who have accepted an
   * invitation and joined a business are listed using listBusinessUsers.
   * 
   * @param authenticationToken
   *   An authentication token with sufficient privileges to manage Evernote Business membership.
   * 
   * @param includeRequestedInvitations
   *   If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
   *   in the returned list. If false, only invitations with a status of
   *   BusinessInvitationStatus.APPROVED will be included.
   * 
   * @param authenticationToken
   * @param includeRequestedInvitations
   */
  virtual void listBusinessInvitations(std::vector< ::evernote::edam::BusinessInvitation> & _return, const std::string& authenticationToken, const bool includeRequestedInvitations) = 0;

  /**
   * Retrieve the standard account limits for a given service level. This should only be
   * called when necessary, e.g. to determine if a higher level is available should the
   * user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
   * not expected to fluctuate frequently.
   * 
   * @throws EDAMUserException <ul>
   *   <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
   * </ul>
   * 
   * @param serviceLevel
   */
  virtual void getAccountLimits( ::evernote::edam::AccountLimits& _return, const  ::evernote::edam::ServiceLevel::type serviceLevel) = 0;
};

class UserStoreIfFactory {
 public:
  typedef UserStoreIf Handler;

  virtual ~UserStoreIfFactory() {}

  virtual UserStoreIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(UserStoreIf* /* handler */) = 0;
};

class UserStoreIfSingletonFactory : virtual public UserStoreIfFactory {
 public:
  UserStoreIfSingletonFactory(const boost::shared_ptr<UserStoreIf>& iface) : iface_(iface) {}
  virtual ~UserStoreIfSingletonFactory() {}

  virtual UserStoreIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(UserStoreIf* /* handler */) {}

 protected:
  boost::shared_ptr<UserStoreIf> iface_;
};

class UserStoreNull : virtual public UserStoreIf {
 public:
  virtual ~UserStoreNull() {}
  bool checkVersion(const std::string& /* clientName */, const int16_t /* edamVersionMajor */, const int16_t /* edamVersionMinor */) {
    bool _return = false;
    return _return;
  }
  void getBootstrapInfo(BootstrapInfo& /* _return */, const std::string& /* locale */) {
    return;
  }
  void authenticateLongSession(AuthenticationResult& /* _return */, const std::string& /* username */, const std::string& /* password */, const std::string& /* consumerKey */, const std::string& /* consumerSecret */, const std::string& /* deviceIdentifier */, const std::string& /* deviceDescription */, const bool /* supportsTwoFactor */) {
    return;
  }
  void completeTwoFactorAuthentication(AuthenticationResult& /* _return */, const std::string& /* authenticationToken */, const std::string& /* oneTimeCode */, const std::string& /* deviceIdentifier */, const std::string& /* deviceDescription */) {
    return;
  }
  void revokeLongSession(const std::string& /* authenticationToken */) {
    return;
  }
  void authenticateToBusiness(AuthenticationResult& /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void getUser( ::evernote::edam::User& /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void getPublicUserInfo(PublicUserInfo& /* _return */, const std::string& /* username */) {
    return;
  }
  void getUserUrls(UserUrls& /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void inviteToBusiness(const std::string& /* authenticationToken */, const std::string& /* emailAddress */) {
    return;
  }
  void removeFromBusiness(const std::string& /* authenticationToken */, const std::string& /* emailAddress */) {
    return;
  }
  void updateBusinessUserIdentifier(const std::string& /* authenticationToken */, const std::string& /* oldEmailAddress */, const std::string& /* newEmailAddress */) {
    return;
  }
  void listBusinessUsers(std::vector< ::evernote::edam::UserProfile> & /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void listBusinessInvitations(std::vector< ::evernote::edam::BusinessInvitation> & /* _return */, const std::string& /* authenticationToken */, const bool /* includeRequestedInvitations */) {
    return;
  }
  void getAccountLimits( ::evernote::edam::AccountLimits& /* _return */, const  ::evernote::edam::ServiceLevel::type /* serviceLevel */) {
    return;
  }
};

typedef struct _UserStore_checkVersion_args__isset {
  _UserStore_checkVersion_args__isset() : clientName(false), edamVersionMajor(true), edamVersionMinor(true) {}
  bool clientName :1;
  bool edamVersionMajor :1;
  bool edamVersionMinor :1;
} _UserStore_checkVersion_args__isset;

class UserStore_checkVersion_args {
 public:

  UserStore_checkVersion_args(const UserStore_checkVersion_args&);
  UserStore_checkVersion_args& operator=(const UserStore_checkVersion_args&);
  UserStore_checkVersion_args() : clientName(), edamVersionMajor(1), edamVersionMinor(28) {
  }

  virtual ~UserStore_checkVersion_args() throw();
  std::string clientName;
  int16_t edamVersionMajor;
  int16_t edamVersionMinor;

  _UserStore_checkVersion_args__isset __isset;

  void __set_clientName(const std::string& val);

  void __set_edamVersionMajor(const int16_t val);

  void __set_edamVersionMinor(const int16_t val);

  bool operator == (const UserStore_checkVersion_args & rhs) const
  {
    if (!(clientName == rhs.clientName))
      return false;
    if (!(edamVersionMajor == rhs.edamVersionMajor))
      return false;
    if (!(edamVersionMinor == rhs.edamVersionMinor))
      return false;
    return true;
  }
  bool operator != (const UserStore_checkVersion_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_checkVersion_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_checkVersion_pargs {
 public:


  virtual ~UserStore_checkVersion_pargs() throw();
  const std::string* clientName;
  const int16_t* edamVersionMajor;
  const int16_t* edamVersionMinor;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_checkVersion_result__isset {
  _UserStore_checkVersion_result__isset() : success(false) {}
  bool success :1;
} _UserStore_checkVersion_result__isset;

class UserStore_checkVersion_result {
 public:

  UserStore_checkVersion_result(const UserStore_checkVersion_result&);
  UserStore_checkVersion_result& operator=(const UserStore_checkVersion_result&);
  UserStore_checkVersion_result() : success(0) {
  }

  virtual ~UserStore_checkVersion_result() throw();
  bool success;

  _UserStore_checkVersion_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const UserStore_checkVersion_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const UserStore_checkVersion_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_checkVersion_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_checkVersion_presult__isset {
  _UserStore_checkVersion_presult__isset() : success(false) {}
  bool success :1;
} _UserStore_checkVersion_presult__isset;

class UserStore_checkVersion_presult {
 public:


  virtual ~UserStore_checkVersion_presult() throw();
  bool* success;

  _UserStore_checkVersion_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_getBootstrapInfo_args__isset {
  _UserStore_getBootstrapInfo_args__isset() : locale(false) {}
  bool locale :1;
} _UserStore_getBootstrapInfo_args__isset;

class UserStore_getBootstrapInfo_args {
 public:

  UserStore_getBootstrapInfo_args(const UserStore_getBootstrapInfo_args&);
  UserStore_getBootstrapInfo_args& operator=(const UserStore_getBootstrapInfo_args&);
  UserStore_getBootstrapInfo_args() : locale() {
  }

  virtual ~UserStore_getBootstrapInfo_args() throw();
  std::string locale;

  _UserStore_getBootstrapInfo_args__isset __isset;

  void __set_locale(const std::string& val);

  bool operator == (const UserStore_getBootstrapInfo_args & rhs) const
  {
    if (!(locale == rhs.locale))
      return false;
    return true;
  }
  bool operator != (const UserStore_getBootstrapInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getBootstrapInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_getBootstrapInfo_pargs {
 public:


  virtual ~UserStore_getBootstrapInfo_pargs() throw();
  const std::string* locale;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getBootstrapInfo_result__isset {
  _UserStore_getBootstrapInfo_result__isset() : success(false) {}
  bool success :1;
} _UserStore_getBootstrapInfo_result__isset;

class UserStore_getBootstrapInfo_result {
 public:

  UserStore_getBootstrapInfo_result(const UserStore_getBootstrapInfo_result&);
  UserStore_getBootstrapInfo_result& operator=(const UserStore_getBootstrapInfo_result&);
  UserStore_getBootstrapInfo_result() {
  }

  virtual ~UserStore_getBootstrapInfo_result() throw();
  BootstrapInfo success;

  _UserStore_getBootstrapInfo_result__isset __isset;

  void __set_success(const BootstrapInfo& val);

  bool operator == (const UserStore_getBootstrapInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const UserStore_getBootstrapInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getBootstrapInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getBootstrapInfo_presult__isset {
  _UserStore_getBootstrapInfo_presult__isset() : success(false) {}
  bool success :1;
} _UserStore_getBootstrapInfo_presult__isset;

class UserStore_getBootstrapInfo_presult {
 public:


  virtual ~UserStore_getBootstrapInfo_presult() throw();
  BootstrapInfo* success;

  _UserStore_getBootstrapInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_authenticateLongSession_args__isset {
  _UserStore_authenticateLongSession_args__isset() : username(false), password(false), consumerKey(false), consumerSecret(false), deviceIdentifier(false), deviceDescription(false), supportsTwoFactor(false) {}
  bool username :1;
  bool password :1;
  bool consumerKey :1;
  bool consumerSecret :1;
  bool deviceIdentifier :1;
  bool deviceDescription :1;
  bool supportsTwoFactor :1;
} _UserStore_authenticateLongSession_args__isset;

class UserStore_authenticateLongSession_args {
 public:

  UserStore_authenticateLongSession_args(const UserStore_authenticateLongSession_args&);
  UserStore_authenticateLongSession_args& operator=(const UserStore_authenticateLongSession_args&);
  UserStore_authenticateLongSession_args() : username(), password(), consumerKey(), consumerSecret(), deviceIdentifier(), deviceDescription(), supportsTwoFactor(0) {
  }

  virtual ~UserStore_authenticateLongSession_args() throw();
  std::string username;
  std::string password;
  std::string consumerKey;
  std::string consumerSecret;
  std::string deviceIdentifier;
  std::string deviceDescription;
  bool supportsTwoFactor;

  _UserStore_authenticateLongSession_args__isset __isset;

  void __set_username(const std::string& val);

  void __set_password(const std::string& val);

  void __set_consumerKey(const std::string& val);

  void __set_consumerSecret(const std::string& val);

  void __set_deviceIdentifier(const std::string& val);

  void __set_deviceDescription(const std::string& val);

  void __set_supportsTwoFactor(const bool val);

  bool operator == (const UserStore_authenticateLongSession_args & rhs) const
  {
    if (!(username == rhs.username))
      return false;
    if (!(password == rhs.password))
      return false;
    if (!(consumerKey == rhs.consumerKey))
      return false;
    if (!(consumerSecret == rhs.consumerSecret))
      return false;
    if (!(deviceIdentifier == rhs.deviceIdentifier))
      return false;
    if (!(deviceDescription == rhs.deviceDescription))
      return false;
    if (!(supportsTwoFactor == rhs.supportsTwoFactor))
      return false;
    return true;
  }
  bool operator != (const UserStore_authenticateLongSession_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_authenticateLongSession_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_authenticateLongSession_pargs {
 public:


  virtual ~UserStore_authenticateLongSession_pargs() throw();
  const std::string* username;
  const std::string* password;
  const std::string* consumerKey;
  const std::string* consumerSecret;
  const std::string* deviceIdentifier;
  const std::string* deviceDescription;
  const bool* supportsTwoFactor;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_authenticateLongSession_result__isset {
  _UserStore_authenticateLongSession_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_authenticateLongSession_result__isset;

class UserStore_authenticateLongSession_result {
 public:

  UserStore_authenticateLongSession_result(const UserStore_authenticateLongSession_result&);
  UserStore_authenticateLongSession_result& operator=(const UserStore_authenticateLongSession_result&);
  UserStore_authenticateLongSession_result() {
  }

  virtual ~UserStore_authenticateLongSession_result() throw();
  AuthenticationResult success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_authenticateLongSession_result__isset __isset;

  void __set_success(const AuthenticationResult& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const UserStore_authenticateLongSession_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_authenticateLongSession_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_authenticateLongSession_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_authenticateLongSession_presult__isset {
  _UserStore_authenticateLongSession_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_authenticateLongSession_presult__isset;

class UserStore_authenticateLongSession_presult {
 public:


  virtual ~UserStore_authenticateLongSession_presult() throw();
  AuthenticationResult* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_authenticateLongSession_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_completeTwoFactorAuthentication_args__isset {
  _UserStore_completeTwoFactorAuthentication_args__isset() : authenticationToken(false), oneTimeCode(false), deviceIdentifier(false), deviceDescription(false) {}
  bool authenticationToken :1;
  bool oneTimeCode :1;
  bool deviceIdentifier :1;
  bool deviceDescription :1;
} _UserStore_completeTwoFactorAuthentication_args__isset;

class UserStore_completeTwoFactorAuthentication_args {
 public:

  UserStore_completeTwoFactorAuthentication_args(const UserStore_completeTwoFactorAuthentication_args&);
  UserStore_completeTwoFactorAuthentication_args& operator=(const UserStore_completeTwoFactorAuthentication_args&);
  UserStore_completeTwoFactorAuthentication_args() : authenticationToken(), oneTimeCode(), deviceIdentifier(), deviceDescription() {
  }

  virtual ~UserStore_completeTwoFactorAuthentication_args() throw();
  std::string authenticationToken;
  std::string oneTimeCode;
  std::string deviceIdentifier;
  std::string deviceDescription;

  _UserStore_completeTwoFactorAuthentication_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_oneTimeCode(const std::string& val);

  void __set_deviceIdentifier(const std::string& val);

  void __set_deviceDescription(const std::string& val);

  bool operator == (const UserStore_completeTwoFactorAuthentication_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(oneTimeCode == rhs.oneTimeCode))
      return false;
    if (!(deviceIdentifier == rhs.deviceIdentifier))
      return false;
    if (!(deviceDescription == rhs.deviceDescription))
      return false;
    return true;
  }
  bool operator != (const UserStore_completeTwoFactorAuthentication_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_completeTwoFactorAuthentication_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_completeTwoFactorAuthentication_pargs {
 public:


  virtual ~UserStore_completeTwoFactorAuthentication_pargs() throw();
  const std::string* authenticationToken;
  const std::string* oneTimeCode;
  const std::string* deviceIdentifier;
  const std::string* deviceDescription;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_completeTwoFactorAuthentication_result__isset {
  _UserStore_completeTwoFactorAuthentication_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_completeTwoFactorAuthentication_result__isset;

class UserStore_completeTwoFactorAuthentication_result {
 public:

  UserStore_completeTwoFactorAuthentication_result(const UserStore_completeTwoFactorAuthentication_result&);
  UserStore_completeTwoFactorAuthentication_result& operator=(const UserStore_completeTwoFactorAuthentication_result&);
  UserStore_completeTwoFactorAuthentication_result() {
  }

  virtual ~UserStore_completeTwoFactorAuthentication_result() throw();
  AuthenticationResult success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_completeTwoFactorAuthentication_result__isset __isset;

  void __set_success(const AuthenticationResult& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const UserStore_completeTwoFactorAuthentication_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_completeTwoFactorAuthentication_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_completeTwoFactorAuthentication_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_completeTwoFactorAuthentication_presult__isset {
  _UserStore_completeTwoFactorAuthentication_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_completeTwoFactorAuthentication_presult__isset;

class UserStore_completeTwoFactorAuthentication_presult {
 public:


  virtual ~UserStore_completeTwoFactorAuthentication_presult() throw();
  AuthenticationResult* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_completeTwoFactorAuthentication_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_revokeLongSession_args__isset {
  _UserStore_revokeLongSession_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _UserStore_revokeLongSession_args__isset;

class UserStore_revokeLongSession_args {
 public:

  UserStore_revokeLongSession_args(const UserStore_revokeLongSession_args&);
  UserStore_revokeLongSession_args& operator=(const UserStore_revokeLongSession_args&);
  UserStore_revokeLongSession_args() : authenticationToken() {
  }

  virtual ~UserStore_revokeLongSession_args() throw();
  std::string authenticationToken;

  _UserStore_revokeLongSession_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const UserStore_revokeLongSession_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const UserStore_revokeLongSession_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_revokeLongSession_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_revokeLongSession_pargs {
 public:


  virtual ~UserStore_revokeLongSession_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_revokeLongSession_result__isset {
  _UserStore_revokeLongSession_result__isset() : userException(false), systemException(false) {}
  bool userException :1;
  bool systemException :1;
} _UserStore_revokeLongSession_result__isset;

class UserStore_revokeLongSession_result {
 public:

  UserStore_revokeLongSession_result(const UserStore_revokeLongSession_result&);
  UserStore_revokeLongSession_result& operator=(const UserStore_revokeLongSession_result&);
  UserStore_revokeLongSession_result() {
  }

  virtual ~UserStore_revokeLongSession_result() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_revokeLongSession_result__isset __isset;

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const UserStore_revokeLongSession_result & rhs) const
  {
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_revokeLongSession_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_revokeLongSession_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_revokeLongSession_presult__isset {
  _UserStore_revokeLongSession_presult__isset() : userException(false), systemException(false) {}
  bool userException :1;
  bool systemException :1;
} _UserStore_revokeLongSession_presult__isset;

class UserStore_revokeLongSession_presult {
 public:


  virtual ~UserStore_revokeLongSession_presult() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_revokeLongSession_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_authenticateToBusiness_args__isset {
  _UserStore_authenticateToBusiness_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _UserStore_authenticateToBusiness_args__isset;

class UserStore_authenticateToBusiness_args {
 public:

  UserStore_authenticateToBusiness_args(const UserStore_authenticateToBusiness_args&);
  UserStore_authenticateToBusiness_args& operator=(const UserStore_authenticateToBusiness_args&);
  UserStore_authenticateToBusiness_args() : authenticationToken() {
  }

  virtual ~UserStore_authenticateToBusiness_args() throw();
  std::string authenticationToken;

  _UserStore_authenticateToBusiness_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const UserStore_authenticateToBusiness_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const UserStore_authenticateToBusiness_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_authenticateToBusiness_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_authenticateToBusiness_pargs {
 public:


  virtual ~UserStore_authenticateToBusiness_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_authenticateToBusiness_result__isset {
  _UserStore_authenticateToBusiness_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_authenticateToBusiness_result__isset;

class UserStore_authenticateToBusiness_result {
 public:

  UserStore_authenticateToBusiness_result(const UserStore_authenticateToBusiness_result&);
  UserStore_authenticateToBusiness_result& operator=(const UserStore_authenticateToBusiness_result&);
  UserStore_authenticateToBusiness_result() {
  }

  virtual ~UserStore_authenticateToBusiness_result() throw();
  AuthenticationResult success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_authenticateToBusiness_result__isset __isset;

  void __set_success(const AuthenticationResult& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const UserStore_authenticateToBusiness_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_authenticateToBusiness_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_authenticateToBusiness_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_authenticateToBusiness_presult__isset {
  _UserStore_authenticateToBusiness_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_authenticateToBusiness_presult__isset;

class UserStore_authenticateToBusiness_presult {
 public:


  virtual ~UserStore_authenticateToBusiness_presult() throw();
  AuthenticationResult* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_authenticateToBusiness_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_getUser_args__isset {
  _UserStore_getUser_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _UserStore_getUser_args__isset;

class UserStore_getUser_args {
 public:

  UserStore_getUser_args(const UserStore_getUser_args&);
  UserStore_getUser_args& operator=(const UserStore_getUser_args&);
  UserStore_getUser_args() : authenticationToken() {
  }

  virtual ~UserStore_getUser_args() throw();
  std::string authenticationToken;

  _UserStore_getUser_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const UserStore_getUser_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const UserStore_getUser_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getUser_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_getUser_pargs {
 public:


  virtual ~UserStore_getUser_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getUser_result__isset {
  _UserStore_getUser_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_getUser_result__isset;

class UserStore_getUser_result {
 public:

  UserStore_getUser_result(const UserStore_getUser_result&);
  UserStore_getUser_result& operator=(const UserStore_getUser_result&);
  UserStore_getUser_result() {
  }

  virtual ~UserStore_getUser_result() throw();
   ::evernote::edam::User success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_getUser_result__isset __isset;

  void __set_success(const  ::evernote::edam::User& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const UserStore_getUser_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_getUser_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getUser_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getUser_presult__isset {
  _UserStore_getUser_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_getUser_presult__isset;

class UserStore_getUser_presult {
 public:


  virtual ~UserStore_getUser_presult() throw();
   ::evernote::edam::User* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_getUser_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_getPublicUserInfo_args__isset {
  _UserStore_getPublicUserInfo_args__isset() : username(false) {}
  bool username :1;
} _UserStore_getPublicUserInfo_args__isset;

class UserStore_getPublicUserInfo_args {
 public:

  UserStore_getPublicUserInfo_args(const UserStore_getPublicUserInfo_args&);
  UserStore_getPublicUserInfo_args& operator=(const UserStore_getPublicUserInfo_args&);
  UserStore_getPublicUserInfo_args() : username() {
  }

  virtual ~UserStore_getPublicUserInfo_args() throw();
  std::string username;

  _UserStore_getPublicUserInfo_args__isset __isset;

  void __set_username(const std::string& val);

  bool operator == (const UserStore_getPublicUserInfo_args & rhs) const
  {
    if (!(username == rhs.username))
      return false;
    return true;
  }
  bool operator != (const UserStore_getPublicUserInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getPublicUserInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_getPublicUserInfo_pargs {
 public:


  virtual ~UserStore_getPublicUserInfo_pargs() throw();
  const std::string* username;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getPublicUserInfo_result__isset {
  _UserStore_getPublicUserInfo_result__isset() : success(false), notFoundException(false), systemException(false), userException(false) {}
  bool success :1;
  bool notFoundException :1;
  bool systemException :1;
  bool userException :1;
} _UserStore_getPublicUserInfo_result__isset;

class UserStore_getPublicUserInfo_result {
 public:

  UserStore_getPublicUserInfo_result(const UserStore_getPublicUserInfo_result&);
  UserStore_getPublicUserInfo_result& operator=(const UserStore_getPublicUserInfo_result&);
  UserStore_getPublicUserInfo_result() {
  }

  virtual ~UserStore_getPublicUserInfo_result() throw();
  PublicUserInfo success;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMUserException userException;

  _UserStore_getPublicUserInfo_result__isset __isset;

  void __set_success(const PublicUserInfo& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  bool operator == (const UserStore_getPublicUserInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(userException == rhs.userException))
      return false;
    return true;
  }
  bool operator != (const UserStore_getPublicUserInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getPublicUserInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getPublicUserInfo_presult__isset {
  _UserStore_getPublicUserInfo_presult__isset() : success(false), notFoundException(false), systemException(false), userException(false) {}
  bool success :1;
  bool notFoundException :1;
  bool systemException :1;
  bool userException :1;
} _UserStore_getPublicUserInfo_presult__isset;

class UserStore_getPublicUserInfo_presult {
 public:


  virtual ~UserStore_getPublicUserInfo_presult() throw();
  PublicUserInfo* success;
   ::evernote::edam::EDAMNotFoundException notFoundException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMUserException userException;

  _UserStore_getPublicUserInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_getUserUrls_args__isset {
  _UserStore_getUserUrls_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _UserStore_getUserUrls_args__isset;

class UserStore_getUserUrls_args {
 public:

  UserStore_getUserUrls_args(const UserStore_getUserUrls_args&);
  UserStore_getUserUrls_args& operator=(const UserStore_getUserUrls_args&);
  UserStore_getUserUrls_args() : authenticationToken() {
  }

  virtual ~UserStore_getUserUrls_args() throw();
  std::string authenticationToken;

  _UserStore_getUserUrls_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const UserStore_getUserUrls_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const UserStore_getUserUrls_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getUserUrls_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_getUserUrls_pargs {
 public:


  virtual ~UserStore_getUserUrls_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getUserUrls_result__isset {
  _UserStore_getUserUrls_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_getUserUrls_result__isset;

class UserStore_getUserUrls_result {
 public:

  UserStore_getUserUrls_result(const UserStore_getUserUrls_result&);
  UserStore_getUserUrls_result& operator=(const UserStore_getUserUrls_result&);
  UserStore_getUserUrls_result() {
  }

  virtual ~UserStore_getUserUrls_result() throw();
  UserUrls success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_getUserUrls_result__isset __isset;

  void __set_success(const UserUrls& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const UserStore_getUserUrls_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_getUserUrls_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getUserUrls_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getUserUrls_presult__isset {
  _UserStore_getUserUrls_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_getUserUrls_presult__isset;

class UserStore_getUserUrls_presult {
 public:


  virtual ~UserStore_getUserUrls_presult() throw();
  UserUrls* success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_getUserUrls_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_inviteToBusiness_args__isset {
  _UserStore_inviteToBusiness_args__isset() : authenticationToken(false), emailAddress(false) {}
  bool authenticationToken :1;
  bool emailAddress :1;
} _UserStore_inviteToBusiness_args__isset;

class UserStore_inviteToBusiness_args {
 public:

  UserStore_inviteToBusiness_args(const UserStore_inviteToBusiness_args&);
  UserStore_inviteToBusiness_args& operator=(const UserStore_inviteToBusiness_args&);
  UserStore_inviteToBusiness_args() : authenticationToken(), emailAddress() {
  }

  virtual ~UserStore_inviteToBusiness_args() throw();
  std::string authenticationToken;
  std::string emailAddress;

  _UserStore_inviteToBusiness_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_emailAddress(const std::string& val);

  bool operator == (const UserStore_inviteToBusiness_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(emailAddress == rhs.emailAddress))
      return false;
    return true;
  }
  bool operator != (const UserStore_inviteToBusiness_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_inviteToBusiness_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_inviteToBusiness_pargs {
 public:


  virtual ~UserStore_inviteToBusiness_pargs() throw();
  const std::string* authenticationToken;
  const std::string* emailAddress;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_inviteToBusiness_result__isset {
  _UserStore_inviteToBusiness_result__isset() : userException(false), systemException(false) {}
  bool userException :1;
  bool systemException :1;
} _UserStore_inviteToBusiness_result__isset;

class UserStore_inviteToBusiness_result {
 public:

  UserStore_inviteToBusiness_result(const UserStore_inviteToBusiness_result&);
  UserStore_inviteToBusiness_result& operator=(const UserStore_inviteToBusiness_result&);
  UserStore_inviteToBusiness_result() {
  }

  virtual ~UserStore_inviteToBusiness_result() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_inviteToBusiness_result__isset __isset;

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const UserStore_inviteToBusiness_result & rhs) const
  {
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_inviteToBusiness_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_inviteToBusiness_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_inviteToBusiness_presult__isset {
  _UserStore_inviteToBusiness_presult__isset() : userException(false), systemException(false) {}
  bool userException :1;
  bool systemException :1;
} _UserStore_inviteToBusiness_presult__isset;

class UserStore_inviteToBusiness_presult {
 public:


  virtual ~UserStore_inviteToBusiness_presult() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_inviteToBusiness_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_removeFromBusiness_args__isset {
  _UserStore_removeFromBusiness_args__isset() : authenticationToken(false), emailAddress(false) {}
  bool authenticationToken :1;
  bool emailAddress :1;
} _UserStore_removeFromBusiness_args__isset;

class UserStore_removeFromBusiness_args {
 public:

  UserStore_removeFromBusiness_args(const UserStore_removeFromBusiness_args&);
  UserStore_removeFromBusiness_args& operator=(const UserStore_removeFromBusiness_args&);
  UserStore_removeFromBusiness_args() : authenticationToken(), emailAddress() {
  }

  virtual ~UserStore_removeFromBusiness_args() throw();
  std::string authenticationToken;
  std::string emailAddress;

  _UserStore_removeFromBusiness_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_emailAddress(const std::string& val);

  bool operator == (const UserStore_removeFromBusiness_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(emailAddress == rhs.emailAddress))
      return false;
    return true;
  }
  bool operator != (const UserStore_removeFromBusiness_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_removeFromBusiness_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_removeFromBusiness_pargs {
 public:


  virtual ~UserStore_removeFromBusiness_pargs() throw();
  const std::string* authenticationToken;
  const std::string* emailAddress;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_removeFromBusiness_result__isset {
  _UserStore_removeFromBusiness_result__isset() : userException(false), systemException(false), notFoundException(false) {}
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _UserStore_removeFromBusiness_result__isset;

class UserStore_removeFromBusiness_result {
 public:

  UserStore_removeFromBusiness_result(const UserStore_removeFromBusiness_result&);
  UserStore_removeFromBusiness_result& operator=(const UserStore_removeFromBusiness_result&);
  UserStore_removeFromBusiness_result() {
  }

  virtual ~UserStore_removeFromBusiness_result() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _UserStore_removeFromBusiness_result__isset __isset;

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const UserStore_removeFromBusiness_result & rhs) const
  {
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const UserStore_removeFromBusiness_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_removeFromBusiness_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_removeFromBusiness_presult__isset {
  _UserStore_removeFromBusiness_presult__isset() : userException(false), systemException(false), notFoundException(false) {}
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _UserStore_removeFromBusiness_presult__isset;

class UserStore_removeFromBusiness_presult {
 public:


  virtual ~UserStore_removeFromBusiness_presult() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _UserStore_removeFromBusiness_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_updateBusinessUserIdentifier_args__isset {
  _UserStore_updateBusinessUserIdentifier_args__isset() : authenticationToken(false), oldEmailAddress(false), newEmailAddress(false) {}
  bool authenticationToken :1;
  bool oldEmailAddress :1;
  bool newEmailAddress :1;
} _UserStore_updateBusinessUserIdentifier_args__isset;

class UserStore_updateBusinessUserIdentifier_args {
 public:

  UserStore_updateBusinessUserIdentifier_args(const UserStore_updateBusinessUserIdentifier_args&);
  UserStore_updateBusinessUserIdentifier_args& operator=(const UserStore_updateBusinessUserIdentifier_args&);
  UserStore_updateBusinessUserIdentifier_args() : authenticationToken(), oldEmailAddress(), newEmailAddress() {
  }

  virtual ~UserStore_updateBusinessUserIdentifier_args() throw();
  std::string authenticationToken;
  std::string oldEmailAddress;
  std::string newEmailAddress;

  _UserStore_updateBusinessUserIdentifier_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_oldEmailAddress(const std::string& val);

  void __set_newEmailAddress(const std::string& val);

  bool operator == (const UserStore_updateBusinessUserIdentifier_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(oldEmailAddress == rhs.oldEmailAddress))
      return false;
    if (!(newEmailAddress == rhs.newEmailAddress))
      return false;
    return true;
  }
  bool operator != (const UserStore_updateBusinessUserIdentifier_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_updateBusinessUserIdentifier_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_updateBusinessUserIdentifier_pargs {
 public:


  virtual ~UserStore_updateBusinessUserIdentifier_pargs() throw();
  const std::string* authenticationToken;
  const std::string* oldEmailAddress;
  const std::string* newEmailAddress;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_updateBusinessUserIdentifier_result__isset {
  _UserStore_updateBusinessUserIdentifier_result__isset() : userException(false), systemException(false), notFoundException(false) {}
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _UserStore_updateBusinessUserIdentifier_result__isset;

class UserStore_updateBusinessUserIdentifier_result {
 public:

  UserStore_updateBusinessUserIdentifier_result(const UserStore_updateBusinessUserIdentifier_result&);
  UserStore_updateBusinessUserIdentifier_result& operator=(const UserStore_updateBusinessUserIdentifier_result&);
  UserStore_updateBusinessUserIdentifier_result() {
  }

  virtual ~UserStore_updateBusinessUserIdentifier_result() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _UserStore_updateBusinessUserIdentifier_result__isset __isset;

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const UserStore_updateBusinessUserIdentifier_result & rhs) const
  {
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const UserStore_updateBusinessUserIdentifier_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_updateBusinessUserIdentifier_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_updateBusinessUserIdentifier_presult__isset {
  _UserStore_updateBusinessUserIdentifier_presult__isset() : userException(false), systemException(false), notFoundException(false) {}
  bool userException :1;
  bool systemException :1;
  bool notFoundException :1;
} _UserStore_updateBusinessUserIdentifier_presult__isset;

class UserStore_updateBusinessUserIdentifier_presult {
 public:


  virtual ~UserStore_updateBusinessUserIdentifier_presult() throw();
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _UserStore_updateBusinessUserIdentifier_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_listBusinessUsers_args__isset {
  _UserStore_listBusinessUsers_args__isset() : authenticationToken(false) {}
  bool authenticationToken :1;
} _UserStore_listBusinessUsers_args__isset;

class UserStore_listBusinessUsers_args {
 public:

  UserStore_listBusinessUsers_args(const UserStore_listBusinessUsers_args&);
  UserStore_listBusinessUsers_args& operator=(const UserStore_listBusinessUsers_args&);
  UserStore_listBusinessUsers_args() : authenticationToken() {
  }

  virtual ~UserStore_listBusinessUsers_args() throw();
  std::string authenticationToken;

  _UserStore_listBusinessUsers_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  bool operator == (const UserStore_listBusinessUsers_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const UserStore_listBusinessUsers_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_listBusinessUsers_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_listBusinessUsers_pargs {
 public:


  virtual ~UserStore_listBusinessUsers_pargs() throw();
  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_listBusinessUsers_result__isset {
  _UserStore_listBusinessUsers_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_listBusinessUsers_result__isset;

class UserStore_listBusinessUsers_result {
 public:

  UserStore_listBusinessUsers_result(const UserStore_listBusinessUsers_result&);
  UserStore_listBusinessUsers_result& operator=(const UserStore_listBusinessUsers_result&);
  UserStore_listBusinessUsers_result() {
  }

  virtual ~UserStore_listBusinessUsers_result() throw();
  std::vector< ::evernote::edam::UserProfile>  success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_listBusinessUsers_result__isset __isset;

  void __set_success(const std::vector< ::evernote::edam::UserProfile> & val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const UserStore_listBusinessUsers_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_listBusinessUsers_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_listBusinessUsers_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_listBusinessUsers_presult__isset {
  _UserStore_listBusinessUsers_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_listBusinessUsers_presult__isset;

class UserStore_listBusinessUsers_presult {
 public:


  virtual ~UserStore_listBusinessUsers_presult() throw();
  std::vector< ::evernote::edam::UserProfile> * success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_listBusinessUsers_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_listBusinessInvitations_args__isset {
  _UserStore_listBusinessInvitations_args__isset() : authenticationToken(false), includeRequestedInvitations(false) {}
  bool authenticationToken :1;
  bool includeRequestedInvitations :1;
} _UserStore_listBusinessInvitations_args__isset;

class UserStore_listBusinessInvitations_args {
 public:

  UserStore_listBusinessInvitations_args(const UserStore_listBusinessInvitations_args&);
  UserStore_listBusinessInvitations_args& operator=(const UserStore_listBusinessInvitations_args&);
  UserStore_listBusinessInvitations_args() : authenticationToken(), includeRequestedInvitations(0) {
  }

  virtual ~UserStore_listBusinessInvitations_args() throw();
  std::string authenticationToken;
  bool includeRequestedInvitations;

  _UserStore_listBusinessInvitations_args__isset __isset;

  void __set_authenticationToken(const std::string& val);

  void __set_includeRequestedInvitations(const bool val);

  bool operator == (const UserStore_listBusinessInvitations_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(includeRequestedInvitations == rhs.includeRequestedInvitations))
      return false;
    return true;
  }
  bool operator != (const UserStore_listBusinessInvitations_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_listBusinessInvitations_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_listBusinessInvitations_pargs {
 public:


  virtual ~UserStore_listBusinessInvitations_pargs() throw();
  const std::string* authenticationToken;
  const bool* includeRequestedInvitations;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_listBusinessInvitations_result__isset {
  _UserStore_listBusinessInvitations_result__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_listBusinessInvitations_result__isset;

class UserStore_listBusinessInvitations_result {
 public:

  UserStore_listBusinessInvitations_result(const UserStore_listBusinessInvitations_result&);
  UserStore_listBusinessInvitations_result& operator=(const UserStore_listBusinessInvitations_result&);
  UserStore_listBusinessInvitations_result() {
  }

  virtual ~UserStore_listBusinessInvitations_result() throw();
  std::vector< ::evernote::edam::BusinessInvitation>  success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_listBusinessInvitations_result__isset __isset;

  void __set_success(const std::vector< ::evernote::edam::BusinessInvitation> & val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_systemException(const  ::evernote::edam::EDAMSystemException& val);

  bool operator == (const UserStore_listBusinessInvitations_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_listBusinessInvitations_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_listBusinessInvitations_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_listBusinessInvitations_presult__isset {
  _UserStore_listBusinessInvitations_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success :1;
  bool userException :1;
  bool systemException :1;
} _UserStore_listBusinessInvitations_presult__isset;

class UserStore_listBusinessInvitations_presult {
 public:


  virtual ~UserStore_listBusinessInvitations_presult() throw();
  std::vector< ::evernote::edam::BusinessInvitation> * success;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMSystemException systemException;

  _UserStore_listBusinessInvitations_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_getAccountLimits_args__isset {
  _UserStore_getAccountLimits_args__isset() : serviceLevel(false) {}
  bool serviceLevel :1;
} _UserStore_getAccountLimits_args__isset;

class UserStore_getAccountLimits_args {
 public:

  UserStore_getAccountLimits_args(const UserStore_getAccountLimits_args&);
  UserStore_getAccountLimits_args& operator=(const UserStore_getAccountLimits_args&);
  UserStore_getAccountLimits_args() : serviceLevel(( ::evernote::edam::ServiceLevel::type)0) {
  }

  virtual ~UserStore_getAccountLimits_args() throw();
   ::evernote::edam::ServiceLevel::type serviceLevel;

  _UserStore_getAccountLimits_args__isset __isset;

  void __set_serviceLevel(const  ::evernote::edam::ServiceLevel::type val);

  bool operator == (const UserStore_getAccountLimits_args & rhs) const
  {
    if (!(serviceLevel == rhs.serviceLevel))
      return false;
    return true;
  }
  bool operator != (const UserStore_getAccountLimits_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getAccountLimits_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_getAccountLimits_pargs {
 public:


  virtual ~UserStore_getAccountLimits_pargs() throw();
  const  ::evernote::edam::ServiceLevel::type* serviceLevel;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getAccountLimits_result__isset {
  _UserStore_getAccountLimits_result__isset() : success(false), userException(false) {}
  bool success :1;
  bool userException :1;
} _UserStore_getAccountLimits_result__isset;

class UserStore_getAccountLimits_result {
 public:

  UserStore_getAccountLimits_result(const UserStore_getAccountLimits_result&);
  UserStore_getAccountLimits_result& operator=(const UserStore_getAccountLimits_result&);
  UserStore_getAccountLimits_result() {
  }

  virtual ~UserStore_getAccountLimits_result() throw();
   ::evernote::edam::AccountLimits success;
   ::evernote::edam::EDAMUserException userException;

  _UserStore_getAccountLimits_result__isset __isset;

  void __set_success(const  ::evernote::edam::AccountLimits& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  bool operator == (const UserStore_getAccountLimits_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    return true;
  }
  bool operator != (const UserStore_getAccountLimits_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getAccountLimits_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getAccountLimits_presult__isset {
  _UserStore_getAccountLimits_presult__isset() : success(false), userException(false) {}
  bool success :1;
  bool userException :1;
} _UserStore_getAccountLimits_presult__isset;

class UserStore_getAccountLimits_presult {
 public:


  virtual ~UserStore_getAccountLimits_presult() throw();
   ::evernote::edam::AccountLimits* success;
   ::evernote::edam::EDAMUserException userException;

  _UserStore_getAccountLimits_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class UserStoreClient : virtual public UserStoreIf {
 public:
  UserStoreClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  UserStoreClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  bool checkVersion(const std::string& clientName, const int16_t edamVersionMajor, const int16_t edamVersionMinor);
  void send_checkVersion(const std::string& clientName, const int16_t edamVersionMajor, const int16_t edamVersionMinor);
  bool recv_checkVersion();
  void getBootstrapInfo(BootstrapInfo& _return, const std::string& locale);
  void send_getBootstrapInfo(const std::string& locale);
  void recv_getBootstrapInfo(BootstrapInfo& _return);
  void authenticateLongSession(AuthenticationResult& _return, const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const std::string& deviceIdentifier, const std::string& deviceDescription, const bool supportsTwoFactor);
  void send_authenticateLongSession(const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const std::string& deviceIdentifier, const std::string& deviceDescription, const bool supportsTwoFactor);
  void recv_authenticateLongSession(AuthenticationResult& _return);
  void completeTwoFactorAuthentication(AuthenticationResult& _return, const std::string& authenticationToken, const std::string& oneTimeCode, const std::string& deviceIdentifier, const std::string& deviceDescription);
  void send_completeTwoFactorAuthentication(const std::string& authenticationToken, const std::string& oneTimeCode, const std::string& deviceIdentifier, const std::string& deviceDescription);
  void recv_completeTwoFactorAuthentication(AuthenticationResult& _return);
  void revokeLongSession(const std::string& authenticationToken);
  void send_revokeLongSession(const std::string& authenticationToken);
  void recv_revokeLongSession();
  void authenticateToBusiness(AuthenticationResult& _return, const std::string& authenticationToken);
  void send_authenticateToBusiness(const std::string& authenticationToken);
  void recv_authenticateToBusiness(AuthenticationResult& _return);
  void getUser( ::evernote::edam::User& _return, const std::string& authenticationToken);
  void send_getUser(const std::string& authenticationToken);
  void recv_getUser( ::evernote::edam::User& _return);
  void getPublicUserInfo(PublicUserInfo& _return, const std::string& username);
  void send_getPublicUserInfo(const std::string& username);
  void recv_getPublicUserInfo(PublicUserInfo& _return);
  void getUserUrls(UserUrls& _return, const std::string& authenticationToken);
  void send_getUserUrls(const std::string& authenticationToken);
  void recv_getUserUrls(UserUrls& _return);
  void inviteToBusiness(const std::string& authenticationToken, const std::string& emailAddress);
  void send_inviteToBusiness(const std::string& authenticationToken, const std::string& emailAddress);
  void recv_inviteToBusiness();
  void removeFromBusiness(const std::string& authenticationToken, const std::string& emailAddress);
  void send_removeFromBusiness(const std::string& authenticationToken, const std::string& emailAddress);
  void recv_removeFromBusiness();
  void updateBusinessUserIdentifier(const std::string& authenticationToken, const std::string& oldEmailAddress, const std::string& newEmailAddress);
  void send_updateBusinessUserIdentifier(const std::string& authenticationToken, const std::string& oldEmailAddress, const std::string& newEmailAddress);
  void recv_updateBusinessUserIdentifier();
  void listBusinessUsers(std::vector< ::evernote::edam::UserProfile> & _return, const std::string& authenticationToken);
  void send_listBusinessUsers(const std::string& authenticationToken);
  void recv_listBusinessUsers(std::vector< ::evernote::edam::UserProfile> & _return);
  void listBusinessInvitations(std::vector< ::evernote::edam::BusinessInvitation> & _return, const std::string& authenticationToken, const bool includeRequestedInvitations);
  void send_listBusinessInvitations(const std::string& authenticationToken, const bool includeRequestedInvitations);
  void recv_listBusinessInvitations(std::vector< ::evernote::edam::BusinessInvitation> & _return);
  void getAccountLimits( ::evernote::edam::AccountLimits& _return, const  ::evernote::edam::ServiceLevel::type serviceLevel);
  void send_getAccountLimits(const  ::evernote::edam::ServiceLevel::type serviceLevel);
  void recv_getAccountLimits( ::evernote::edam::AccountLimits& _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class UserStoreProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<UserStoreIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (UserStoreProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_checkVersion(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getBootstrapInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_authenticateLongSession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_completeTwoFactorAuthentication(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_revokeLongSession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_authenticateToBusiness(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getUser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getPublicUserInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getUserUrls(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_inviteToBusiness(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeFromBusiness(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateBusinessUserIdentifier(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listBusinessUsers(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listBusinessInvitations(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getAccountLimits(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  UserStoreProcessor(boost::shared_ptr<UserStoreIf> iface) :
    iface_(iface) {
    processMap_["checkVersion"] = &UserStoreProcessor::process_checkVersion;
    processMap_["getBootstrapInfo"] = &UserStoreProcessor::process_getBootstrapInfo;
    processMap_["authenticateLongSession"] = &UserStoreProcessor::process_authenticateLongSession;
    processMap_["completeTwoFactorAuthentication"] = &UserStoreProcessor::process_completeTwoFactorAuthentication;
    processMap_["revokeLongSession"] = &UserStoreProcessor::process_revokeLongSession;
    processMap_["authenticateToBusiness"] = &UserStoreProcessor::process_authenticateToBusiness;
    processMap_["getUser"] = &UserStoreProcessor::process_getUser;
    processMap_["getPublicUserInfo"] = &UserStoreProcessor::process_getPublicUserInfo;
    processMap_["getUserUrls"] = &UserStoreProcessor::process_getUserUrls;
    processMap_["inviteToBusiness"] = &UserStoreProcessor::process_inviteToBusiness;
    processMap_["removeFromBusiness"] = &UserStoreProcessor::process_removeFromBusiness;
    processMap_["updateBusinessUserIdentifier"] = &UserStoreProcessor::process_updateBusinessUserIdentifier;
    processMap_["listBusinessUsers"] = &UserStoreProcessor::process_listBusinessUsers;
    processMap_["listBusinessInvitations"] = &UserStoreProcessor::process_listBusinessInvitations;
    processMap_["getAccountLimits"] = &UserStoreProcessor::process_getAccountLimits;
  }

  virtual ~UserStoreProcessor() {}
};

class UserStoreProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  UserStoreProcessorFactory(const ::boost::shared_ptr< UserStoreIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< UserStoreIfFactory > handlerFactory_;
};

class UserStoreMultiface : virtual public UserStoreIf {
 public:
  UserStoreMultiface(std::vector<boost::shared_ptr<UserStoreIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~UserStoreMultiface() {}
 protected:
  std::vector<boost::shared_ptr<UserStoreIf> > ifaces_;
  UserStoreMultiface() {}
  void add(boost::shared_ptr<UserStoreIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  bool checkVersion(const std::string& clientName, const int16_t edamVersionMajor, const int16_t edamVersionMinor) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->checkVersion(clientName, edamVersionMajor, edamVersionMinor);
    }
    return ifaces_[i]->checkVersion(clientName, edamVersionMajor, edamVersionMinor);
  }

  void getBootstrapInfo(BootstrapInfo& _return, const std::string& locale) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getBootstrapInfo(_return, locale);
    }
    ifaces_[i]->getBootstrapInfo(_return, locale);
    return;
  }

  void authenticateLongSession(AuthenticationResult& _return, const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const std::string& deviceIdentifier, const std::string& deviceDescription, const bool supportsTwoFactor) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->authenticateLongSession(_return, username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor);
    }
    ifaces_[i]->authenticateLongSession(_return, username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor);
    return;
  }

  void completeTwoFactorAuthentication(AuthenticationResult& _return, const std::string& authenticationToken, const std::string& oneTimeCode, const std::string& deviceIdentifier, const std::string& deviceDescription) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->completeTwoFactorAuthentication(_return, authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription);
    }
    ifaces_[i]->completeTwoFactorAuthentication(_return, authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription);
    return;
  }

  void revokeLongSession(const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->revokeLongSession(authenticationToken);
    }
    ifaces_[i]->revokeLongSession(authenticationToken);
  }

  void authenticateToBusiness(AuthenticationResult& _return, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->authenticateToBusiness(_return, authenticationToken);
    }
    ifaces_[i]->authenticateToBusiness(_return, authenticationToken);
    return;
  }

  void getUser( ::evernote::edam::User& _return, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getUser(_return, authenticationToken);
    }
    ifaces_[i]->getUser(_return, authenticationToken);
    return;
  }

  void getPublicUserInfo(PublicUserInfo& _return, const std::string& username) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getPublicUserInfo(_return, username);
    }
    ifaces_[i]->getPublicUserInfo(_return, username);
    return;
  }

  void getUserUrls(UserUrls& _return, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getUserUrls(_return, authenticationToken);
    }
    ifaces_[i]->getUserUrls(_return, authenticationToken);
    return;
  }

  void inviteToBusiness(const std::string& authenticationToken, const std::string& emailAddress) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->inviteToBusiness(authenticationToken, emailAddress);
    }
    ifaces_[i]->inviteToBusiness(authenticationToken, emailAddress);
  }

  void removeFromBusiness(const std::string& authenticationToken, const std::string& emailAddress) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeFromBusiness(authenticationToken, emailAddress);
    }
    ifaces_[i]->removeFromBusiness(authenticationToken, emailAddress);
  }

  void updateBusinessUserIdentifier(const std::string& authenticationToken, const std::string& oldEmailAddress, const std::string& newEmailAddress) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateBusinessUserIdentifier(authenticationToken, oldEmailAddress, newEmailAddress);
    }
    ifaces_[i]->updateBusinessUserIdentifier(authenticationToken, oldEmailAddress, newEmailAddress);
  }

  void listBusinessUsers(std::vector< ::evernote::edam::UserProfile> & _return, const std::string& authenticationToken) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listBusinessUsers(_return, authenticationToken);
    }
    ifaces_[i]->listBusinessUsers(_return, authenticationToken);
    return;
  }

  void listBusinessInvitations(std::vector< ::evernote::edam::BusinessInvitation> & _return, const std::string& authenticationToken, const bool includeRequestedInvitations) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listBusinessInvitations(_return, authenticationToken, includeRequestedInvitations);
    }
    ifaces_[i]->listBusinessInvitations(_return, authenticationToken, includeRequestedInvitations);
    return;
  }

  void getAccountLimits( ::evernote::edam::AccountLimits& _return, const  ::evernote::edam::ServiceLevel::type serviceLevel) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getAccountLimits(_return, serviceLevel);
    }
    ifaces_[i]->getAccountLimits(_return, serviceLevel);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class UserStoreConcurrentClient : virtual public UserStoreIf {
 public:
  UserStoreConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  UserStoreConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  bool checkVersion(const std::string& clientName, const int16_t edamVersionMajor, const int16_t edamVersionMinor);
  int32_t send_checkVersion(const std::string& clientName, const int16_t edamVersionMajor, const int16_t edamVersionMinor);
  bool recv_checkVersion(const int32_t seqid);
  void getBootstrapInfo(BootstrapInfo& _return, const std::string& locale);
  int32_t send_getBootstrapInfo(const std::string& locale);
  void recv_getBootstrapInfo(BootstrapInfo& _return, const int32_t seqid);
  void authenticateLongSession(AuthenticationResult& _return, const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const std::string& deviceIdentifier, const std::string& deviceDescription, const bool supportsTwoFactor);
  int32_t send_authenticateLongSession(const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const std::string& deviceIdentifier, const std::string& deviceDescription, const bool supportsTwoFactor);
  void recv_authenticateLongSession(AuthenticationResult& _return, const int32_t seqid);
  void completeTwoFactorAuthentication(AuthenticationResult& _return, const std::string& authenticationToken, const std::string& oneTimeCode, const std::string& deviceIdentifier, const std::string& deviceDescription);
  int32_t send_completeTwoFactorAuthentication(const std::string& authenticationToken, const std::string& oneTimeCode, const std::string& deviceIdentifier, const std::string& deviceDescription);
  void recv_completeTwoFactorAuthentication(AuthenticationResult& _return, const int32_t seqid);
  void revokeLongSession(const std::string& authenticationToken);
  int32_t send_revokeLongSession(const std::string& authenticationToken);
  void recv_revokeLongSession(const int32_t seqid);
  void authenticateToBusiness(AuthenticationResult& _return, const std::string& authenticationToken);
  int32_t send_authenticateToBusiness(const std::string& authenticationToken);
  void recv_authenticateToBusiness(AuthenticationResult& _return, const int32_t seqid);
  void getUser( ::evernote::edam::User& _return, const std::string& authenticationToken);
  int32_t send_getUser(const std::string& authenticationToken);
  void recv_getUser( ::evernote::edam::User& _return, const int32_t seqid);
  void getPublicUserInfo(PublicUserInfo& _return, const std::string& username);
  int32_t send_getPublicUserInfo(const std::string& username);
  void recv_getPublicUserInfo(PublicUserInfo& _return, const int32_t seqid);
  void getUserUrls(UserUrls& _return, const std::string& authenticationToken);
  int32_t send_getUserUrls(const std::string& authenticationToken);
  void recv_getUserUrls(UserUrls& _return, const int32_t seqid);
  void inviteToBusiness(const std::string& authenticationToken, const std::string& emailAddress);
  int32_t send_inviteToBusiness(const std::string& authenticationToken, const std::string& emailAddress);
  void recv_inviteToBusiness(const int32_t seqid);
  void removeFromBusiness(const std::string& authenticationToken, const std::string& emailAddress);
  int32_t send_removeFromBusiness(const std::string& authenticationToken, const std::string& emailAddress);
  void recv_removeFromBusiness(const int32_t seqid);
  void updateBusinessUserIdentifier(const std::string& authenticationToken, const std::string& oldEmailAddress, const std::string& newEmailAddress);
  int32_t send_updateBusinessUserIdentifier(const std::string& authenticationToken, const std::string& oldEmailAddress, const std::string& newEmailAddress);
  void recv_updateBusinessUserIdentifier(const int32_t seqid);
  void listBusinessUsers(std::vector< ::evernote::edam::UserProfile> & _return, const std::string& authenticationToken);
  int32_t send_listBusinessUsers(const std::string& authenticationToken);
  void recv_listBusinessUsers(std::vector< ::evernote::edam::UserProfile> & _return, const int32_t seqid);
  void listBusinessInvitations(std::vector< ::evernote::edam::BusinessInvitation> & _return, const std::string& authenticationToken, const bool includeRequestedInvitations);
  int32_t send_listBusinessInvitations(const std::string& authenticationToken, const bool includeRequestedInvitations);
  void recv_listBusinessInvitations(std::vector< ::evernote::edam::BusinessInvitation> & _return, const int32_t seqid);
  void getAccountLimits( ::evernote::edam::AccountLimits& _return, const  ::evernote::edam::ServiceLevel::type serviceLevel);
  int32_t send_getAccountLimits(const  ::evernote::edam::ServiceLevel::type serviceLevel);
  void recv_getAccountLimits( ::evernote::edam::AccountLimits& _return, const int32_t seqid);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _WIN32
  #pragma warning( pop )
#endif

}} // namespace

#endif
