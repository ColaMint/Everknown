/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef NoteStore_TYPES_H
#define NoteStore_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "UserStore_types.h"
#include "Types_types.h"
#include "Errors_types.h"
#include "Limits_types.h"


namespace evernote { namespace edam {

struct ShareRelationshipPrivilegeLevel {
  enum type {
    READ_NOTEBOOK = 0,
    READ_NOTEBOOK_PLUS_ACTIVITY = 10,
    MODIFY_NOTEBOOK_PLUS_ACTIVITY = 20,
    FULL_ACCESS = 30
  };
};

extern const std::map<int, const char*> _ShareRelationshipPrivilegeLevel_VALUES_TO_NAMES;

class SyncState;

class SyncChunk;

class SyncChunkFilter;

class NoteFilter;

class NoteList;

class NoteMetadata;

class NotesMetadataList;

class NotesMetadataResultSpec;

class NoteCollectionCounts;

class NoteResultSpec;

class NoteEmailParameters;

class NoteVersionId;

class RelatedQuery;

class RelatedResult;

class RelatedResultSpec;

class UpdateNoteIfUsnMatchesResult;

class ShareRelationshipRestrictions;

class InvitationShareRelationship;

class MemberShareRelationship;

class ShareRelationships;

class ManageNotebookSharesParameters;

class ManageNotebookSharesError;

class ManageNotebookSharesResult;

class SharedNoteTemplate;

class NotebookShareTemplate;

class CreateOrUpdateNotebookSharesResult;

class NoteShareRelationshipRestrictions;

class NoteMemberShareRelationship;

class NoteInvitationShareRelationship;

class NoteShareRelationships;

class ManageNoteSharesParameters;

class ManageNoteSharesError;

class ManageNoteSharesResult;

typedef struct _SyncState__isset {
  _SyncState__isset() : uploaded(false), userLastUpdated(false), userMaxMessageEventId(false) {}
  bool uploaded :1;
  bool userLastUpdated :1;
  bool userMaxMessageEventId :1;
} _SyncState__isset;

class SyncState {
 public:

  SyncState(const SyncState&);
  SyncState& operator=(const SyncState&);
  SyncState() : currentTime(0), fullSyncBefore(0), updateCount(0), uploaded(0), userLastUpdated(0), userMaxMessageEventId(0) {
  }

  virtual ~SyncState() throw();
   ::evernote::edam::Timestamp currentTime;
   ::evernote::edam::Timestamp fullSyncBefore;
  int32_t updateCount;
  int64_t uploaded;
   ::evernote::edam::Timestamp userLastUpdated;
   ::evernote::edam::MessageEventID userMaxMessageEventId;

  _SyncState__isset __isset;

  void __set_currentTime(const  ::evernote::edam::Timestamp val);

  void __set_fullSyncBefore(const  ::evernote::edam::Timestamp val);

  void __set_updateCount(const int32_t val);

  void __set_uploaded(const int64_t val);

  void __set_userLastUpdated(const  ::evernote::edam::Timestamp val);

  void __set_userMaxMessageEventId(const  ::evernote::edam::MessageEventID val);

  bool operator == (const SyncState & rhs) const
  {
    if (!(currentTime == rhs.currentTime))
      return false;
    if (!(fullSyncBefore == rhs.fullSyncBefore))
      return false;
    if (!(updateCount == rhs.updateCount))
      return false;
    if (__isset.uploaded != rhs.__isset.uploaded)
      return false;
    else if (__isset.uploaded && !(uploaded == rhs.uploaded))
      return false;
    if (__isset.userLastUpdated != rhs.__isset.userLastUpdated)
      return false;
    else if (__isset.userLastUpdated && !(userLastUpdated == rhs.userLastUpdated))
      return false;
    if (__isset.userMaxMessageEventId != rhs.__isset.userMaxMessageEventId)
      return false;
    else if (__isset.userMaxMessageEventId && !(userMaxMessageEventId == rhs.userMaxMessageEventId))
      return false;
    return true;
  }
  bool operator != (const SyncState &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SyncState & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SyncState &a, SyncState &b);

inline std::ostream& operator<<(std::ostream& out, const SyncState& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SyncChunk__isset {
  _SyncChunk__isset() : chunkHighUSN(false), notes(false), notebooks(false), tags(false), searches(false), resources(false), expungedNotes(false), expungedNotebooks(false), expungedTags(false), expungedSearches(false), linkedNotebooks(false), expungedLinkedNotebooks(false) {}
  bool chunkHighUSN :1;
  bool notes :1;
  bool notebooks :1;
  bool tags :1;
  bool searches :1;
  bool resources :1;
  bool expungedNotes :1;
  bool expungedNotebooks :1;
  bool expungedTags :1;
  bool expungedSearches :1;
  bool linkedNotebooks :1;
  bool expungedLinkedNotebooks :1;
} _SyncChunk__isset;

class SyncChunk {
 public:

  SyncChunk(const SyncChunk&);
  SyncChunk& operator=(const SyncChunk&);
  SyncChunk() : currentTime(0), chunkHighUSN(0), updateCount(0) {
  }

  virtual ~SyncChunk() throw();
   ::evernote::edam::Timestamp currentTime;
  int32_t chunkHighUSN;
  int32_t updateCount;
  std::vector< ::evernote::edam::Note>  notes;
  std::vector< ::evernote::edam::Notebook>  notebooks;
  std::vector< ::evernote::edam::Tag>  tags;
  std::vector< ::evernote::edam::SavedSearch>  searches;
  std::vector< ::evernote::edam::Resource>  resources;
  std::vector< ::evernote::edam::Guid>  expungedNotes;
  std::vector< ::evernote::edam::Guid>  expungedNotebooks;
  std::vector< ::evernote::edam::Guid>  expungedTags;
  std::vector< ::evernote::edam::Guid>  expungedSearches;
  std::vector< ::evernote::edam::LinkedNotebook>  linkedNotebooks;
  std::vector< ::evernote::edam::Guid>  expungedLinkedNotebooks;

  _SyncChunk__isset __isset;

  void __set_currentTime(const  ::evernote::edam::Timestamp val);

  void __set_chunkHighUSN(const int32_t val);

  void __set_updateCount(const int32_t val);

  void __set_notes(const std::vector< ::evernote::edam::Note> & val);

  void __set_notebooks(const std::vector< ::evernote::edam::Notebook> & val);

  void __set_tags(const std::vector< ::evernote::edam::Tag> & val);

  void __set_searches(const std::vector< ::evernote::edam::SavedSearch> & val);

  void __set_resources(const std::vector< ::evernote::edam::Resource> & val);

  void __set_expungedNotes(const std::vector< ::evernote::edam::Guid> & val);

  void __set_expungedNotebooks(const std::vector< ::evernote::edam::Guid> & val);

  void __set_expungedTags(const std::vector< ::evernote::edam::Guid> & val);

  void __set_expungedSearches(const std::vector< ::evernote::edam::Guid> & val);

  void __set_linkedNotebooks(const std::vector< ::evernote::edam::LinkedNotebook> & val);

  void __set_expungedLinkedNotebooks(const std::vector< ::evernote::edam::Guid> & val);

  bool operator == (const SyncChunk & rhs) const
  {
    if (!(currentTime == rhs.currentTime))
      return false;
    if (__isset.chunkHighUSN != rhs.__isset.chunkHighUSN)
      return false;
    else if (__isset.chunkHighUSN && !(chunkHighUSN == rhs.chunkHighUSN))
      return false;
    if (!(updateCount == rhs.updateCount))
      return false;
    if (__isset.notes != rhs.__isset.notes)
      return false;
    else if (__isset.notes && !(notes == rhs.notes))
      return false;
    if (__isset.notebooks != rhs.__isset.notebooks)
      return false;
    else if (__isset.notebooks && !(notebooks == rhs.notebooks))
      return false;
    if (__isset.tags != rhs.__isset.tags)
      return false;
    else if (__isset.tags && !(tags == rhs.tags))
      return false;
    if (__isset.searches != rhs.__isset.searches)
      return false;
    else if (__isset.searches && !(searches == rhs.searches))
      return false;
    if (__isset.resources != rhs.__isset.resources)
      return false;
    else if (__isset.resources && !(resources == rhs.resources))
      return false;
    if (__isset.expungedNotes != rhs.__isset.expungedNotes)
      return false;
    else if (__isset.expungedNotes && !(expungedNotes == rhs.expungedNotes))
      return false;
    if (__isset.expungedNotebooks != rhs.__isset.expungedNotebooks)
      return false;
    else if (__isset.expungedNotebooks && !(expungedNotebooks == rhs.expungedNotebooks))
      return false;
    if (__isset.expungedTags != rhs.__isset.expungedTags)
      return false;
    else if (__isset.expungedTags && !(expungedTags == rhs.expungedTags))
      return false;
    if (__isset.expungedSearches != rhs.__isset.expungedSearches)
      return false;
    else if (__isset.expungedSearches && !(expungedSearches == rhs.expungedSearches))
      return false;
    if (__isset.linkedNotebooks != rhs.__isset.linkedNotebooks)
      return false;
    else if (__isset.linkedNotebooks && !(linkedNotebooks == rhs.linkedNotebooks))
      return false;
    if (__isset.expungedLinkedNotebooks != rhs.__isset.expungedLinkedNotebooks)
      return false;
    else if (__isset.expungedLinkedNotebooks && !(expungedLinkedNotebooks == rhs.expungedLinkedNotebooks))
      return false;
    return true;
  }
  bool operator != (const SyncChunk &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SyncChunk & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SyncChunk &a, SyncChunk &b);

inline std::ostream& operator<<(std::ostream& out, const SyncChunk& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SyncChunkFilter__isset {
  _SyncChunkFilter__isset() : includeNotes(false), includeNoteResources(false), includeNoteAttributes(false), includeNotebooks(false), includeTags(false), includeSearches(false), includeResources(false), includeLinkedNotebooks(false), includeExpunged(false), includeNoteApplicationDataFullMap(false), includeResourceApplicationDataFullMap(false), includeNoteResourceApplicationDataFullMap(false), includeSharedNotes(false), omitSharedNotebooks(false), requireNoteContentClass(false), notebookGuids(false) {}
  bool includeNotes :1;
  bool includeNoteResources :1;
  bool includeNoteAttributes :1;
  bool includeNotebooks :1;
  bool includeTags :1;
  bool includeSearches :1;
  bool includeResources :1;
  bool includeLinkedNotebooks :1;
  bool includeExpunged :1;
  bool includeNoteApplicationDataFullMap :1;
  bool includeResourceApplicationDataFullMap :1;
  bool includeNoteResourceApplicationDataFullMap :1;
  bool includeSharedNotes :1;
  bool omitSharedNotebooks :1;
  bool requireNoteContentClass :1;
  bool notebookGuids :1;
} _SyncChunkFilter__isset;

class SyncChunkFilter {
 public:

  SyncChunkFilter(const SyncChunkFilter&);
  SyncChunkFilter& operator=(const SyncChunkFilter&);
  SyncChunkFilter() : includeNotes(0), includeNoteResources(0), includeNoteAttributes(0), includeNotebooks(0), includeTags(0), includeSearches(0), includeResources(0), includeLinkedNotebooks(0), includeExpunged(0), includeNoteApplicationDataFullMap(0), includeResourceApplicationDataFullMap(0), includeNoteResourceApplicationDataFullMap(0), includeSharedNotes(0), omitSharedNotebooks(0), requireNoteContentClass() {
  }

  virtual ~SyncChunkFilter() throw();
  bool includeNotes;
  bool includeNoteResources;
  bool includeNoteAttributes;
  bool includeNotebooks;
  bool includeTags;
  bool includeSearches;
  bool includeResources;
  bool includeLinkedNotebooks;
  bool includeExpunged;
  bool includeNoteApplicationDataFullMap;
  bool includeResourceApplicationDataFullMap;
  bool includeNoteResourceApplicationDataFullMap;
  bool includeSharedNotes;
  bool omitSharedNotebooks;
  std::string requireNoteContentClass;
  std::set<std::string>  notebookGuids;

  _SyncChunkFilter__isset __isset;

  void __set_includeNotes(const bool val);

  void __set_includeNoteResources(const bool val);

  void __set_includeNoteAttributes(const bool val);

  void __set_includeNotebooks(const bool val);

  void __set_includeTags(const bool val);

  void __set_includeSearches(const bool val);

  void __set_includeResources(const bool val);

  void __set_includeLinkedNotebooks(const bool val);

  void __set_includeExpunged(const bool val);

  void __set_includeNoteApplicationDataFullMap(const bool val);

  void __set_includeResourceApplicationDataFullMap(const bool val);

  void __set_includeNoteResourceApplicationDataFullMap(const bool val);

  void __set_includeSharedNotes(const bool val);

  void __set_omitSharedNotebooks(const bool val);

  void __set_requireNoteContentClass(const std::string& val);

  void __set_notebookGuids(const std::set<std::string> & val);

  bool operator == (const SyncChunkFilter & rhs) const
  {
    if (__isset.includeNotes != rhs.__isset.includeNotes)
      return false;
    else if (__isset.includeNotes && !(includeNotes == rhs.includeNotes))
      return false;
    if (__isset.includeNoteResources != rhs.__isset.includeNoteResources)
      return false;
    else if (__isset.includeNoteResources && !(includeNoteResources == rhs.includeNoteResources))
      return false;
    if (__isset.includeNoteAttributes != rhs.__isset.includeNoteAttributes)
      return false;
    else if (__isset.includeNoteAttributes && !(includeNoteAttributes == rhs.includeNoteAttributes))
      return false;
    if (__isset.includeNotebooks != rhs.__isset.includeNotebooks)
      return false;
    else if (__isset.includeNotebooks && !(includeNotebooks == rhs.includeNotebooks))
      return false;
    if (__isset.includeTags != rhs.__isset.includeTags)
      return false;
    else if (__isset.includeTags && !(includeTags == rhs.includeTags))
      return false;
    if (__isset.includeSearches != rhs.__isset.includeSearches)
      return false;
    else if (__isset.includeSearches && !(includeSearches == rhs.includeSearches))
      return false;
    if (__isset.includeResources != rhs.__isset.includeResources)
      return false;
    else if (__isset.includeResources && !(includeResources == rhs.includeResources))
      return false;
    if (__isset.includeLinkedNotebooks != rhs.__isset.includeLinkedNotebooks)
      return false;
    else if (__isset.includeLinkedNotebooks && !(includeLinkedNotebooks == rhs.includeLinkedNotebooks))
      return false;
    if (__isset.includeExpunged != rhs.__isset.includeExpunged)
      return false;
    else if (__isset.includeExpunged && !(includeExpunged == rhs.includeExpunged))
      return false;
    if (__isset.includeNoteApplicationDataFullMap != rhs.__isset.includeNoteApplicationDataFullMap)
      return false;
    else if (__isset.includeNoteApplicationDataFullMap && !(includeNoteApplicationDataFullMap == rhs.includeNoteApplicationDataFullMap))
      return false;
    if (__isset.includeResourceApplicationDataFullMap != rhs.__isset.includeResourceApplicationDataFullMap)
      return false;
    else if (__isset.includeResourceApplicationDataFullMap && !(includeResourceApplicationDataFullMap == rhs.includeResourceApplicationDataFullMap))
      return false;
    if (__isset.includeNoteResourceApplicationDataFullMap != rhs.__isset.includeNoteResourceApplicationDataFullMap)
      return false;
    else if (__isset.includeNoteResourceApplicationDataFullMap && !(includeNoteResourceApplicationDataFullMap == rhs.includeNoteResourceApplicationDataFullMap))
      return false;
    if (__isset.includeSharedNotes != rhs.__isset.includeSharedNotes)
      return false;
    else if (__isset.includeSharedNotes && !(includeSharedNotes == rhs.includeSharedNotes))
      return false;
    if (__isset.omitSharedNotebooks != rhs.__isset.omitSharedNotebooks)
      return false;
    else if (__isset.omitSharedNotebooks && !(omitSharedNotebooks == rhs.omitSharedNotebooks))
      return false;
    if (__isset.requireNoteContentClass != rhs.__isset.requireNoteContentClass)
      return false;
    else if (__isset.requireNoteContentClass && !(requireNoteContentClass == rhs.requireNoteContentClass))
      return false;
    if (__isset.notebookGuids != rhs.__isset.notebookGuids)
      return false;
    else if (__isset.notebookGuids && !(notebookGuids == rhs.notebookGuids))
      return false;
    return true;
  }
  bool operator != (const SyncChunkFilter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SyncChunkFilter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SyncChunkFilter &a, SyncChunkFilter &b);

inline std::ostream& operator<<(std::ostream& out, const SyncChunkFilter& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoteFilter__isset {
  _NoteFilter__isset() : order(false), ascending(false), words(false), notebookGuid(false), tagGuids(false), timeZone(false), inactive(false), emphasized(false), includeAllReadableNotebooks(false), context(false) {}
  bool order :1;
  bool ascending :1;
  bool words :1;
  bool notebookGuid :1;
  bool tagGuids :1;
  bool timeZone :1;
  bool inactive :1;
  bool emphasized :1;
  bool includeAllReadableNotebooks :1;
  bool context :1;
} _NoteFilter__isset;

class NoteFilter {
 public:

  NoteFilter(const NoteFilter&);
  NoteFilter& operator=(const NoteFilter&);
  NoteFilter() : order(0), ascending(0), words(), notebookGuid(), timeZone(), inactive(0), emphasized(), includeAllReadableNotebooks(0), context() {
  }

  virtual ~NoteFilter() throw();
  int32_t order;
  bool ascending;
  std::string words;
   ::evernote::edam::Guid notebookGuid;
  std::vector< ::evernote::edam::Guid>  tagGuids;
  std::string timeZone;
  bool inactive;
  std::string emphasized;
  bool includeAllReadableNotebooks;
  std::string context;

  _NoteFilter__isset __isset;

  void __set_order(const int32_t val);

  void __set_ascending(const bool val);

  void __set_words(const std::string& val);

  void __set_notebookGuid(const  ::evernote::edam::Guid& val);

  void __set_tagGuids(const std::vector< ::evernote::edam::Guid> & val);

  void __set_timeZone(const std::string& val);

  void __set_inactive(const bool val);

  void __set_emphasized(const std::string& val);

  void __set_includeAllReadableNotebooks(const bool val);

  void __set_context(const std::string& val);

  bool operator == (const NoteFilter & rhs) const
  {
    if (__isset.order != rhs.__isset.order)
      return false;
    else if (__isset.order && !(order == rhs.order))
      return false;
    if (__isset.ascending != rhs.__isset.ascending)
      return false;
    else if (__isset.ascending && !(ascending == rhs.ascending))
      return false;
    if (__isset.words != rhs.__isset.words)
      return false;
    else if (__isset.words && !(words == rhs.words))
      return false;
    if (__isset.notebookGuid != rhs.__isset.notebookGuid)
      return false;
    else if (__isset.notebookGuid && !(notebookGuid == rhs.notebookGuid))
      return false;
    if (__isset.tagGuids != rhs.__isset.tagGuids)
      return false;
    else if (__isset.tagGuids && !(tagGuids == rhs.tagGuids))
      return false;
    if (__isset.timeZone != rhs.__isset.timeZone)
      return false;
    else if (__isset.timeZone && !(timeZone == rhs.timeZone))
      return false;
    if (__isset.inactive != rhs.__isset.inactive)
      return false;
    else if (__isset.inactive && !(inactive == rhs.inactive))
      return false;
    if (__isset.emphasized != rhs.__isset.emphasized)
      return false;
    else if (__isset.emphasized && !(emphasized == rhs.emphasized))
      return false;
    if (__isset.includeAllReadableNotebooks != rhs.__isset.includeAllReadableNotebooks)
      return false;
    else if (__isset.includeAllReadableNotebooks && !(includeAllReadableNotebooks == rhs.includeAllReadableNotebooks))
      return false;
    if (__isset.context != rhs.__isset.context)
      return false;
    else if (__isset.context && !(context == rhs.context))
      return false;
    return true;
  }
  bool operator != (const NoteFilter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteFilter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NoteFilter &a, NoteFilter &b);

inline std::ostream& operator<<(std::ostream& out, const NoteFilter& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoteList__isset {
  _NoteList__isset() : stoppedWords(false), searchedWords(false), updateCount(false) {}
  bool stoppedWords :1;
  bool searchedWords :1;
  bool updateCount :1;
} _NoteList__isset;

class NoteList {
 public:

  NoteList(const NoteList&);
  NoteList& operator=(const NoteList&);
  NoteList() : startIndex(0), totalNotes(0), updateCount(0) {
  }

  virtual ~NoteList() throw();
  int32_t startIndex;
  int32_t totalNotes;
  std::vector< ::evernote::edam::Note>  notes;
  std::vector<std::string>  stoppedWords;
  std::vector<std::string>  searchedWords;
  int32_t updateCount;

  _NoteList__isset __isset;

  void __set_startIndex(const int32_t val);

  void __set_totalNotes(const int32_t val);

  void __set_notes(const std::vector< ::evernote::edam::Note> & val);

  void __set_stoppedWords(const std::vector<std::string> & val);

  void __set_searchedWords(const std::vector<std::string> & val);

  void __set_updateCount(const int32_t val);

  bool operator == (const NoteList & rhs) const
  {
    if (!(startIndex == rhs.startIndex))
      return false;
    if (!(totalNotes == rhs.totalNotes))
      return false;
    if (!(notes == rhs.notes))
      return false;
    if (__isset.stoppedWords != rhs.__isset.stoppedWords)
      return false;
    else if (__isset.stoppedWords && !(stoppedWords == rhs.stoppedWords))
      return false;
    if (__isset.searchedWords != rhs.__isset.searchedWords)
      return false;
    else if (__isset.searchedWords && !(searchedWords == rhs.searchedWords))
      return false;
    if (__isset.updateCount != rhs.__isset.updateCount)
      return false;
    else if (__isset.updateCount && !(updateCount == rhs.updateCount))
      return false;
    return true;
  }
  bool operator != (const NoteList &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteList & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NoteList &a, NoteList &b);

inline std::ostream& operator<<(std::ostream& out, const NoteList& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoteMetadata__isset {
  _NoteMetadata__isset() : title(false), contentLength(false), created(false), updated(false), deleted(false), updateSequenceNum(false), notebookGuid(false), tagGuids(false), attributes(false), largestResourceMime(false), largestResourceSize(false) {}
  bool title :1;
  bool contentLength :1;
  bool created :1;
  bool updated :1;
  bool deleted :1;
  bool updateSequenceNum :1;
  bool notebookGuid :1;
  bool tagGuids :1;
  bool attributes :1;
  bool largestResourceMime :1;
  bool largestResourceSize :1;
} _NoteMetadata__isset;

class NoteMetadata {
 public:

  NoteMetadata(const NoteMetadata&);
  NoteMetadata& operator=(const NoteMetadata&);
  NoteMetadata() : guid(), title(), contentLength(0), created(0), updated(0), deleted(0), updateSequenceNum(0), notebookGuid(), largestResourceMime(), largestResourceSize(0) {
  }

  virtual ~NoteMetadata() throw();
   ::evernote::edam::Guid guid;
  std::string title;
  int32_t contentLength;
   ::evernote::edam::Timestamp created;
   ::evernote::edam::Timestamp updated;
   ::evernote::edam::Timestamp deleted;
  int32_t updateSequenceNum;
  std::string notebookGuid;
  std::vector< ::evernote::edam::Guid>  tagGuids;
   ::evernote::edam::NoteAttributes attributes;
  std::string largestResourceMime;
  int32_t largestResourceSize;

  _NoteMetadata__isset __isset;

  void __set_guid(const  ::evernote::edam::Guid& val);

  void __set_title(const std::string& val);

  void __set_contentLength(const int32_t val);

  void __set_created(const  ::evernote::edam::Timestamp val);

  void __set_updated(const  ::evernote::edam::Timestamp val);

  void __set_deleted(const  ::evernote::edam::Timestamp val);

  void __set_updateSequenceNum(const int32_t val);

  void __set_notebookGuid(const std::string& val);

  void __set_tagGuids(const std::vector< ::evernote::edam::Guid> & val);

  void __set_attributes(const  ::evernote::edam::NoteAttributes& val);

  void __set_largestResourceMime(const std::string& val);

  void __set_largestResourceSize(const int32_t val);

  bool operator == (const NoteMetadata & rhs) const
  {
    if (!(guid == rhs.guid))
      return false;
    if (__isset.title != rhs.__isset.title)
      return false;
    else if (__isset.title && !(title == rhs.title))
      return false;
    if (__isset.contentLength != rhs.__isset.contentLength)
      return false;
    else if (__isset.contentLength && !(contentLength == rhs.contentLength))
      return false;
    if (__isset.created != rhs.__isset.created)
      return false;
    else if (__isset.created && !(created == rhs.created))
      return false;
    if (__isset.updated != rhs.__isset.updated)
      return false;
    else if (__isset.updated && !(updated == rhs.updated))
      return false;
    if (__isset.deleted != rhs.__isset.deleted)
      return false;
    else if (__isset.deleted && !(deleted == rhs.deleted))
      return false;
    if (__isset.updateSequenceNum != rhs.__isset.updateSequenceNum)
      return false;
    else if (__isset.updateSequenceNum && !(updateSequenceNum == rhs.updateSequenceNum))
      return false;
    if (__isset.notebookGuid != rhs.__isset.notebookGuid)
      return false;
    else if (__isset.notebookGuid && !(notebookGuid == rhs.notebookGuid))
      return false;
    if (__isset.tagGuids != rhs.__isset.tagGuids)
      return false;
    else if (__isset.tagGuids && !(tagGuids == rhs.tagGuids))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.largestResourceMime != rhs.__isset.largestResourceMime)
      return false;
    else if (__isset.largestResourceMime && !(largestResourceMime == rhs.largestResourceMime))
      return false;
    if (__isset.largestResourceSize != rhs.__isset.largestResourceSize)
      return false;
    else if (__isset.largestResourceSize && !(largestResourceSize == rhs.largestResourceSize))
      return false;
    return true;
  }
  bool operator != (const NoteMetadata &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteMetadata & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NoteMetadata &a, NoteMetadata &b);

inline std::ostream& operator<<(std::ostream& out, const NoteMetadata& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NotesMetadataList__isset {
  _NotesMetadataList__isset() : stoppedWords(false), searchedWords(false), updateCount(false) {}
  bool stoppedWords :1;
  bool searchedWords :1;
  bool updateCount :1;
} _NotesMetadataList__isset;

class NotesMetadataList {
 public:

  NotesMetadataList(const NotesMetadataList&);
  NotesMetadataList& operator=(const NotesMetadataList&);
  NotesMetadataList() : startIndex(0), totalNotes(0), updateCount(0) {
  }

  virtual ~NotesMetadataList() throw();
  int32_t startIndex;
  int32_t totalNotes;
  std::vector<NoteMetadata>  notes;
  std::vector<std::string>  stoppedWords;
  std::vector<std::string>  searchedWords;
  int32_t updateCount;

  _NotesMetadataList__isset __isset;

  void __set_startIndex(const int32_t val);

  void __set_totalNotes(const int32_t val);

  void __set_notes(const std::vector<NoteMetadata> & val);

  void __set_stoppedWords(const std::vector<std::string> & val);

  void __set_searchedWords(const std::vector<std::string> & val);

  void __set_updateCount(const int32_t val);

  bool operator == (const NotesMetadataList & rhs) const
  {
    if (!(startIndex == rhs.startIndex))
      return false;
    if (!(totalNotes == rhs.totalNotes))
      return false;
    if (!(notes == rhs.notes))
      return false;
    if (__isset.stoppedWords != rhs.__isset.stoppedWords)
      return false;
    else if (__isset.stoppedWords && !(stoppedWords == rhs.stoppedWords))
      return false;
    if (__isset.searchedWords != rhs.__isset.searchedWords)
      return false;
    else if (__isset.searchedWords && !(searchedWords == rhs.searchedWords))
      return false;
    if (__isset.updateCount != rhs.__isset.updateCount)
      return false;
    else if (__isset.updateCount && !(updateCount == rhs.updateCount))
      return false;
    return true;
  }
  bool operator != (const NotesMetadataList &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotesMetadataList & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotesMetadataList &a, NotesMetadataList &b);

inline std::ostream& operator<<(std::ostream& out, const NotesMetadataList& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NotesMetadataResultSpec__isset {
  _NotesMetadataResultSpec__isset() : includeTitle(false), includeContentLength(false), includeCreated(false), includeUpdated(false), includeDeleted(false), includeUpdateSequenceNum(false), includeNotebookGuid(false), includeTagGuids(false), includeAttributes(false), includeLargestResourceMime(false), includeLargestResourceSize(false) {}
  bool includeTitle :1;
  bool includeContentLength :1;
  bool includeCreated :1;
  bool includeUpdated :1;
  bool includeDeleted :1;
  bool includeUpdateSequenceNum :1;
  bool includeNotebookGuid :1;
  bool includeTagGuids :1;
  bool includeAttributes :1;
  bool includeLargestResourceMime :1;
  bool includeLargestResourceSize :1;
} _NotesMetadataResultSpec__isset;

class NotesMetadataResultSpec {
 public:

  NotesMetadataResultSpec(const NotesMetadataResultSpec&);
  NotesMetadataResultSpec& operator=(const NotesMetadataResultSpec&);
  NotesMetadataResultSpec() : includeTitle(0), includeContentLength(0), includeCreated(0), includeUpdated(0), includeDeleted(0), includeUpdateSequenceNum(0), includeNotebookGuid(0), includeTagGuids(0), includeAttributes(0), includeLargestResourceMime(0), includeLargestResourceSize(0) {
  }

  virtual ~NotesMetadataResultSpec() throw();
  bool includeTitle;
  bool includeContentLength;
  bool includeCreated;
  bool includeUpdated;
  bool includeDeleted;
  bool includeUpdateSequenceNum;
  bool includeNotebookGuid;
  bool includeTagGuids;
  bool includeAttributes;
  bool includeLargestResourceMime;
  bool includeLargestResourceSize;

  _NotesMetadataResultSpec__isset __isset;

  void __set_includeTitle(const bool val);

  void __set_includeContentLength(const bool val);

  void __set_includeCreated(const bool val);

  void __set_includeUpdated(const bool val);

  void __set_includeDeleted(const bool val);

  void __set_includeUpdateSequenceNum(const bool val);

  void __set_includeNotebookGuid(const bool val);

  void __set_includeTagGuids(const bool val);

  void __set_includeAttributes(const bool val);

  void __set_includeLargestResourceMime(const bool val);

  void __set_includeLargestResourceSize(const bool val);

  bool operator == (const NotesMetadataResultSpec & rhs) const
  {
    if (__isset.includeTitle != rhs.__isset.includeTitle)
      return false;
    else if (__isset.includeTitle && !(includeTitle == rhs.includeTitle))
      return false;
    if (__isset.includeContentLength != rhs.__isset.includeContentLength)
      return false;
    else if (__isset.includeContentLength && !(includeContentLength == rhs.includeContentLength))
      return false;
    if (__isset.includeCreated != rhs.__isset.includeCreated)
      return false;
    else if (__isset.includeCreated && !(includeCreated == rhs.includeCreated))
      return false;
    if (__isset.includeUpdated != rhs.__isset.includeUpdated)
      return false;
    else if (__isset.includeUpdated && !(includeUpdated == rhs.includeUpdated))
      return false;
    if (__isset.includeDeleted != rhs.__isset.includeDeleted)
      return false;
    else if (__isset.includeDeleted && !(includeDeleted == rhs.includeDeleted))
      return false;
    if (__isset.includeUpdateSequenceNum != rhs.__isset.includeUpdateSequenceNum)
      return false;
    else if (__isset.includeUpdateSequenceNum && !(includeUpdateSequenceNum == rhs.includeUpdateSequenceNum))
      return false;
    if (__isset.includeNotebookGuid != rhs.__isset.includeNotebookGuid)
      return false;
    else if (__isset.includeNotebookGuid && !(includeNotebookGuid == rhs.includeNotebookGuid))
      return false;
    if (__isset.includeTagGuids != rhs.__isset.includeTagGuids)
      return false;
    else if (__isset.includeTagGuids && !(includeTagGuids == rhs.includeTagGuids))
      return false;
    if (__isset.includeAttributes != rhs.__isset.includeAttributes)
      return false;
    else if (__isset.includeAttributes && !(includeAttributes == rhs.includeAttributes))
      return false;
    if (__isset.includeLargestResourceMime != rhs.__isset.includeLargestResourceMime)
      return false;
    else if (__isset.includeLargestResourceMime && !(includeLargestResourceMime == rhs.includeLargestResourceMime))
      return false;
    if (__isset.includeLargestResourceSize != rhs.__isset.includeLargestResourceSize)
      return false;
    else if (__isset.includeLargestResourceSize && !(includeLargestResourceSize == rhs.includeLargestResourceSize))
      return false;
    return true;
  }
  bool operator != (const NotesMetadataResultSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotesMetadataResultSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotesMetadataResultSpec &a, NotesMetadataResultSpec &b);

inline std::ostream& operator<<(std::ostream& out, const NotesMetadataResultSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoteCollectionCounts__isset {
  _NoteCollectionCounts__isset() : notebookCounts(false), tagCounts(false), trashCount(false) {}
  bool notebookCounts :1;
  bool tagCounts :1;
  bool trashCount :1;
} _NoteCollectionCounts__isset;

class NoteCollectionCounts {
 public:

  NoteCollectionCounts(const NoteCollectionCounts&);
  NoteCollectionCounts& operator=(const NoteCollectionCounts&);
  NoteCollectionCounts() : trashCount(0) {
  }

  virtual ~NoteCollectionCounts() throw();
  std::map< ::evernote::edam::Guid, int32_t>  notebookCounts;
  std::map< ::evernote::edam::Guid, int32_t>  tagCounts;
  int32_t trashCount;

  _NoteCollectionCounts__isset __isset;

  void __set_notebookCounts(const std::map< ::evernote::edam::Guid, int32_t> & val);

  void __set_tagCounts(const std::map< ::evernote::edam::Guid, int32_t> & val);

  void __set_trashCount(const int32_t val);

  bool operator == (const NoteCollectionCounts & rhs) const
  {
    if (__isset.notebookCounts != rhs.__isset.notebookCounts)
      return false;
    else if (__isset.notebookCounts && !(notebookCounts == rhs.notebookCounts))
      return false;
    if (__isset.tagCounts != rhs.__isset.tagCounts)
      return false;
    else if (__isset.tagCounts && !(tagCounts == rhs.tagCounts))
      return false;
    if (__isset.trashCount != rhs.__isset.trashCount)
      return false;
    else if (__isset.trashCount && !(trashCount == rhs.trashCount))
      return false;
    return true;
  }
  bool operator != (const NoteCollectionCounts &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteCollectionCounts & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NoteCollectionCounts &a, NoteCollectionCounts &b);

inline std::ostream& operator<<(std::ostream& out, const NoteCollectionCounts& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoteResultSpec__isset {
  _NoteResultSpec__isset() : includeContent(false), includeResourcesData(false), includeResourcesRecognition(false), includeResourcesAlternateData(false), includeSharedNotes(false), includeNoteAppDataValues(false), includeResourceAppDataValues(false), includeAccountLimits(false) {}
  bool includeContent :1;
  bool includeResourcesData :1;
  bool includeResourcesRecognition :1;
  bool includeResourcesAlternateData :1;
  bool includeSharedNotes :1;
  bool includeNoteAppDataValues :1;
  bool includeResourceAppDataValues :1;
  bool includeAccountLimits :1;
} _NoteResultSpec__isset;

class NoteResultSpec {
 public:

  NoteResultSpec(const NoteResultSpec&);
  NoteResultSpec& operator=(const NoteResultSpec&);
  NoteResultSpec() : includeContent(0), includeResourcesData(0), includeResourcesRecognition(0), includeResourcesAlternateData(0), includeSharedNotes(0), includeNoteAppDataValues(0), includeResourceAppDataValues(0), includeAccountLimits(0) {
  }

  virtual ~NoteResultSpec() throw();
  bool includeContent;
  bool includeResourcesData;
  bool includeResourcesRecognition;
  bool includeResourcesAlternateData;
  bool includeSharedNotes;
  bool includeNoteAppDataValues;
  bool includeResourceAppDataValues;
  bool includeAccountLimits;

  _NoteResultSpec__isset __isset;

  void __set_includeContent(const bool val);

  void __set_includeResourcesData(const bool val);

  void __set_includeResourcesRecognition(const bool val);

  void __set_includeResourcesAlternateData(const bool val);

  void __set_includeSharedNotes(const bool val);

  void __set_includeNoteAppDataValues(const bool val);

  void __set_includeResourceAppDataValues(const bool val);

  void __set_includeAccountLimits(const bool val);

  bool operator == (const NoteResultSpec & rhs) const
  {
    if (__isset.includeContent != rhs.__isset.includeContent)
      return false;
    else if (__isset.includeContent && !(includeContent == rhs.includeContent))
      return false;
    if (__isset.includeResourcesData != rhs.__isset.includeResourcesData)
      return false;
    else if (__isset.includeResourcesData && !(includeResourcesData == rhs.includeResourcesData))
      return false;
    if (__isset.includeResourcesRecognition != rhs.__isset.includeResourcesRecognition)
      return false;
    else if (__isset.includeResourcesRecognition && !(includeResourcesRecognition == rhs.includeResourcesRecognition))
      return false;
    if (__isset.includeResourcesAlternateData != rhs.__isset.includeResourcesAlternateData)
      return false;
    else if (__isset.includeResourcesAlternateData && !(includeResourcesAlternateData == rhs.includeResourcesAlternateData))
      return false;
    if (__isset.includeSharedNotes != rhs.__isset.includeSharedNotes)
      return false;
    else if (__isset.includeSharedNotes && !(includeSharedNotes == rhs.includeSharedNotes))
      return false;
    if (__isset.includeNoteAppDataValues != rhs.__isset.includeNoteAppDataValues)
      return false;
    else if (__isset.includeNoteAppDataValues && !(includeNoteAppDataValues == rhs.includeNoteAppDataValues))
      return false;
    if (__isset.includeResourceAppDataValues != rhs.__isset.includeResourceAppDataValues)
      return false;
    else if (__isset.includeResourceAppDataValues && !(includeResourceAppDataValues == rhs.includeResourceAppDataValues))
      return false;
    if (__isset.includeAccountLimits != rhs.__isset.includeAccountLimits)
      return false;
    else if (__isset.includeAccountLimits && !(includeAccountLimits == rhs.includeAccountLimits))
      return false;
    return true;
  }
  bool operator != (const NoteResultSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteResultSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NoteResultSpec &a, NoteResultSpec &b);

inline std::ostream& operator<<(std::ostream& out, const NoteResultSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoteEmailParameters__isset {
  _NoteEmailParameters__isset() : guid(false), note(false), toAddresses(false), ccAddresses(false), subject(false), message(false) {}
  bool guid :1;
  bool note :1;
  bool toAddresses :1;
  bool ccAddresses :1;
  bool subject :1;
  bool message :1;
} _NoteEmailParameters__isset;

class NoteEmailParameters {
 public:

  NoteEmailParameters(const NoteEmailParameters&);
  NoteEmailParameters& operator=(const NoteEmailParameters&);
  NoteEmailParameters() : guid(), subject(), message() {
  }

  virtual ~NoteEmailParameters() throw();
  std::string guid;
   ::evernote::edam::Note note;
  std::vector<std::string>  toAddresses;
  std::vector<std::string>  ccAddresses;
  std::string subject;
  std::string message;

  _NoteEmailParameters__isset __isset;

  void __set_guid(const std::string& val);

  void __set_note(const  ::evernote::edam::Note& val);

  void __set_toAddresses(const std::vector<std::string> & val);

  void __set_ccAddresses(const std::vector<std::string> & val);

  void __set_subject(const std::string& val);

  void __set_message(const std::string& val);

  bool operator == (const NoteEmailParameters & rhs) const
  {
    if (__isset.guid != rhs.__isset.guid)
      return false;
    else if (__isset.guid && !(guid == rhs.guid))
      return false;
    if (__isset.note != rhs.__isset.note)
      return false;
    else if (__isset.note && !(note == rhs.note))
      return false;
    if (__isset.toAddresses != rhs.__isset.toAddresses)
      return false;
    else if (__isset.toAddresses && !(toAddresses == rhs.toAddresses))
      return false;
    if (__isset.ccAddresses != rhs.__isset.ccAddresses)
      return false;
    else if (__isset.ccAddresses && !(ccAddresses == rhs.ccAddresses))
      return false;
    if (__isset.subject != rhs.__isset.subject)
      return false;
    else if (__isset.subject && !(subject == rhs.subject))
      return false;
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoteEmailParameters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteEmailParameters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NoteEmailParameters &a, NoteEmailParameters &b);

inline std::ostream& operator<<(std::ostream& out, const NoteEmailParameters& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoteVersionId__isset {
  _NoteVersionId__isset() : lastEditorId(false) {}
  bool lastEditorId :1;
} _NoteVersionId__isset;

class NoteVersionId {
 public:

  NoteVersionId(const NoteVersionId&);
  NoteVersionId& operator=(const NoteVersionId&);
  NoteVersionId() : updateSequenceNum(0), updated(0), saved(0), title(), lastEditorId(0) {
  }

  virtual ~NoteVersionId() throw();
  int32_t updateSequenceNum;
   ::evernote::edam::Timestamp updated;
   ::evernote::edam::Timestamp saved;
  std::string title;
   ::evernote::edam::UserID lastEditorId;

  _NoteVersionId__isset __isset;

  void __set_updateSequenceNum(const int32_t val);

  void __set_updated(const  ::evernote::edam::Timestamp val);

  void __set_saved(const  ::evernote::edam::Timestamp val);

  void __set_title(const std::string& val);

  void __set_lastEditorId(const  ::evernote::edam::UserID val);

  bool operator == (const NoteVersionId & rhs) const
  {
    if (!(updateSequenceNum == rhs.updateSequenceNum))
      return false;
    if (!(updated == rhs.updated))
      return false;
    if (!(saved == rhs.saved))
      return false;
    if (!(title == rhs.title))
      return false;
    if (__isset.lastEditorId != rhs.__isset.lastEditorId)
      return false;
    else if (__isset.lastEditorId && !(lastEditorId == rhs.lastEditorId))
      return false;
    return true;
  }
  bool operator != (const NoteVersionId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteVersionId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NoteVersionId &a, NoteVersionId &b);

inline std::ostream& operator<<(std::ostream& out, const NoteVersionId& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RelatedQuery__isset {
  _RelatedQuery__isset() : noteGuid(false), plainText(false), filter(false), referenceUri(false), context(false), cacheKey(false) {}
  bool noteGuid :1;
  bool plainText :1;
  bool filter :1;
  bool referenceUri :1;
  bool context :1;
  bool cacheKey :1;
} _RelatedQuery__isset;

class RelatedQuery {
 public:

  RelatedQuery(const RelatedQuery&);
  RelatedQuery& operator=(const RelatedQuery&);
  RelatedQuery() : noteGuid(), plainText(), referenceUri(), context(), cacheKey() {
  }

  virtual ~RelatedQuery() throw();
  std::string noteGuid;
  std::string plainText;
  NoteFilter filter;
  std::string referenceUri;
  std::string context;
  std::string cacheKey;

  _RelatedQuery__isset __isset;

  void __set_noteGuid(const std::string& val);

  void __set_plainText(const std::string& val);

  void __set_filter(const NoteFilter& val);

  void __set_referenceUri(const std::string& val);

  void __set_context(const std::string& val);

  void __set_cacheKey(const std::string& val);

  bool operator == (const RelatedQuery & rhs) const
  {
    if (__isset.noteGuid != rhs.__isset.noteGuid)
      return false;
    else if (__isset.noteGuid && !(noteGuid == rhs.noteGuid))
      return false;
    if (__isset.plainText != rhs.__isset.plainText)
      return false;
    else if (__isset.plainText && !(plainText == rhs.plainText))
      return false;
    if (__isset.filter != rhs.__isset.filter)
      return false;
    else if (__isset.filter && !(filter == rhs.filter))
      return false;
    if (__isset.referenceUri != rhs.__isset.referenceUri)
      return false;
    else if (__isset.referenceUri && !(referenceUri == rhs.referenceUri))
      return false;
    if (__isset.context != rhs.__isset.context)
      return false;
    else if (__isset.context && !(context == rhs.context))
      return false;
    if (__isset.cacheKey != rhs.__isset.cacheKey)
      return false;
    else if (__isset.cacheKey && !(cacheKey == rhs.cacheKey))
      return false;
    return true;
  }
  bool operator != (const RelatedQuery &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RelatedQuery & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RelatedQuery &a, RelatedQuery &b);

inline std::ostream& operator<<(std::ostream& out, const RelatedQuery& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RelatedResult__isset {
  _RelatedResult__isset() : notes(false), notebooks(false), tags(false), containingNotebooks(false), experts(false), relatedContent(false), cacheKey(false), cacheExpires(false) {}
  bool notes :1;
  bool notebooks :1;
  bool tags :1;
  bool containingNotebooks :1;
  bool experts :1;
  bool relatedContent :1;
  bool cacheKey :1;
  bool cacheExpires :1;
} _RelatedResult__isset;

class RelatedResult {
 public:

  RelatedResult(const RelatedResult&);
  RelatedResult& operator=(const RelatedResult&);
  RelatedResult() : cacheKey(), cacheExpires(0) {
  }

  virtual ~RelatedResult() throw();
  std::vector< ::evernote::edam::Note>  notes;
  std::vector< ::evernote::edam::Notebook>  notebooks;
  std::vector< ::evernote::edam::Tag>  tags;
  std::vector< ::evernote::edam::NotebookDescriptor>  containingNotebooks;
  std::vector< ::evernote::edam::UserProfile>  experts;
  std::vector< ::evernote::edam::RelatedContent>  relatedContent;
  std::string cacheKey;
  int32_t cacheExpires;

  _RelatedResult__isset __isset;

  void __set_notes(const std::vector< ::evernote::edam::Note> & val);

  void __set_notebooks(const std::vector< ::evernote::edam::Notebook> & val);

  void __set_tags(const std::vector< ::evernote::edam::Tag> & val);

  void __set_containingNotebooks(const std::vector< ::evernote::edam::NotebookDescriptor> & val);

  void __set_experts(const std::vector< ::evernote::edam::UserProfile> & val);

  void __set_relatedContent(const std::vector< ::evernote::edam::RelatedContent> & val);

  void __set_cacheKey(const std::string& val);

  void __set_cacheExpires(const int32_t val);

  bool operator == (const RelatedResult & rhs) const
  {
    if (__isset.notes != rhs.__isset.notes)
      return false;
    else if (__isset.notes && !(notes == rhs.notes))
      return false;
    if (__isset.notebooks != rhs.__isset.notebooks)
      return false;
    else if (__isset.notebooks && !(notebooks == rhs.notebooks))
      return false;
    if (__isset.tags != rhs.__isset.tags)
      return false;
    else if (__isset.tags && !(tags == rhs.tags))
      return false;
    if (__isset.containingNotebooks != rhs.__isset.containingNotebooks)
      return false;
    else if (__isset.containingNotebooks && !(containingNotebooks == rhs.containingNotebooks))
      return false;
    if (__isset.experts != rhs.__isset.experts)
      return false;
    else if (__isset.experts && !(experts == rhs.experts))
      return false;
    if (__isset.relatedContent != rhs.__isset.relatedContent)
      return false;
    else if (__isset.relatedContent && !(relatedContent == rhs.relatedContent))
      return false;
    if (__isset.cacheKey != rhs.__isset.cacheKey)
      return false;
    else if (__isset.cacheKey && !(cacheKey == rhs.cacheKey))
      return false;
    if (__isset.cacheExpires != rhs.__isset.cacheExpires)
      return false;
    else if (__isset.cacheExpires && !(cacheExpires == rhs.cacheExpires))
      return false;
    return true;
  }
  bool operator != (const RelatedResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RelatedResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RelatedResult &a, RelatedResult &b);

inline std::ostream& operator<<(std::ostream& out, const RelatedResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RelatedResultSpec__isset {
  _RelatedResultSpec__isset() : maxNotes(false), maxNotebooks(false), maxTags(false), writableNotebooksOnly(false), includeContainingNotebooks(false), maxExperts(false), maxRelatedContent(false), relatedContentTypes(false) {}
  bool maxNotes :1;
  bool maxNotebooks :1;
  bool maxTags :1;
  bool writableNotebooksOnly :1;
  bool includeContainingNotebooks :1;
  bool maxExperts :1;
  bool maxRelatedContent :1;
  bool relatedContentTypes :1;
} _RelatedResultSpec__isset;

class RelatedResultSpec {
 public:

  RelatedResultSpec(const RelatedResultSpec&);
  RelatedResultSpec& operator=(const RelatedResultSpec&);
  RelatedResultSpec() : maxNotes(0), maxNotebooks(0), maxTags(0), writableNotebooksOnly(0), includeContainingNotebooks(0), maxExperts(0), maxRelatedContent(0) {
  }

  virtual ~RelatedResultSpec() throw();
  int32_t maxNotes;
  int32_t maxNotebooks;
  int32_t maxTags;
  bool writableNotebooksOnly;
  bool includeContainingNotebooks;
  int32_t maxExperts;
  int32_t maxRelatedContent;
  std::set< ::evernote::edam::RelatedContentType::type>  relatedContentTypes;

  _RelatedResultSpec__isset __isset;

  void __set_maxNotes(const int32_t val);

  void __set_maxNotebooks(const int32_t val);

  void __set_maxTags(const int32_t val);

  void __set_writableNotebooksOnly(const bool val);

  void __set_includeContainingNotebooks(const bool val);

  void __set_maxExperts(const int32_t val);

  void __set_maxRelatedContent(const int32_t val);

  void __set_relatedContentTypes(const std::set< ::evernote::edam::RelatedContentType::type> & val);

  bool operator == (const RelatedResultSpec & rhs) const
  {
    if (__isset.maxNotes != rhs.__isset.maxNotes)
      return false;
    else if (__isset.maxNotes && !(maxNotes == rhs.maxNotes))
      return false;
    if (__isset.maxNotebooks != rhs.__isset.maxNotebooks)
      return false;
    else if (__isset.maxNotebooks && !(maxNotebooks == rhs.maxNotebooks))
      return false;
    if (__isset.maxTags != rhs.__isset.maxTags)
      return false;
    else if (__isset.maxTags && !(maxTags == rhs.maxTags))
      return false;
    if (__isset.writableNotebooksOnly != rhs.__isset.writableNotebooksOnly)
      return false;
    else if (__isset.writableNotebooksOnly && !(writableNotebooksOnly == rhs.writableNotebooksOnly))
      return false;
    if (__isset.includeContainingNotebooks != rhs.__isset.includeContainingNotebooks)
      return false;
    else if (__isset.includeContainingNotebooks && !(includeContainingNotebooks == rhs.includeContainingNotebooks))
      return false;
    if (__isset.maxExperts != rhs.__isset.maxExperts)
      return false;
    else if (__isset.maxExperts && !(maxExperts == rhs.maxExperts))
      return false;
    if (__isset.maxRelatedContent != rhs.__isset.maxRelatedContent)
      return false;
    else if (__isset.maxRelatedContent && !(maxRelatedContent == rhs.maxRelatedContent))
      return false;
    if (__isset.relatedContentTypes != rhs.__isset.relatedContentTypes)
      return false;
    else if (__isset.relatedContentTypes && !(relatedContentTypes == rhs.relatedContentTypes))
      return false;
    return true;
  }
  bool operator != (const RelatedResultSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RelatedResultSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RelatedResultSpec &a, RelatedResultSpec &b);

inline std::ostream& operator<<(std::ostream& out, const RelatedResultSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _UpdateNoteIfUsnMatchesResult__isset {
  _UpdateNoteIfUsnMatchesResult__isset() : note(false), updated(false) {}
  bool note :1;
  bool updated :1;
} _UpdateNoteIfUsnMatchesResult__isset;

class UpdateNoteIfUsnMatchesResult {
 public:

  UpdateNoteIfUsnMatchesResult(const UpdateNoteIfUsnMatchesResult&);
  UpdateNoteIfUsnMatchesResult& operator=(const UpdateNoteIfUsnMatchesResult&);
  UpdateNoteIfUsnMatchesResult() : updated(0) {
  }

  virtual ~UpdateNoteIfUsnMatchesResult() throw();
   ::evernote::edam::Note note;
  bool updated;

  _UpdateNoteIfUsnMatchesResult__isset __isset;

  void __set_note(const  ::evernote::edam::Note& val);

  void __set_updated(const bool val);

  bool operator == (const UpdateNoteIfUsnMatchesResult & rhs) const
  {
    if (__isset.note != rhs.__isset.note)
      return false;
    else if (__isset.note && !(note == rhs.note))
      return false;
    if (__isset.updated != rhs.__isset.updated)
      return false;
    else if (__isset.updated && !(updated == rhs.updated))
      return false;
    return true;
  }
  bool operator != (const UpdateNoteIfUsnMatchesResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UpdateNoteIfUsnMatchesResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UpdateNoteIfUsnMatchesResult &a, UpdateNoteIfUsnMatchesResult &b);

inline std::ostream& operator<<(std::ostream& out, const UpdateNoteIfUsnMatchesResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ShareRelationshipRestrictions__isset {
  _ShareRelationshipRestrictions__isset() : noSetReadOnly(false), noSetReadPlusActivity(false), noSetModify(false), noSetFullAccess(false) {}
  bool noSetReadOnly :1;
  bool noSetReadPlusActivity :1;
  bool noSetModify :1;
  bool noSetFullAccess :1;
} _ShareRelationshipRestrictions__isset;

class ShareRelationshipRestrictions {
 public:

  ShareRelationshipRestrictions(const ShareRelationshipRestrictions&);
  ShareRelationshipRestrictions& operator=(const ShareRelationshipRestrictions&);
  ShareRelationshipRestrictions() : noSetReadOnly(0), noSetReadPlusActivity(0), noSetModify(0), noSetFullAccess(0) {
  }

  virtual ~ShareRelationshipRestrictions() throw();
  bool noSetReadOnly;
  bool noSetReadPlusActivity;
  bool noSetModify;
  bool noSetFullAccess;

  _ShareRelationshipRestrictions__isset __isset;

  void __set_noSetReadOnly(const bool val);

  void __set_noSetReadPlusActivity(const bool val);

  void __set_noSetModify(const bool val);

  void __set_noSetFullAccess(const bool val);

  bool operator == (const ShareRelationshipRestrictions & rhs) const
  {
    if (__isset.noSetReadOnly != rhs.__isset.noSetReadOnly)
      return false;
    else if (__isset.noSetReadOnly && !(noSetReadOnly == rhs.noSetReadOnly))
      return false;
    if (__isset.noSetReadPlusActivity != rhs.__isset.noSetReadPlusActivity)
      return false;
    else if (__isset.noSetReadPlusActivity && !(noSetReadPlusActivity == rhs.noSetReadPlusActivity))
      return false;
    if (__isset.noSetModify != rhs.__isset.noSetModify)
      return false;
    else if (__isset.noSetModify && !(noSetModify == rhs.noSetModify))
      return false;
    if (__isset.noSetFullAccess != rhs.__isset.noSetFullAccess)
      return false;
    else if (__isset.noSetFullAccess && !(noSetFullAccess == rhs.noSetFullAccess))
      return false;
    return true;
  }
  bool operator != (const ShareRelationshipRestrictions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShareRelationshipRestrictions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShareRelationshipRestrictions &a, ShareRelationshipRestrictions &b);

inline std::ostream& operator<<(std::ostream& out, const ShareRelationshipRestrictions& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _InvitationShareRelationship__isset {
  _InvitationShareRelationship__isset() : displayName(false), recipientUserIdentity(false), privilege(false), sharerUserId(false) {}
  bool displayName :1;
  bool recipientUserIdentity :1;
  bool privilege :1;
  bool sharerUserId :1;
} _InvitationShareRelationship__isset;

class InvitationShareRelationship {
 public:

  InvitationShareRelationship(const InvitationShareRelationship&);
  InvitationShareRelationship& operator=(const InvitationShareRelationship&);
  InvitationShareRelationship() : displayName(), privilege((ShareRelationshipPrivilegeLevel::type)0), sharerUserId(0) {
  }

  virtual ~InvitationShareRelationship() throw();
  std::string displayName;
   ::evernote::edam::UserIdentity recipientUserIdentity;
  ShareRelationshipPrivilegeLevel::type privilege;
   ::evernote::edam::UserID sharerUserId;

  _InvitationShareRelationship__isset __isset;

  void __set_displayName(const std::string& val);

  void __set_recipientUserIdentity(const  ::evernote::edam::UserIdentity& val);

  void __set_privilege(const ShareRelationshipPrivilegeLevel::type val);

  void __set_sharerUserId(const  ::evernote::edam::UserID val);

  bool operator == (const InvitationShareRelationship & rhs) const
  {
    if (__isset.displayName != rhs.__isset.displayName)
      return false;
    else if (__isset.displayName && !(displayName == rhs.displayName))
      return false;
    if (__isset.recipientUserIdentity != rhs.__isset.recipientUserIdentity)
      return false;
    else if (__isset.recipientUserIdentity && !(recipientUserIdentity == rhs.recipientUserIdentity))
      return false;
    if (__isset.privilege != rhs.__isset.privilege)
      return false;
    else if (__isset.privilege && !(privilege == rhs.privilege))
      return false;
    if (__isset.sharerUserId != rhs.__isset.sharerUserId)
      return false;
    else if (__isset.sharerUserId && !(sharerUserId == rhs.sharerUserId))
      return false;
    return true;
  }
  bool operator != (const InvitationShareRelationship &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvitationShareRelationship & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(InvitationShareRelationship &a, InvitationShareRelationship &b);

inline std::ostream& operator<<(std::ostream& out, const InvitationShareRelationship& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MemberShareRelationship__isset {
  _MemberShareRelationship__isset() : displayName(false), recipientUserId(false), bestPrivilege(false), individualPrivilege(false), restrictions(false), sharerUserId(false) {}
  bool displayName :1;
  bool recipientUserId :1;
  bool bestPrivilege :1;
  bool individualPrivilege :1;
  bool restrictions :1;
  bool sharerUserId :1;
} _MemberShareRelationship__isset;

class MemberShareRelationship {
 public:

  MemberShareRelationship(const MemberShareRelationship&);
  MemberShareRelationship& operator=(const MemberShareRelationship&);
  MemberShareRelationship() : displayName(), recipientUserId(0), bestPrivilege((ShareRelationshipPrivilegeLevel::type)0), individualPrivilege((ShareRelationshipPrivilegeLevel::type)0), sharerUserId(0) {
  }

  virtual ~MemberShareRelationship() throw();
  std::string displayName;
   ::evernote::edam::UserID recipientUserId;
  ShareRelationshipPrivilegeLevel::type bestPrivilege;
  ShareRelationshipPrivilegeLevel::type individualPrivilege;
  ShareRelationshipRestrictions restrictions;
   ::evernote::edam::UserID sharerUserId;

  _MemberShareRelationship__isset __isset;

  void __set_displayName(const std::string& val);

  void __set_recipientUserId(const  ::evernote::edam::UserID val);

  void __set_bestPrivilege(const ShareRelationshipPrivilegeLevel::type val);

  void __set_individualPrivilege(const ShareRelationshipPrivilegeLevel::type val);

  void __set_restrictions(const ShareRelationshipRestrictions& val);

  void __set_sharerUserId(const  ::evernote::edam::UserID val);

  bool operator == (const MemberShareRelationship & rhs) const
  {
    if (__isset.displayName != rhs.__isset.displayName)
      return false;
    else if (__isset.displayName && !(displayName == rhs.displayName))
      return false;
    if (__isset.recipientUserId != rhs.__isset.recipientUserId)
      return false;
    else if (__isset.recipientUserId && !(recipientUserId == rhs.recipientUserId))
      return false;
    if (__isset.bestPrivilege != rhs.__isset.bestPrivilege)
      return false;
    else if (__isset.bestPrivilege && !(bestPrivilege == rhs.bestPrivilege))
      return false;
    if (__isset.individualPrivilege != rhs.__isset.individualPrivilege)
      return false;
    else if (__isset.individualPrivilege && !(individualPrivilege == rhs.individualPrivilege))
      return false;
    if (__isset.restrictions != rhs.__isset.restrictions)
      return false;
    else if (__isset.restrictions && !(restrictions == rhs.restrictions))
      return false;
    if (__isset.sharerUserId != rhs.__isset.sharerUserId)
      return false;
    else if (__isset.sharerUserId && !(sharerUserId == rhs.sharerUserId))
      return false;
    return true;
  }
  bool operator != (const MemberShareRelationship &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MemberShareRelationship & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MemberShareRelationship &a, MemberShareRelationship &b);

inline std::ostream& operator<<(std::ostream& out, const MemberShareRelationship& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ShareRelationships__isset {
  _ShareRelationships__isset() : invitations(false), memberships(false), invitationRestrictions(false) {}
  bool invitations :1;
  bool memberships :1;
  bool invitationRestrictions :1;
} _ShareRelationships__isset;

class ShareRelationships {
 public:

  ShareRelationships(const ShareRelationships&);
  ShareRelationships& operator=(const ShareRelationships&);
  ShareRelationships() {
  }

  virtual ~ShareRelationships() throw();
  std::vector<InvitationShareRelationship>  invitations;
  std::vector<MemberShareRelationship>  memberships;
  ShareRelationshipRestrictions invitationRestrictions;

  _ShareRelationships__isset __isset;

  void __set_invitations(const std::vector<InvitationShareRelationship> & val);

  void __set_memberships(const std::vector<MemberShareRelationship> & val);

  void __set_invitationRestrictions(const ShareRelationshipRestrictions& val);

  bool operator == (const ShareRelationships & rhs) const
  {
    if (__isset.invitations != rhs.__isset.invitations)
      return false;
    else if (__isset.invitations && !(invitations == rhs.invitations))
      return false;
    if (__isset.memberships != rhs.__isset.memberships)
      return false;
    else if (__isset.memberships && !(memberships == rhs.memberships))
      return false;
    if (__isset.invitationRestrictions != rhs.__isset.invitationRestrictions)
      return false;
    else if (__isset.invitationRestrictions && !(invitationRestrictions == rhs.invitationRestrictions))
      return false;
    return true;
  }
  bool operator != (const ShareRelationships &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShareRelationships & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShareRelationships &a, ShareRelationships &b);

inline std::ostream& operator<<(std::ostream& out, const ShareRelationships& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ManageNotebookSharesParameters__isset {
  _ManageNotebookSharesParameters__isset() : notebookGuid(false), inviteMessage(false), membershipsToUpdate(false), invitationsToCreateOrUpdate(false), unshares(false) {}
  bool notebookGuid :1;
  bool inviteMessage :1;
  bool membershipsToUpdate :1;
  bool invitationsToCreateOrUpdate :1;
  bool unshares :1;
} _ManageNotebookSharesParameters__isset;

class ManageNotebookSharesParameters {
 public:

  ManageNotebookSharesParameters(const ManageNotebookSharesParameters&);
  ManageNotebookSharesParameters& operator=(const ManageNotebookSharesParameters&);
  ManageNotebookSharesParameters() : notebookGuid(), inviteMessage() {
  }

  virtual ~ManageNotebookSharesParameters() throw();
  std::string notebookGuid;
  std::string inviteMessage;
  std::vector<MemberShareRelationship>  membershipsToUpdate;
  std::vector<InvitationShareRelationship>  invitationsToCreateOrUpdate;
  std::vector< ::evernote::edam::UserIdentity>  unshares;

  _ManageNotebookSharesParameters__isset __isset;

  void __set_notebookGuid(const std::string& val);

  void __set_inviteMessage(const std::string& val);

  void __set_membershipsToUpdate(const std::vector<MemberShareRelationship> & val);

  void __set_invitationsToCreateOrUpdate(const std::vector<InvitationShareRelationship> & val);

  void __set_unshares(const std::vector< ::evernote::edam::UserIdentity> & val);

  bool operator == (const ManageNotebookSharesParameters & rhs) const
  {
    if (__isset.notebookGuid != rhs.__isset.notebookGuid)
      return false;
    else if (__isset.notebookGuid && !(notebookGuid == rhs.notebookGuid))
      return false;
    if (__isset.inviteMessage != rhs.__isset.inviteMessage)
      return false;
    else if (__isset.inviteMessage && !(inviteMessage == rhs.inviteMessage))
      return false;
    if (__isset.membershipsToUpdate != rhs.__isset.membershipsToUpdate)
      return false;
    else if (__isset.membershipsToUpdate && !(membershipsToUpdate == rhs.membershipsToUpdate))
      return false;
    if (__isset.invitationsToCreateOrUpdate != rhs.__isset.invitationsToCreateOrUpdate)
      return false;
    else if (__isset.invitationsToCreateOrUpdate && !(invitationsToCreateOrUpdate == rhs.invitationsToCreateOrUpdate))
      return false;
    if (__isset.unshares != rhs.__isset.unshares)
      return false;
    else if (__isset.unshares && !(unshares == rhs.unshares))
      return false;
    return true;
  }
  bool operator != (const ManageNotebookSharesParameters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ManageNotebookSharesParameters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ManageNotebookSharesParameters &a, ManageNotebookSharesParameters &b);

inline std::ostream& operator<<(std::ostream& out, const ManageNotebookSharesParameters& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ManageNotebookSharesError__isset {
  _ManageNotebookSharesError__isset() : userIdentity(false), userException(false), notFoundException(false) {}
  bool userIdentity :1;
  bool userException :1;
  bool notFoundException :1;
} _ManageNotebookSharesError__isset;

class ManageNotebookSharesError {
 public:

  ManageNotebookSharesError(const ManageNotebookSharesError&);
  ManageNotebookSharesError& operator=(const ManageNotebookSharesError&);
  ManageNotebookSharesError() {
  }

  virtual ~ManageNotebookSharesError() throw();
   ::evernote::edam::UserIdentity userIdentity;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _ManageNotebookSharesError__isset __isset;

  void __set_userIdentity(const  ::evernote::edam::UserIdentity& val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const ManageNotebookSharesError & rhs) const
  {
    if (__isset.userIdentity != rhs.__isset.userIdentity)
      return false;
    else if (__isset.userIdentity && !(userIdentity == rhs.userIdentity))
      return false;
    if (__isset.userException != rhs.__isset.userException)
      return false;
    else if (__isset.userException && !(userException == rhs.userException))
      return false;
    if (__isset.notFoundException != rhs.__isset.notFoundException)
      return false;
    else if (__isset.notFoundException && !(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const ManageNotebookSharesError &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ManageNotebookSharesError & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ManageNotebookSharesError &a, ManageNotebookSharesError &b);

inline std::ostream& operator<<(std::ostream& out, const ManageNotebookSharesError& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ManageNotebookSharesResult__isset {
  _ManageNotebookSharesResult__isset() : errors(false) {}
  bool errors :1;
} _ManageNotebookSharesResult__isset;

class ManageNotebookSharesResult {
 public:

  ManageNotebookSharesResult(const ManageNotebookSharesResult&);
  ManageNotebookSharesResult& operator=(const ManageNotebookSharesResult&);
  ManageNotebookSharesResult() {
  }

  virtual ~ManageNotebookSharesResult() throw();
  std::vector<ManageNotebookSharesError>  errors;

  _ManageNotebookSharesResult__isset __isset;

  void __set_errors(const std::vector<ManageNotebookSharesError> & val);

  bool operator == (const ManageNotebookSharesResult & rhs) const
  {
    if (__isset.errors != rhs.__isset.errors)
      return false;
    else if (__isset.errors && !(errors == rhs.errors))
      return false;
    return true;
  }
  bool operator != (const ManageNotebookSharesResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ManageNotebookSharesResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ManageNotebookSharesResult &a, ManageNotebookSharesResult &b);

inline std::ostream& operator<<(std::ostream& out, const ManageNotebookSharesResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SharedNoteTemplate__isset {
  _SharedNoteTemplate__isset() : noteGuid(false), recipientThreadId(false), recipientContacts(false), privilege(false) {}
  bool noteGuid :1;
  bool recipientThreadId :1;
  bool recipientContacts :1;
  bool privilege :1;
} _SharedNoteTemplate__isset;

class SharedNoteTemplate {
 public:

  SharedNoteTemplate(const SharedNoteTemplate&);
  SharedNoteTemplate& operator=(const SharedNoteTemplate&);
  SharedNoteTemplate() : noteGuid(), recipientThreadId(0), privilege(( ::evernote::edam::SharedNotePrivilegeLevel::type)0) {
  }

  virtual ~SharedNoteTemplate() throw();
   ::evernote::edam::Guid noteGuid;
   ::evernote::edam::MessageThreadID recipientThreadId;
  std::vector< ::evernote::edam::Contact>  recipientContacts;
   ::evernote::edam::SharedNotePrivilegeLevel::type privilege;

  _SharedNoteTemplate__isset __isset;

  void __set_noteGuid(const  ::evernote::edam::Guid& val);

  void __set_recipientThreadId(const  ::evernote::edam::MessageThreadID val);

  void __set_recipientContacts(const std::vector< ::evernote::edam::Contact> & val);

  void __set_privilege(const  ::evernote::edam::SharedNotePrivilegeLevel::type val);

  bool operator == (const SharedNoteTemplate & rhs) const
  {
    if (__isset.noteGuid != rhs.__isset.noteGuid)
      return false;
    else if (__isset.noteGuid && !(noteGuid == rhs.noteGuid))
      return false;
    if (__isset.recipientThreadId != rhs.__isset.recipientThreadId)
      return false;
    else if (__isset.recipientThreadId && !(recipientThreadId == rhs.recipientThreadId))
      return false;
    if (__isset.recipientContacts != rhs.__isset.recipientContacts)
      return false;
    else if (__isset.recipientContacts && !(recipientContacts == rhs.recipientContacts))
      return false;
    if (__isset.privilege != rhs.__isset.privilege)
      return false;
    else if (__isset.privilege && !(privilege == rhs.privilege))
      return false;
    return true;
  }
  bool operator != (const SharedNoteTemplate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SharedNoteTemplate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SharedNoteTemplate &a, SharedNoteTemplate &b);

inline std::ostream& operator<<(std::ostream& out, const SharedNoteTemplate& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NotebookShareTemplate__isset {
  _NotebookShareTemplate__isset() : notebookGuid(false), recipientThreadId(false), recipientContacts(false), privilege(false) {}
  bool notebookGuid :1;
  bool recipientThreadId :1;
  bool recipientContacts :1;
  bool privilege :1;
} _NotebookShareTemplate__isset;

class NotebookShareTemplate {
 public:

  NotebookShareTemplate(const NotebookShareTemplate&);
  NotebookShareTemplate& operator=(const NotebookShareTemplate&);
  NotebookShareTemplate() : notebookGuid(), recipientThreadId(0), privilege(( ::evernote::edam::SharedNotebookPrivilegeLevel::type)0) {
  }

  virtual ~NotebookShareTemplate() throw();
   ::evernote::edam::Guid notebookGuid;
   ::evernote::edam::MessageThreadID recipientThreadId;
  std::vector< ::evernote::edam::Contact>  recipientContacts;
   ::evernote::edam::SharedNotebookPrivilegeLevel::type privilege;

  _NotebookShareTemplate__isset __isset;

  void __set_notebookGuid(const  ::evernote::edam::Guid& val);

  void __set_recipientThreadId(const  ::evernote::edam::MessageThreadID val);

  void __set_recipientContacts(const std::vector< ::evernote::edam::Contact> & val);

  void __set_privilege(const  ::evernote::edam::SharedNotebookPrivilegeLevel::type val);

  bool operator == (const NotebookShareTemplate & rhs) const
  {
    if (__isset.notebookGuid != rhs.__isset.notebookGuid)
      return false;
    else if (__isset.notebookGuid && !(notebookGuid == rhs.notebookGuid))
      return false;
    if (__isset.recipientThreadId != rhs.__isset.recipientThreadId)
      return false;
    else if (__isset.recipientThreadId && !(recipientThreadId == rhs.recipientThreadId))
      return false;
    if (__isset.recipientContacts != rhs.__isset.recipientContacts)
      return false;
    else if (__isset.recipientContacts && !(recipientContacts == rhs.recipientContacts))
      return false;
    if (__isset.privilege != rhs.__isset.privilege)
      return false;
    else if (__isset.privilege && !(privilege == rhs.privilege))
      return false;
    return true;
  }
  bool operator != (const NotebookShareTemplate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotebookShareTemplate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotebookShareTemplate &a, NotebookShareTemplate &b);

inline std::ostream& operator<<(std::ostream& out, const NotebookShareTemplate& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CreateOrUpdateNotebookSharesResult__isset {
  _CreateOrUpdateNotebookSharesResult__isset() : updateSequenceNum(false), matchingShares(false) {}
  bool updateSequenceNum :1;
  bool matchingShares :1;
} _CreateOrUpdateNotebookSharesResult__isset;

class CreateOrUpdateNotebookSharesResult {
 public:

  CreateOrUpdateNotebookSharesResult(const CreateOrUpdateNotebookSharesResult&);
  CreateOrUpdateNotebookSharesResult& operator=(const CreateOrUpdateNotebookSharesResult&);
  CreateOrUpdateNotebookSharesResult() : updateSequenceNum(0) {
  }

  virtual ~CreateOrUpdateNotebookSharesResult() throw();
  int32_t updateSequenceNum;
  std::vector< ::evernote::edam::SharedNotebook>  matchingShares;

  _CreateOrUpdateNotebookSharesResult__isset __isset;

  void __set_updateSequenceNum(const int32_t val);

  void __set_matchingShares(const std::vector< ::evernote::edam::SharedNotebook> & val);

  bool operator == (const CreateOrUpdateNotebookSharesResult & rhs) const
  {
    if (__isset.updateSequenceNum != rhs.__isset.updateSequenceNum)
      return false;
    else if (__isset.updateSequenceNum && !(updateSequenceNum == rhs.updateSequenceNum))
      return false;
    if (__isset.matchingShares != rhs.__isset.matchingShares)
      return false;
    else if (__isset.matchingShares && !(matchingShares == rhs.matchingShares))
      return false;
    return true;
  }
  bool operator != (const CreateOrUpdateNotebookSharesResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CreateOrUpdateNotebookSharesResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CreateOrUpdateNotebookSharesResult &a, CreateOrUpdateNotebookSharesResult &b);

inline std::ostream& operator<<(std::ostream& out, const CreateOrUpdateNotebookSharesResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoteShareRelationshipRestrictions__isset {
  _NoteShareRelationshipRestrictions__isset() : noSetReadNote(false), noSetModifyNote(false), noSetFullAccess(false) {}
  bool noSetReadNote :1;
  bool noSetModifyNote :1;
  bool noSetFullAccess :1;
} _NoteShareRelationshipRestrictions__isset;

class NoteShareRelationshipRestrictions {
 public:

  NoteShareRelationshipRestrictions(const NoteShareRelationshipRestrictions&);
  NoteShareRelationshipRestrictions& operator=(const NoteShareRelationshipRestrictions&);
  NoteShareRelationshipRestrictions() : noSetReadNote(0), noSetModifyNote(0), noSetFullAccess(0) {
  }

  virtual ~NoteShareRelationshipRestrictions() throw();
  bool noSetReadNote;
  bool noSetModifyNote;
  bool noSetFullAccess;

  _NoteShareRelationshipRestrictions__isset __isset;

  void __set_noSetReadNote(const bool val);

  void __set_noSetModifyNote(const bool val);

  void __set_noSetFullAccess(const bool val);

  bool operator == (const NoteShareRelationshipRestrictions & rhs) const
  {
    if (__isset.noSetReadNote != rhs.__isset.noSetReadNote)
      return false;
    else if (__isset.noSetReadNote && !(noSetReadNote == rhs.noSetReadNote))
      return false;
    if (__isset.noSetModifyNote != rhs.__isset.noSetModifyNote)
      return false;
    else if (__isset.noSetModifyNote && !(noSetModifyNote == rhs.noSetModifyNote))
      return false;
    if (__isset.noSetFullAccess != rhs.__isset.noSetFullAccess)
      return false;
    else if (__isset.noSetFullAccess && !(noSetFullAccess == rhs.noSetFullAccess))
      return false;
    return true;
  }
  bool operator != (const NoteShareRelationshipRestrictions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteShareRelationshipRestrictions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NoteShareRelationshipRestrictions &a, NoteShareRelationshipRestrictions &b);

inline std::ostream& operator<<(std::ostream& out, const NoteShareRelationshipRestrictions& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoteMemberShareRelationship__isset {
  _NoteMemberShareRelationship__isset() : displayName(false), recipientUserId(false), privilege(false), restrictions(false), sharerUserId(false) {}
  bool displayName :1;
  bool recipientUserId :1;
  bool privilege :1;
  bool restrictions :1;
  bool sharerUserId :1;
} _NoteMemberShareRelationship__isset;

class NoteMemberShareRelationship {
 public:

  NoteMemberShareRelationship(const NoteMemberShareRelationship&);
  NoteMemberShareRelationship& operator=(const NoteMemberShareRelationship&);
  NoteMemberShareRelationship() : displayName(), recipientUserId(0), privilege(( ::evernote::edam::SharedNotePrivilegeLevel::type)0), sharerUserId(0) {
  }

  virtual ~NoteMemberShareRelationship() throw();
  std::string displayName;
   ::evernote::edam::UserID recipientUserId;
   ::evernote::edam::SharedNotePrivilegeLevel::type privilege;
  NoteShareRelationshipRestrictions restrictions;
   ::evernote::edam::UserID sharerUserId;

  _NoteMemberShareRelationship__isset __isset;

  void __set_displayName(const std::string& val);

  void __set_recipientUserId(const  ::evernote::edam::UserID val);

  void __set_privilege(const  ::evernote::edam::SharedNotePrivilegeLevel::type val);

  void __set_restrictions(const NoteShareRelationshipRestrictions& val);

  void __set_sharerUserId(const  ::evernote::edam::UserID val);

  bool operator == (const NoteMemberShareRelationship & rhs) const
  {
    if (__isset.displayName != rhs.__isset.displayName)
      return false;
    else if (__isset.displayName && !(displayName == rhs.displayName))
      return false;
    if (__isset.recipientUserId != rhs.__isset.recipientUserId)
      return false;
    else if (__isset.recipientUserId && !(recipientUserId == rhs.recipientUserId))
      return false;
    if (__isset.privilege != rhs.__isset.privilege)
      return false;
    else if (__isset.privilege && !(privilege == rhs.privilege))
      return false;
    if (__isset.restrictions != rhs.__isset.restrictions)
      return false;
    else if (__isset.restrictions && !(restrictions == rhs.restrictions))
      return false;
    if (__isset.sharerUserId != rhs.__isset.sharerUserId)
      return false;
    else if (__isset.sharerUserId && !(sharerUserId == rhs.sharerUserId))
      return false;
    return true;
  }
  bool operator != (const NoteMemberShareRelationship &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteMemberShareRelationship & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NoteMemberShareRelationship &a, NoteMemberShareRelationship &b);

inline std::ostream& operator<<(std::ostream& out, const NoteMemberShareRelationship& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoteInvitationShareRelationship__isset {
  _NoteInvitationShareRelationship__isset() : displayName(false), recipientIdentityId(false), privilege(false), sharerUserId(false) {}
  bool displayName :1;
  bool recipientIdentityId :1;
  bool privilege :1;
  bool sharerUserId :1;
} _NoteInvitationShareRelationship__isset;

class NoteInvitationShareRelationship {
 public:

  NoteInvitationShareRelationship(const NoteInvitationShareRelationship&);
  NoteInvitationShareRelationship& operator=(const NoteInvitationShareRelationship&);
  NoteInvitationShareRelationship() : displayName(), recipientIdentityId(0), privilege(( ::evernote::edam::SharedNotePrivilegeLevel::type)0), sharerUserId(0) {
  }

  virtual ~NoteInvitationShareRelationship() throw();
  std::string displayName;
   ::evernote::edam::IdentityID recipientIdentityId;
   ::evernote::edam::SharedNotePrivilegeLevel::type privilege;
   ::evernote::edam::UserID sharerUserId;

  _NoteInvitationShareRelationship__isset __isset;

  void __set_displayName(const std::string& val);

  void __set_recipientIdentityId(const  ::evernote::edam::IdentityID val);

  void __set_privilege(const  ::evernote::edam::SharedNotePrivilegeLevel::type val);

  void __set_sharerUserId(const  ::evernote::edam::UserID val);

  bool operator == (const NoteInvitationShareRelationship & rhs) const
  {
    if (__isset.displayName != rhs.__isset.displayName)
      return false;
    else if (__isset.displayName && !(displayName == rhs.displayName))
      return false;
    if (__isset.recipientIdentityId != rhs.__isset.recipientIdentityId)
      return false;
    else if (__isset.recipientIdentityId && !(recipientIdentityId == rhs.recipientIdentityId))
      return false;
    if (__isset.privilege != rhs.__isset.privilege)
      return false;
    else if (__isset.privilege && !(privilege == rhs.privilege))
      return false;
    if (__isset.sharerUserId != rhs.__isset.sharerUserId)
      return false;
    else if (__isset.sharerUserId && !(sharerUserId == rhs.sharerUserId))
      return false;
    return true;
  }
  bool operator != (const NoteInvitationShareRelationship &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteInvitationShareRelationship & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NoteInvitationShareRelationship &a, NoteInvitationShareRelationship &b);

inline std::ostream& operator<<(std::ostream& out, const NoteInvitationShareRelationship& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoteShareRelationships__isset {
  _NoteShareRelationships__isset() : invitations(false), memberships(false), invitationRestrictions(false) {}
  bool invitations :1;
  bool memberships :1;
  bool invitationRestrictions :1;
} _NoteShareRelationships__isset;

class NoteShareRelationships {
 public:

  NoteShareRelationships(const NoteShareRelationships&);
  NoteShareRelationships& operator=(const NoteShareRelationships&);
  NoteShareRelationships() {
  }

  virtual ~NoteShareRelationships() throw();
  std::vector<NoteInvitationShareRelationship>  invitations;
  std::vector<NoteMemberShareRelationship>  memberships;
  NoteShareRelationshipRestrictions invitationRestrictions;

  _NoteShareRelationships__isset __isset;

  void __set_invitations(const std::vector<NoteInvitationShareRelationship> & val);

  void __set_memberships(const std::vector<NoteMemberShareRelationship> & val);

  void __set_invitationRestrictions(const NoteShareRelationshipRestrictions& val);

  bool operator == (const NoteShareRelationships & rhs) const
  {
    if (__isset.invitations != rhs.__isset.invitations)
      return false;
    else if (__isset.invitations && !(invitations == rhs.invitations))
      return false;
    if (__isset.memberships != rhs.__isset.memberships)
      return false;
    else if (__isset.memberships && !(memberships == rhs.memberships))
      return false;
    if (__isset.invitationRestrictions != rhs.__isset.invitationRestrictions)
      return false;
    else if (__isset.invitationRestrictions && !(invitationRestrictions == rhs.invitationRestrictions))
      return false;
    return true;
  }
  bool operator != (const NoteShareRelationships &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoteShareRelationships & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NoteShareRelationships &a, NoteShareRelationships &b);

inline std::ostream& operator<<(std::ostream& out, const NoteShareRelationships& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ManageNoteSharesParameters__isset {
  _ManageNoteSharesParameters__isset() : noteGuid(false), membershipsToUpdate(false), invitationsToUpdate(false), membershipsToUnshare(false), invitationsToUnshare(false) {}
  bool noteGuid :1;
  bool membershipsToUpdate :1;
  bool invitationsToUpdate :1;
  bool membershipsToUnshare :1;
  bool invitationsToUnshare :1;
} _ManageNoteSharesParameters__isset;

class ManageNoteSharesParameters {
 public:

  ManageNoteSharesParameters(const ManageNoteSharesParameters&);
  ManageNoteSharesParameters& operator=(const ManageNoteSharesParameters&);
  ManageNoteSharesParameters() : noteGuid() {
  }

  virtual ~ManageNoteSharesParameters() throw();
  std::string noteGuid;
  std::vector<NoteMemberShareRelationship>  membershipsToUpdate;
  std::vector<NoteInvitationShareRelationship>  invitationsToUpdate;
  std::vector< ::evernote::edam::UserID>  membershipsToUnshare;
  std::vector< ::evernote::edam::IdentityID>  invitationsToUnshare;

  _ManageNoteSharesParameters__isset __isset;

  void __set_noteGuid(const std::string& val);

  void __set_membershipsToUpdate(const std::vector<NoteMemberShareRelationship> & val);

  void __set_invitationsToUpdate(const std::vector<NoteInvitationShareRelationship> & val);

  void __set_membershipsToUnshare(const std::vector< ::evernote::edam::UserID> & val);

  void __set_invitationsToUnshare(const std::vector< ::evernote::edam::IdentityID> & val);

  bool operator == (const ManageNoteSharesParameters & rhs) const
  {
    if (__isset.noteGuid != rhs.__isset.noteGuid)
      return false;
    else if (__isset.noteGuid && !(noteGuid == rhs.noteGuid))
      return false;
    if (__isset.membershipsToUpdate != rhs.__isset.membershipsToUpdate)
      return false;
    else if (__isset.membershipsToUpdate && !(membershipsToUpdate == rhs.membershipsToUpdate))
      return false;
    if (__isset.invitationsToUpdate != rhs.__isset.invitationsToUpdate)
      return false;
    else if (__isset.invitationsToUpdate && !(invitationsToUpdate == rhs.invitationsToUpdate))
      return false;
    if (__isset.membershipsToUnshare != rhs.__isset.membershipsToUnshare)
      return false;
    else if (__isset.membershipsToUnshare && !(membershipsToUnshare == rhs.membershipsToUnshare))
      return false;
    if (__isset.invitationsToUnshare != rhs.__isset.invitationsToUnshare)
      return false;
    else if (__isset.invitationsToUnshare && !(invitationsToUnshare == rhs.invitationsToUnshare))
      return false;
    return true;
  }
  bool operator != (const ManageNoteSharesParameters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ManageNoteSharesParameters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ManageNoteSharesParameters &a, ManageNoteSharesParameters &b);

inline std::ostream& operator<<(std::ostream& out, const ManageNoteSharesParameters& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ManageNoteSharesError__isset {
  _ManageNoteSharesError__isset() : identityID(false), userID(false), userException(false), notFoundException(false) {}
  bool identityID :1;
  bool userID :1;
  bool userException :1;
  bool notFoundException :1;
} _ManageNoteSharesError__isset;

class ManageNoteSharesError {
 public:

  ManageNoteSharesError(const ManageNoteSharesError&);
  ManageNoteSharesError& operator=(const ManageNoteSharesError&);
  ManageNoteSharesError() : identityID(0), userID(0) {
  }

  virtual ~ManageNoteSharesError() throw();
   ::evernote::edam::IdentityID identityID;
   ::evernote::edam::UserID userID;
   ::evernote::edam::EDAMUserException userException;
   ::evernote::edam::EDAMNotFoundException notFoundException;

  _ManageNoteSharesError__isset __isset;

  void __set_identityID(const  ::evernote::edam::IdentityID val);

  void __set_userID(const  ::evernote::edam::UserID val);

  void __set_userException(const  ::evernote::edam::EDAMUserException& val);

  void __set_notFoundException(const  ::evernote::edam::EDAMNotFoundException& val);

  bool operator == (const ManageNoteSharesError & rhs) const
  {
    if (__isset.identityID != rhs.__isset.identityID)
      return false;
    else if (__isset.identityID && !(identityID == rhs.identityID))
      return false;
    if (__isset.userID != rhs.__isset.userID)
      return false;
    else if (__isset.userID && !(userID == rhs.userID))
      return false;
    if (__isset.userException != rhs.__isset.userException)
      return false;
    else if (__isset.userException && !(userException == rhs.userException))
      return false;
    if (__isset.notFoundException != rhs.__isset.notFoundException)
      return false;
    else if (__isset.notFoundException && !(notFoundException == rhs.notFoundException))
      return false;
    return true;
  }
  bool operator != (const ManageNoteSharesError &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ManageNoteSharesError & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ManageNoteSharesError &a, ManageNoteSharesError &b);

inline std::ostream& operator<<(std::ostream& out, const ManageNoteSharesError& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ManageNoteSharesResult__isset {
  _ManageNoteSharesResult__isset() : errors(false) {}
  bool errors :1;
} _ManageNoteSharesResult__isset;

class ManageNoteSharesResult {
 public:

  ManageNoteSharesResult(const ManageNoteSharesResult&);
  ManageNoteSharesResult& operator=(const ManageNoteSharesResult&);
  ManageNoteSharesResult() {
  }

  virtual ~ManageNoteSharesResult() throw();
  std::vector<ManageNoteSharesError>  errors;

  _ManageNoteSharesResult__isset __isset;

  void __set_errors(const std::vector<ManageNoteSharesError> & val);

  bool operator == (const ManageNoteSharesResult & rhs) const
  {
    if (__isset.errors != rhs.__isset.errors)
      return false;
    else if (__isset.errors && !(errors == rhs.errors))
      return false;
    return true;
  }
  bool operator != (const ManageNoteSharesResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ManageNoteSharesResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ManageNoteSharesResult &a, ManageNoteSharesResult &b);

inline std::ostream& operator<<(std::ostream& out, const ManageNoteSharesResult& obj)
{
  obj.printTo(out);
  return out;
}

}} // namespace

#endif
